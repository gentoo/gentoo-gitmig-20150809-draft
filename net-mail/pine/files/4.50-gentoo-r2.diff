diff -c -r --new-file pine4.44/README.maildir pine4.44-gentoo/README.maildir
*** pine4.44/README.maildir	Wed Dec 31 18:00:00 1969
--- pine4.44-gentoo/README.maildir	Fri Sep 27 11:24:23 2002
***************
*** 0 ****
--- 1,93 ----
+ Pine 4.0x Maildir c-client module
+ ---------------------------------
+ 
+ Written by Mattias Larsson <ml@techno.org> <mta@freeit.com>
+ 
+ This is the second release of my Maildir driver for Pine 4. It is based
+ on Eric Greens IMAP2bis Maildir driver.
+ 
+ PLEASE NOTE that this driver has only been tested in the IMAP4rev1 daemon
+ before. It was just put into Pine 4.00, and it looks like it works, but it
+ has not been extensively tested. It has been running for 8 months in
+ production in our IMAP4 daemon though.
+ 
+ PLEASE NOTE:
+ 
+ This driver needs to store the UID's of the message in the file somehow. In
+ the earlier versions of this driver this was done by adding a new maildir
+ flag (the ,3 flag), however, this solution was not very good since most
+ other clients could not handle it. Thus I had to find another solution. In
+ this driver I use a pretty radical method. Any file in the maildir with the
+ execute bit set has its UID set in the mtime of the file. So you should not
+ edit the files in here, or in any otherway update the mtime, because then
+ the UID gets changed. Most clients should not do this, so I think this
+ solution is compatible with most other clients (if you find one that isn't,
+ let me know). If you for some reason have to edit a file in the Maildir,
+ delete the ".uidvalidity" file in the root of the Maildir (ie, the dir where
+ you find cur/ new/ and tmp/). Alternatively, edit maildir.c and define the
+ NO_UID_VALIDITY option, which will cause the Maildir to get set new UID's on
+ every start up. Note that if you are running IMAP and Netscape as a client,
+ you can't change the UID's, because Netscape do not support the UID validity
+ flag in the IMAP protocol. So use this with care. 
+ 
+ Please edit the maildir.c file in any case. There are 3 options you can
+ set yourself. The default configuration is not suitable for ISPs. If you are
+ an ISP, or system with many users, you might want to consider setting some
+ of the options different.
+ 
+ Ohh, if there are problems compiling it, let me know, and please let me know
+ what you did to fix it. This thing was developed on Solaris (using both GCC
+ and SunCC, should work with both), but I haven't tried it on any other
+ platform. It is also known to compile cleanly on Linux RH5.1
+ 
+ CONFIGURATION
+ -------------
+ 
+ There are a few configurable options. You find these at the top of the
+ maildir.c file (and it can be found in imap/src/osdep/unix if I'm not all
+ mistaken). Right now, two options are configurable. By default it is
+ configured for ISP use, something that you might want to change if you use
+ it at home.
+ 
+ HOW TO USE
+ ----------
+ 
+ Use it as any other c-client driver. There is some option you want to change
+ if you want all folders to be created as Maildirs (and I can't remember what
+ the option is from the top of my head). Read the pine documentation.
+ 
+ CHANGES
+ -------
+ 
+ Rel 4.  Coredump problem fixed. In release 3 I decided to user the sparep
+ 	in the message cache so no patching of mail.h would be necessary,
+ 	however, PINE uses this pointer internally for other things, causing
+ 	coredumps when used with the Rel 3. patch.
+ 
+ Rel 3.	New way of storing UID's (compatible with ,2 clients).
+ 	Multiple inbox patches applied
+ 
+ Rel 2.  Pine 4 changes.
+ 
+ Rel 1.  Imap4rev 1 driver
+ 
+ FINAL NOTES
+ -----------
+ 
+ I'll try to maintain and release new versions as soon as I have time over,
+ which unfortunately does not happen very often in this business ;)
+ 
+ You can (might) find newer versions of this driver at:
+ 
+ http://www.freeit.com/mta/
+ 
+ 
+ Regards,
+ Daniel Mattias Larsson
+ 
+ e-mail: ml@techno.org
+ ph: +46-707-268785
+ snail-mail:
+ Industrivagen 4
+ SE-194 77 Upplands Vasby
+ SWEDEN
diff -c -r --new-file pine4.44/build~ pine4.44-gentoo/build~
*** pine4.44/build~	Wed Dec 31 18:00:00 1969
--- pine4.44-gentoo/build~	Fri Sep 27 11:40:31 2002
***************
*** 0 ****
--- 1,433 ----
+ #!/bin/sh
+ #
+ # $Id: 4.50-gentoo-r2.diff,v 1.1 2002/12/03 20:26:00 raker Exp $
+ #
+ #            T H E    P I N E    M A I L   S Y S T E M
+ #
+ #   Laurence Lundblade and Mike Seibel
+ #   Networks and Distributed Computing
+ #   Computing and Communications
+ #   University of Washington
+ #   Administration Building, AG-44
+ #   Seattle, Washington, 98195, USA
+ #   Internet: lgl@CAC.Washington.EDU
+ #             mikes@CAC.Washington.EDU
+ #
+ #   Please address all bugs and comments to "pine-bugs@cac.washington.edu"
+ #
+ #
+ #   Pine and Pico are registered trademarks of the University of Washington.
+ #   No commercial use of these trademarks may be made without prior written
+ #   permission of the University of Washington.
+ #
+ #   Pine, Pico, and Pilot software and its included text are Copyright
+ #   1989-2001 by the University of Washington.
+ #
+ #   The full text of our legal notices is contained in the file called
+ #   CPYRIGHT, included with this distribution.
+ #
+ #
+ #   Pine is in part based on The Elm Mail System:
+ #    ***********************************************************************
+ #    *  The Elm Mail System  -  Revision: 2.13                             *
+ #    *                                                                     *
+ #    * 			Copyright (c) 1986, 1987 Dave Taylor               *
+ #    * 			Copyright (c) 1988, 1989 USENET Community Trust    *
+ #    ***********************************************************************
+ # 
+ #
+ 
+ 
+ #
+ #  General build script for Pine
+ #
+ 
+ cat > .bld.hlp <<EOF
+ Usage: build <make-options> <target-platform>
+ 
+ <target-platform> may be one of the ports listed in doc/pine-ports or
+   clean   Clean up object files and such.
+           Also, a good way to rebuild Pine/Pico from scratch.
+ 
+ See the README file for more information.
+ 
+ EOF
+                  
+ 
+ # If no args, build what was built last time.
+ if [ $# -eq 0 ]
+ then
+     if [ -f .bld.args ]
+     then
+ 	set `cat .bld.args`
+     fi
+ else
+     rm -f .bld.args
+ fi
+ 
+ L1=
+ L2=
+ K1=
+ K2=
+ S1=
+ S2=
+ S3=
+ S4=
+ CERTSD=
+ NOSSL=
+ SSL=
+ DEFSSLD=/usr/local/ssl
+ SSLD=
+ NOCC=
+ LLIBS=
+ LFLAGS=
+ NOLDAP=
+ GDIR=
+ AAFLAGS=
+ SAFLAGS=
+ 
+ maketarg="no-target"
+ PHOME=`pwd`
+ 
+ for var in "$@"; do
+   case "$var" in
+  
+     help) cat .bld.hlp
+           exit ;;
+ 
+     clean|???)
+          if [ $maketarg != no-target ]
+          then
+              echo "Can only make one target system at a time"
+              echo Both \""$maketarg"\" and \""$var"\" were given
+              exit
+          else
+              maketarg="$var"
+          fi
+        ;;
+ 
+     NOSSL) NOSSL=1
+ 	   NSSL=NOSSL
+        ;;
+ 
+     NOLDAP) NOLDAP=1
+ 	   NLDAP=NOLDAP
+        ;;
+ 
+     *) makeargs="$makeargs '$var'"
+        case "$var" in
+ 	 CC=*)                   NOCC=1    ;;
+ 	 LDAPLIBS=*)             LLIBS=1   ;;
+ 	 LDAPCFLAGS=*)           LFLAGS=1  ;;
+ 	 GSSDIR=*)               GDIR=1
+ 				 K1="$var" ;;
+ 	 EXTRAAUTHENTICATORS=*)  AAFLAGS=1 ;;
+ 	 SSLTYPE=*)              SAFLAGS=1 ;;
+ 	 SSLDIR=*)               SSLD=`echo "$var" | cut -c8-`  ;;
+ 	 SSLCERTS=*)             CERTSD=`echo "$var" | cut -c10-`
+ 				 S2="$var" ;;
+ 	 SSLINCLUDE=*)           S3="$var" ;;
+ 	 SSLLIB=*)               S4="$var" ;;
+        esac
+        ;;
+ 
+   esac
+ done
+ 
+ 
+ if [ $# -ne 0 ]
+ then
+     case $maketarg in
+ 
+        ???) 
+ 	    echo "$makeargs" "$NSSL" "$NLDAP" $maketarg > .bld.args ;;
+     esac
+ fi
+ 
+ # Set up correct compiler
+ if [ "$NOCC" != "1" ]
+ then
+   case $maketarg in
+      sol)
+  echo "\"Sol\" port no longer exists. Use \"so4\" for Solaris version 2.4 or"
+  echo "lower (SunOS 5.4 or lower) and \"so5\" for Solaris version 2.5 or"
+  echo "higher (SunOS 5.5 or higher)."
+ 	  exit;;
+      gso)
+  echo "\"Gso\" port no longer exists. Use \"gs4\" for Solaris version 2.4 or"
+  echo "lower (SunOS 5.4 or lower) and \"gs5\" for Solaris version 2.5 or"
+  echo "higher (SunOS 5.5 or higher)."
+ 	  exit;;
+      gh9) makeargs="CC=gcc $makeargs" ;;
+      ghp) makeargs="CC=gcc $makeargs" ;;
+      go5) makeargs="CC=gcc $makeargs" ;;
+      gs4) makeargs="CC=gcc $makeargs" ;;
+      gs5) makeargs="CC=gcc $makeargs" ;;
+      gsc) makeargs="CC=gcc $makeargs" ;;
+      gsu) makeargs="CC=gcc $makeargs" ;;
+      gul) makeargs="CC=gcc $makeargs" ;;
+      mnt) makeargs="CC=gcc $makeargs" ;;
+      bs3) makeargs="CC=shlicc $makeargs" ;;
+      nto) makeargs="CC=qcc $makeargs" ;;
+      lyn) [ -f /CYGNUS.bash ] && . /CYGNUS.bash; makeargs="CC=gcc $makeargs" ;;
+        *) makeargs="CC=cc $makeargs" ;;
+   esac
+ fi
+ 
+ # Some ports are common for pico (for example) but different for pine.
+ # For example, port hxd uses hpp port for pico, hpx port for pine, and a
+ # separate hxd port for c-client. Not all of these have been verified to work.
+ case $maketarg in
+    aos) ccltarg=$maketarg; picotarg=bsd;       pinetarg=$picotarg ;;
+    bs2) ccltarg=bsi;       picotarg=$maketarg; pinetarg=$maketarg ;;
+    bs3) ccltarg=$maketarg; picotarg=bs2;       pinetarg=bs2 ;;
+    d41) ccltarg=$maketarg; picotarg=d-g;       pinetarg=$picotarg ;;
+    d54) ccltarg=$maketarg; picotarg=d-g;       pinetarg=$picotarg ;;
+    ghp) ccltarg=$maketarg; picotarg=gh9;       pinetarg=$maketarg ;;
+    go5) ccltarg=$maketarg; picotarg=$maketarg; pinetarg=sc5 ;;
+    gs4) ccltarg=gso;       picotarg=gso;       pinetarg=$maketarg ;;
+    gs5) ccltarg=gso;       picotarg=gso;       pinetarg=$maketarg ;;
+    gsc) ccltarg=$maketarg; picotarg=sco;       pinetarg=sco ;;
+    hpx) ccltarg=$maketarg; picotarg=hpp;       pinetarg=$maketarg ;;
+    hxd) ccltarg=$maketarg; picotarg=hpp;       pinetarg=hpx ;;
+    lnp) ccltarg=$maketarg; picotarg=lnx;       pinetarg=$picotarg ;;
+    lrh) ccltarg=$maketarg; picotarg=lnx;       pinetarg=$picotarg ; DEFSSLD=/usr/share/ssl ;;
+    nx3) ccltarg=$maketarg; picotarg=nxt;       pinetarg=$picotarg ;;
+    os4) ccltarg=$maketarg; picotarg=osf;       pinetarg=$picotarg ;;
+    pt1) ccltarg=psx;       picotarg=$maketarg; pinetarg=$maketarg ;;
+    shp) ccltarg=$maketarg; picotarg=hpp;       pinetarg=$picotarg ;;
+    sg6) ccltarg=$maketarg; picotarg=sgi;       pinetarg=$picotarg ;;
+    slx) ccltarg=$maketarg; picotarg=lnx;       pinetarg=$picotarg ;;
+    sl4) ccltarg=$maketarg; picotarg=lnx;       pinetarg=$picotarg ;;
+    sl5) ccltarg=$maketarg; picotarg=lnx;       pinetarg=$picotarg ;;
+    snx) ccltarg=$maketarg; picotarg=sv4;       pinetarg=sv4 ;;
+    so4) ccltarg=sol;       picotarg=sol;       pinetarg=$maketarg ;;
+    so5) ccltarg=sol;       picotarg=sol;       pinetarg=$maketarg ;;
+    sos) ccltarg=$maketarg; picotarg=osf;       pinetarg=$picotarg ;;
+    ssn) ccltarg=$maketarg; picotarg=sun;       pinetarg=$picotarg ;;
+      *) ccltarg=$maketarg; picotarg=$maketarg; pinetarg=$maketarg ;;
+ esac
+ 
+ echo "make args are $makeargs" "$maketarg"
+ 
+ case $maketarg in
+ 
+    ???) 
+         echo ''
+         cd $PHOME
+ 
+ # Try to automatically include LDAP definitions.
+         if [ "$NOLDAP" != "1" -a -f contrib/ldap-setup -a \
+ 	     \( "$LLIBS" != "1" -o "$LFLAGS" != "1" \) ]
+ 	then
+ 	  contrib/ldap-setup $pinetarg $maketarg
+ # Allow for override of either of these separately.
+ 	  case "$?" in
+ 	    1) if [ "$LLIBS" != "1" ]
+ 	       then
+ 		 L1="'LDAPLIBS=../ldap/libraries/libldap.so ../ldap/libraries/liblber.so ../ldap/libraries/libresolv.so'"
+ 	       fi
+ 	       if [ "$LFLAGS" != "1" ]
+ 	       then
+ 		 L2="'LDAPCFLAGS=-DENABLE_LDAP -I../ldap/include'"
+ 	       fi
+ 	       echo "Including LDAP functionality"
+ 	       ;;
+ 
+ 	    2) if [ "$LLIBS" != "1" ]
+ 	       then
+ 		 L1="'LDAPLIBS=../ldap/libraries/libldap.a'"
+ 	       fi
+ 	       if [ "$LFLAGS" != "1" ]
+ 	       then
+ 		 L2="'LDAPCFLAGS=-DENABLE_LDAP -I../ldap/include'"
+ 	       fi
+ 	       echo "Including LDAP functionality"
+ 	       ;;
+ 
+ 	    3) if [ "$LLIBS" != "1" ]
+ 	       then
+ 		 L1="'LDAPLIBS=-lldap'"
+ 	       fi
+ 	       if [ "$LFLAGS" != "1" ]
+ 	       then
+ 		 L2="'LDAPCFLAGS=-DENABLE_LDAP'"
+ 	       fi
+ 	       echo "Including LDAP functionality"
+ 	       ;;
+ 
+ 	    4) ;;
+ 
+ 	    *) exit 30 ;;
+ 	  esac
+ 	fi
+ 
+ # Try to automatically include Kerberos5 definitions.
+         if [ -d krb5 -a -f contrib/krb5-setup -a \
+              \( "$GDIR" != "1" -o "$AAFLAGS" != "1" \) ]
+ 	then
+ 	  contrib/krb5-setup $pinetarg $maketarg
+ # Allow for override of either of these separately.
+ 	  case "$?" in
+ 	    0) if [ "$GDIR" != "1" ]
+ 	       then
+ 	         K1="GSSDIR=$PHOME/krb5"
+ 	       fi
+ 	       if [ "$AAFLAGS" != "1" ]
+ 	       then
+ 	         K2="'EXTRAAUTHENTICATORS=gss'"
+ 	       fi
+ 	       echo "Including Kerberos5 functionality"
+ 	       ;;
+ 
+ 	    *) exit 30 ;;
+ 	  esac
+ 	fi
+ 
+ # Try to automatically include SSL. To prevent SSL from being automatically
+ # included use "build NOSSL target".
+ # Check for nonempty certs directory from OpenSSL. Also check for 8-hexdigit
+ # symlinks.
+ 	if [ x"$SSLD" = "x" ]
+ 	then
+ 	  SSLD="$DEFSSLD"
+ 	fi
+ 
+ 	if [ x"$CERTSD" = "x" ]
+ 	then
+ 	  CERTSD="$SSLD/certs"
+ 	fi
+ 
+         if [ \( -d "$SSLD" -o -d "$CERTSD" \) -a "$SAFLAGS" != "1" -a "$NOSSL" != "1" ]
+ 	then
+ 	  if [ ! -d "$CERTSD" -o ! -f "$CERTSD"/factory.pem ]
+ 	  then
+ 	    if [ ! -d "$CERTSD" ]
+ 	    then
+ 	      echo ""
+ 	      echo "  Directory "$CERTSD" is missing"
+ 	      echo ""
+ 	    else
+ 	      echo ""
+ 	      echo "  File "$CERTSD"/factory.pem is missing"
+ 	      echo ""
+ 	    fi
+ 	    SSLWARN=1
+ 	  else
+ 	    /bin/ls "$CERTSD" | grep '[0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z][0-9A-Za-z]*\.0' > /dev/null 2>&1
+ 	    if [ $? != "0" ]
+ 	    then
+ 		echo ""
+ 		echo "  No 8-hexdigit symlinks in "$CERTSD""
+ 		echo ""
+ 		SSLWARN=2
+ 	    fi
+ 	  fi
+ 	  case $maketarg in
+ 	    sco|gsc|sc5|go5)   SSL="'SSLTYPE=sco'"  ;;
+ 	    *)                 SSL="'SSLTYPE=unix'" ;;
+ 	  esac
+ 
+ 	  S1="SSLDIR=$SSLD"
+ 	  echo "Including SSL functionality"
+ 	fi
+ 
+         if [ -s c-client ] ; then rm -f c-client ; fi
+         ln -s imap/c-client c-client
+         if [ -s mtest    ] ; then rm -f mtest    ; fi
+         ln -s imap/mtest mtest
+         if [ -s imapd    ] ; then rm -f imapd    ; fi
+         ln -s imap/imapd imapd
+         if [ -s ipopd    ] ; then rm -f ipopd    ; fi
+         ln -s imap/ipopd ipopd
+         echo "Making c-client library, imapd, and ipopd"
+ 	echo $S1 $S2 $S3 $S4 $K1 > imap/SPECIALS
+         cd $PHOME/imap
+         eval echo eval make "$makeargs" "$SSL" "SPECIALS=`cat SPECIALS`" "$K2" $ccltarg
+         eval make "$makeargs" "$SSL" "SPECIALS=`cat SPECIALS`" "$K2" $ccltarg
+         echo ''
+ 
+         echo "Making Pico and Pilot"
+         cd $PHOME/pico
+         eval echo make "$makeargs" -f makefile.$picotarg
+         eval make "$makeargs" -f makefile.$picotarg
+         echo ''
+ 
+         echo "Making Pine and rpload/rpdump".
+         cd $PHOME/pine
+         eval echo make "$makeargs" "$L1" "$L2" -f makefile.$pinetarg
+         eval make "$makeargs" "$L1" "$L2" -f makefile.$pinetarg
+         cd $PHOME
+         if [ ! -d bin ] ;  then    mkdir bin;        fi
+         cd $PHOME/bin
+         rm -f pine mtest imapd pico pilot rpload rpdump ipop2d ipop3d
+         if [ -s ../pine/pine ] ;      then ln ../pine/pine  pine      ; fi
+         if [ -s ../mtest/mtest ] ;    then ln ../mtest/mtest mtest    ; fi
+         if [ -s ../imapd/imapd ] ;    then ln ../imapd/imapd imapd    ; fi
+         if [ -s ../ipopd/ipop2d ] ;   then ln ../ipopd/ipop2d ipop2d  ; fi
+         if [ -s ../ipopd/ipop3d ] ;   then ln ../ipopd/ipop3d ipop3d  ; fi
+         if [ -s ../pico/pico ] ;      then ln ../pico/pico pico       ; fi
+         if [ -s ../pico/pilot ] ;     then ln ../pico/pilot pilot     ; fi
+         if [ -s ../pine/rpload ] ;    then ln ../pine/rpload rpload   ; fi
+         if [ -s ../pine/rpdump ] ;    then ln ../pine/rpdump rpdump   ; fi
+         cd $PHOME
+         echo ''
+         echo "Links to executables are in bin directory:"
+         size bin/pine bin/mtest bin/imapd bin/pico bin/pilot bin/rpdump bin/rpload bin/ipop2d bin/ipop3d
+ 	case $maketarg in
+ 	    mnt)    echo "Fixing stacksizes ..."
+ 		    fixstk 64K bin/pine bin/pico bin/imapd bin/mtest bin/pilot
+ 	esac
+ 	if [ "$SSLWARN" = "1" -o "$SSLWARN" = "2" ]
+ 	then
+ 	    echo ""
+ 	    echo " +---------------------------------------------------------+"
+ 	    echo " |                                                         |"
+ 	    echo " |   WARNING. Certificates may not be installed correctly  |"
+ 	    echo " |   in $CERTSD. This may cause Pine SSL/TLS  |"
+ 	    echo " |   connections to fail because Pine may not be able to   |"
+ 	    echo " |   verify the authenticity of the certificates on the    |"
+ 	    echo " |   server. To compile Pine without SSL support use       |"
+ 	    echo " |                                                         |"
+ 	    echo " |             build NOSSL target                          |"
+ 	    echo " |                                                         |"
+ 	    echo " +---------------------------------------------------------+"
+ 	    echo ""
+ 	    if [ "$SSLWARN" = "2" ]
+ 	    then
+ 	    echo " +---------------------------------------------------------+"
+ 	    echo " |                                                         |"
+ 	    echo " |   (Problem may be missing symlinks normally created     |"
+ 	    echo " |    when OpenSSL is built.)                              |"
+ 	    echo " |                                                         |"
+ 	    echo " +---------------------------------------------------------+"
+ 	    echo ""
+ 	    fi
+ 	fi
+         echo "Done"
+         ;;
+ 
+ 
+     clean) # This only sort of works 
+         rm -f c-client mtest imapd ipopd
+         echo "Cleaning c-client and imapd"
+ 	cd $PHOME/imap
+ 	make clean
+         echo "Cleaning Pine"
+         cd $PHOME/pine
+         make -f makefile.ult clean
+         echo "Cleaning pico"
+         cd $PHOME/pico
+         make $makeargs -f makefile.ult clean
+         echo "Done"
+         cd $PHOME
+         ;;
+ 
+     no-target)
+         echo "No target plaform for which to build Pine given."
+         echo 'Give command "build help" for help.'
+         ;;
+ 
+     *)  echo 'Do not know how to make Pine for target "'$maketarg'".'
+         ;;
+ esac
diff -c -r --new-file pine4.44/imap/src/c-client/mail.h pine4.44-gentoo/imap/src/c-client/mail.h
*** pine4.44/imap/src/c-client/mail.h	Tue Nov 13 13:50:10 2001
--- pine4.44-gentoo/imap/src/c-client/mail.h	Fri Sep 27 11:25:41 2002
***************
*** 692,697 ****
--- 692,698 ----
    unsigned int spare2 : 1;	/* second spare bit */
    unsigned int spare3 : 1;	/* third spare bit */
    void *sparep;			/* spare pointer */
+   void *maildirp;	/* for the Maildir driver */
    unsigned long user_flags;	/* user-assignable flags */
  } MESSAGECACHE;
  
diff -c -r --new-file pine4.44/imap/src/osdep/unix/Makefile pine4.44-gentoo/imap/src/osdep/unix/Makefile
*** pine4.44/imap/src/osdep/unix/Makefile	Tue Nov  6 18:23:48 2001
--- pine4.44-gentoo/imap/src/osdep/unix/Makefile	Fri Sep 27 11:27:32 2002
***************
*** 21,27 ****
  # Command line build parameters
  
  EXTRAAUTHENTICATORS=
! EXTRADRIVERS=mbox
  PASSWDTYPE=std
  SSLTYPE=none
  
--- 21,27 ----
  # Command line build parameters
  
  EXTRAAUTHENTICATORS=
! EXTRADRIVERS=maildir mbox
  PASSWDTYPE=std
  SSLTYPE=none
  
***************
*** 105,111 ****
  # Standard distribution build parameters
  
  DEFAULTAUTHENTICATORS=md5 pla log
! DEFAULTDRIVERS=imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
  
  
  # Normally no need to change any of these
--- 105,111 ----
  # Standard distribution build parameters
  
  DEFAULTAUTHENTICATORS=md5 pla log
! DEFAULTDRIVERS=maildir imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
  
  
  # Normally no need to change any of these
***************
*** 114,121 ****
  BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
! CFLAGS=-g
  
  CAT=cat
  MAKE=make
--- 114,121 ----
  BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o flock.o maildir.o
! CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS)
  
  CAT=cat
  MAKE=make
***************
*** 808,813 ****
--- 808,814 ----
  tenex.o: mail.h misc.h osdep.h tenex.h dummy.h
  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
  utf8.o: mail.h misc.h osdep.h utf8.h
+ maildir.o: mail.h misc.h osdep.h utf8.h
  
  
  # OS-dependent
diff -c -r --new-file pine4.44/imap/src/osdep/unix/dummy.c pine4.44-gentoo/imap/src/osdep/unix/dummy.c
*** pine4.44/imap/src/osdep/unix/dummy.c	Sat Oct 27 01:15:23 2001
--- pine4.44-gentoo/imap/src/osdep/unix/dummy.c	Fri Sep 27 11:31:38 2002
***************
*** 341,353 ****
    char tmp[MAILTMPLEN];
  				/* don't \NoSelect dir if it has a driver */
    if ((attributes & LATT_NOSELECT) && (d = mail_valid (NIL,name,NIL)) &&
!       (d != &dummydriver)) attributes &= ~LATT_NOSELECT;
    if (!contents ||		/* notify main program */
        (!(attributes & LATT_NOSELECT) && (csiz = strlen (contents)) &&
         !stat (dummy_file (tmp,name),&sbuf) && (csiz <= sbuf.st_size) &&
         SAFE_SCAN_CONTENTS (d,tmp,contents,csiz,sbuf.st_size)))
      mm_list (stream,delimiter,name,attributes);
!   return T;
  }
  
  /* Dummy create mailbox
--- 341,357 ----
    char tmp[MAILTMPLEN];
  				/* don't \NoSelect dir if it has a driver */
    if ((attributes & LATT_NOSELECT) && (d = mail_valid (NIL,name,NIL)) &&
! 	  (d != &dummydriver)) {
! 	  	attributes &= ~LATT_NOSELECT;
! 		attributes |= LATT_NOINFERIORS;
! 	}
    if (!contents ||		/* notify main program */
        (!(attributes & LATT_NOSELECT) && (csiz = strlen (contents)) &&
         !stat (dummy_file (tmp,name),&sbuf) && (csiz <= sbuf.st_size) &&
         SAFE_SCAN_CONTENTS (d,tmp,contents,csiz,sbuf.st_size)))
      mm_list (stream,delimiter,name,attributes);
! 	if (attributes & LATT_NOINFERIORS) return NIL;
! 	else return T;
  }
  
  /* Dummy create mailbox
diff -c -r --new-file pine4.44/imap/src/osdep/unix/env_unix.c pine4.44-gentoo/imap/src/osdep/unix/env_unix.c
*** pine4.44/imap/src/osdep/unix/env_unix.c	Wed Oct 17 22:35:20 2001
--- pine4.44-gentoo/imap/src/osdep/unix/env_unix.c	Fri Sep 27 11:10:55 2002
***************
*** 48,54 ****
  				/* flock() emulator is a no-op */
  static short disableFcntlLock = NIL;
  				/* warning on EACCES errors on .lock files */
! static short lockEaccesError = T;
  static short hideDotFiles = NIL;/* hide files whose names start with . */
  				/* advertise filesystem root */
  static short advertisetheworld = NIL;
--- 48,54 ----
  				/* flock() emulator is a no-op */
  static short disableFcntlLock = NIL;
  				/* warning on EACCES errors on .lock files */
! static short lockEaccesError = NIL;
  static short hideDotFiles = NIL;/* hide files whose names start with . */
  				/* advertise filesystem root */
  static short advertisetheworld = NIL;
diff -c -r --new-file pine4.44/imap/src/osdep/unix/env_unix.h pine4.44-gentoo/imap/src/osdep/unix/env_unix.h
*** pine4.44/imap/src/osdep/unix/env_unix.h	Fri Sep 28 19:57:23 2001
--- pine4.44-gentoo/imap/src/osdep/unix/env_unix.h	Fri Sep 27 11:10:55 2002
***************
*** 46,57 ****
  
  
  /*
!  * Attention: all sorcerer's apprentices who think that 0666 is a mistake.
!  * You are wrong.  Read the FAQ.  Do not meddle in the affairs of wizards,
!  * for they are subtle and quick to anger.
   */
  
! #define MANDATORYLOCKPROT 0666	/* don't change this */
  
  /* Function prototypes */
  
--- 46,60 ----
  
  
  /*
!  * Attention: all people who do not care about OS security, and think that
!  * mode 0666 is a correct.  You are wrong.  In modern multiuser systems,
!  * both remote and local security is critically important.  Allowing 0666
!  * lockfiles, allows all sorts of security problems to occur.  Feel free to
!  * meddle with it however, if you do not care about local security.
   */
  
! /* Change this only if you do not want a secure multiuser system */
! #define MANDATORYLOCKPROT 0600	
  
  /* Function prototypes */
  
diff -c -r --new-file pine4.44/imap/src/osdep/unix/flock.c pine4.44-gentoo/imap/src/osdep/unix/flock.c
*** pine4.44/imap/src/osdep/unix/flock.c	Wed Dec 31 18:00:00 1969
--- pine4.44-gentoo/imap/src/osdep/unix/flock.c	Fri Sep 27 11:10:55 2002
***************
*** 0 ****
--- 1,63 ----
+ /* One of many ways to emulate flock() on top of real (good) POSIX locks. */
+ 
+ #ident "$RH: flock.c,v 1.2 2000/08/23 17:07:00 nalin Exp $"
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ #include <fcntl.h>
+ #include <unistd.h>
+ 
+ int flock(int fd, int operation)
+ {
+ 	int i, cmd;
+ 	struct flock l = {0, 0, 0, 0, 0};
+ 	if(operation & LOCK_NB) {
+ 		cmd = F_SETLK;
+ 	} else {
+ 		cmd = F_SETLKW;
+ 	}
+ 	l.l_whence = SEEK_SET;
+ 	switch(operation & (~LOCK_NB)) {
+ 		case LOCK_EX:
+ 			l.l_type = F_WRLCK;
+ 			i = fcntl(fd, cmd, &l);
+ 			if(i == -1) {
+ 				if((errno == EAGAIN) || (errno == EACCES)) {
+ 					errno = EWOULDBLOCK;
+ 				}
+ 			}
+ 			break;
+ 		case LOCK_SH:
+ 			l.l_type = F_RDLCK;
+ 			i = fcntl(fd, cmd, &l);
+ 			if(i == -1) {
+ 				if((errno == EAGAIN) || (errno == EACCES)) {
+ 					errno = EWOULDBLOCK;
+ 				}
+ 			}
+ 			break;
+ 		case LOCK_UN:
+ 			l.l_type = F_UNLCK;
+ 			i = fcntl(fd, cmd, &l);
+ 			if(i == -1) {
+ 				if((errno == EAGAIN) || (errno == EACCES)) {
+ 					errno = EWOULDBLOCK;
+ 				}
+ 			}
+ 			break;
+ 		default:
+ 			i = -1;
+ 			errno = EINVAL;
+ 			break;
+ 	}
+ 	return i; 
+ }
+ 
+ #ifdef FLOCK_EMULATE_IS_MAIN
+ int main(int argc, char **argv)
+ {
+ 	int fd = open(argv[1], O_WRONLY);
+ 	flock(fd, LOCK_EX);
+ 	return 0;
+ }
+ #endif
diff -c -r --new-file pine4.44/imap/src/osdep/unix/maildir.c pine4.44-gentoo/imap/src/osdep/unix/maildir.c
*** pine4.44/imap/src/osdep/unix/maildir.c	Wed Dec 31 18:00:00 1969
--- pine4.44-gentoo/imap/src/osdep/unix/maildir.c	Fri Sep 27 11:38:20 2002
***************
*** 0 ****
--- 1,1144 ----
+ /*
+  * Maildir Module for PINE 4.0x - fourth release, use with CARE! 
+  *
+  * Author:      Mattias Larsson <ml@techno.org>
+  *
+  * Version:     21.07.98
+  *
+  * Please read the README.maildir file before using this module!
+  *
+  * If you have any questions, please e-mail ml@techno.org 
+  *
+  * Multiple inboxes patch by Dean Gaudet <dgaudet@arctic.org>
+  *
+  * =================================================
+  *
+  * Based on the IMAP2 maildir routines by:
+  *
+  * Author:      Eric Green
+  *              Bloodhounds International Inc.
+  *              thrytis@imaxx.net
+  *
+  * Additional contributions from:
+  *              Aidas Kasparas (kaspar@soften.ktu.lt)
+  *
+  * Date:        27 April 1997
+  * Last Edited: 13 June 1997
+  *
+  * Based (heavily) on mh.c and other c-client library files by Mark Crispin:
+  *
+  *              Mark Crispin
+  *              Networks and Distributed Computing
+  *              Computing & Communications
+  *              University of Washington
+  *              Administration Building, AG-44
+  *              Seattle, WA  98195
+  *              Internet: MRC@CAC.Washington.EDU
+  *
+  * Copyright 1995 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* CONFIGURABLE OPTIONS - PLEASE CHECK THESE OUT */
+ 
+ #undef NO_MAILDIR_FIDDLE	/* disallow Maildir with Maildir in the
+ 				name. This is useful in an ISP setup
+ 				using the IMAP daemon. #undef it if you
+ 				are running a normal pine and know what
+ 				you are doing */
+ 
+ #undef NO_ABSOLUTE_PATHS	/* if you define this, all paths
+ 				use your HOMEDIR is the root instead
+ 				of the actual root of the machine. This
+ 				is also useful in an ISP setup with
+ 				IMAP */
+ 
+ #define NO_UID_VALIDITIY	/* define this if you want the UID's not
+ 				to be persistent over sessions. Use this
+ 				if you use another client to read the
+ 				maildir that screws up the special way
+ 				in which we store UIDs. Do not enable
+ 				unless you are sure you need it. */
+ 	
+ /* END CONFIGURATION */
+ 
+ #define MTA_DEBUG	/* debugging sent to stdout */
+ #undef MTA_DEBUG
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include "osdep.h"
+ #include <pwd.h>
+ #include <sys/stat.h>
+ #include <sys/time.h>
+ #include <time.h>
+ #include <sys/types.h>
+ #include <utime.h>
+ #include "maildir.h"
+ #include "misc.h"
+ #include "dummy.h"
+ 
+ /* Driver dispatch used by MAIL */
+ 
+ DRIVER maildirdriver = {
+   "maildir",			/* driver name */
+ 				/* driver flags */
+   DR_MAIL|DR_LOCAL|DR_NOFAST|DR_NAMESPACE,
+   (DRIVER *) NIL,		/* next driver */
+   maildir_valid,			/* mailbox is valid for us */
+   maildir_parameters,		/* manipulate parameters */
+   NIL,			/* scan mailboxes */
+   maildir_list,			/* find mailboxes */
+   maildir_lsub,			/* find subscribed mailboxes */
+   maildir_sub,			/* subscribe to mailbox */
+   maildir_unsub,		/* unsubscribe from mailbox */
+   maildir_create,			/* create mailbox */
+   maildir_delete,			/* delete mailbox */
+   maildir_rename,			/* rename mailbox */
+   NIL,				/* status of mailbox */
+   maildir_open,			/* open mailbox */
+   maildir_close,		/* close mailbox */
+   maildir_fast,			/* fetch message "fast" attributes */
+   NIL,				/* fetch message flags */
+   NIL,				/* fetch overview */
+   NIL,				/* fetch message envelopes */
+   maildir_fetchheader,		/* fetch message header */
+   maildir_fetchtext,		/* fetch message body */
+   NIL,				/* fetch partial message text */
+   NIL,				/* unique identifier */
+   NIL,				/* message number */
+   NIL,				/* modify flags */
+   maildir_flagmsg,		/* per-message modify flags */
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages */
+   NIL,				/* thread messages */
+   maildir_ping,			/* ping mailbox to see if still alive */
+   maildir_check,		/* check for new messages */
+   maildir_expunge,			/* expunge deleted messages */
+   maildir_copy,			/* copy messages to another mailbox */
+   maildir_append,			/* append string message to mailbox */
+   maildir_gc				/* garbage collect stream */
+ };
+ 
+ 				/* prototype stream */
+ MAILSTREAM maildirproto = {&maildirdriver};
+ 
+ /* Check validity of mailbox
+  */
+  
+ DRIVER *maildir_valid (char *name)
+ {
+   return maildir_isvalid(name,T) ? &maildirdriver : NIL;
+ }
+ 
+ int maildir_isvalid (char *name,long justname)
+ {
+   char tmp[MAILTMPLEN];
+   struct stat sbuf;
+   
+   if (!name || (!*name) || 
+       ((*name == '#') && 
+        (*(name+1) == 0 ||
+ 	(*(name+1) != 'm' && *(name+1) != 'M') ||
+ 	(*(name+2) != 'd' && *(name+1) != 'D') ||
+ 	*(name+3) != '/')) || (*name == '.'))
+     return NIL;
+   
+   /* okay, anything containing the name Maildir will be ignored
+      this is to prevent anyone from fiddling with their incoming Maildir
+      directly, it should be accessed via the INBOX alias */
+ 
+   #ifdef NO_MAILDIR_FIDDLE
+   if (strstr(name, ".maildir")) {
+ 	return NIL; 
+ 	}
+   #endif
+  				/* If we are requested only to check 
+   				   if the name is appropriate then we
+   				   have done! */
+   if (justname && *name == '#') return T;
+   
+ 
+ 				/* must be valid local mailbox */
+   if ((*name != '*') && (*name != '{') &&
+       maildir_file (tmp,name) &&
+ 				/* assume its maildir if its a dir */
+       stat (tmp,&sbuf) == 0 && S_ISDIR (sbuf.st_mode))
+     return T;
+ 
+ 				/* INBOX is for default Maildir */
+   if (!strcmp (ucase (strcpy (tmp,name)), "INBOX") &&
+       (stat (maildir_file (tmp,name),&sbuf) == 0) &&
+       S_ISDIR (sbuf.st_mode))
+     return T;
+ 
+   return NIL;
+ }
+ 
+ /* Maildir mail generate file string
+  */
+ 
+ char *maildir_file (char *dst,char *name)
+ {
+   char tmp[MAILTMPLEN];
+   
+   if (strlen (name) > 3 &&	/* safe do other comparisons */
+       (*name == '#') &&
+       (name[1] == 'm' || name[1] == 'M') &&
+       (name[2] == 'd' || name[2] == 'D') &&
+       (name[3] == '/'))
+     name += 4;
+ 
+ #ifdef NO_ABSOLUTE_PATHS  
+   if (*name == '/') {	
+   /* we do not want to accept / absolute paths, so lets strip the first
+      / ... */
+     sprintf(dst,"%s/%s/cur", myhomedir(), name+1);
+ 
+ /*    strncpy (dst, name, MAILTMPLEN - 2);
+     strncat (dst, "/cur", MAILTMPLEN - 2);
+     dst[MAILTMPLEN - 1] = '\0'; */
+   }
+   else
+     sprintf (dst,"%s/%s/cur",myhomedir (),
+ 	    strcmp (ucase (strcpy (tmp, name)), "INBOX") ? name : MAILDIRPATH);
+ #else
+   if (*name == '/') {	
+     strncpy (dst, name, MAILTMPLEN - 2);
+     strncat (dst, "/cur", MAILTMPLEN - 2);
+     dst[MAILTMPLEN - 1] = '\0';
+   }
+   else
+     sprintf (dst,"%s/%s/cur",myhomedir (),
+ 	    strcmp (ucase (strcpy (tmp, name)), "INBOX") ? name : MAILDIRPATH);
+ 
+ #endif 
+   
+   #ifdef MTA_DEBUG
+   printf("maildir_file '%s'\n", dst);
+   #endif
+   return dst;
+ }
+ 
+ /* Maildir open
+  */
+  
+ MAILSTREAM *maildir_open (MAILSTREAM *stream)
+ {
+  char tmp[MAILTMPLEN],tmp2[MAILTMPLEN];
+ 
+  if (!stream) return &maildirproto;
+  if (LOCAL) {		/* recycle stream */
+ 	maildir_close (stream, 0);
+ 	stream->dtb = &maildirdriver;
+ 	mail_free_cache (stream);
+ 	stream->uid_last = 0;       /* default UID validity */
+ 	stream->uid_validity = time (0);
+ 	}
+ 
+ 	stream->uid_validity = 0; /* was time(0) */
+ 
+   if (stream->uid_last < time(0))
+   	stream->uid_last = time (0);  
+   
+     stream->local = fs_get (sizeof (MAILDIRLOCAL));
+   LOCAL->inbox = !strcmp (ucase (strcpy (tmp,stream->mailbox)),"INBOX") ||
+       !strcmp (stream->mailbox,maildir_file (tmp2,"INBOX"));
+   LOCAL->dir = cpystr (maildir_file (tmp,stream->mailbox)); /* copy dir name */
+                                 /* make temporary buffer */
+   LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
+   LOCAL->scantime = 0;          /* not scanned yet */
+   stream->sequence++;
+   stream->nmsgs = stream->recent = 0;
+ 
+   maildir_ping_core (stream);
+   maildir_ping (stream);
+ /*  if (maildir_ping (stream) && !(stream->nmsgs || stream->silent))
+     printf("Mailbox is empty\n");
+ */
+   return stream;
+ 
+ }
+ 
+ /* Maildir ping mailbox
+  */
+ 
+ long maildir_ping_core (MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN];
+   MESSAGECACHE *elt;
+   struct stat sbuf, sbuf2;
+   DIR *dir;
+   struct direct *d;
+   int reloadall = NIL;
+   int uidinvalid = NIL;
+   unsigned long old;
+   long i;
+   long nmsgs = stream->nmsgs;
+   long recent = stream->recent;
+   long nfiles = stream->nmsgs;
+   int silent = stream->silent;
+   char *s, *s2;
+   mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
+ 
+ /*  maildir_copynew (LOCAL->dir);
+  */
+   
+   if (stat (LOCAL->dir,&sbuf) < 0) {
+     sprintf (tmp,"Unable to open maildir: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 
+   /* okay, lets try to figure out the Maildir UID validity. This is done
+      by checking the last modification time of the file .uidvalidity
+      in the rootdir of the Maildir. Any program reordering the files
+      in the directory have to touch this file */
+ 
+   sprintf(tmp, "%s/../.uidvalidity", LOCAL->dir);
+   
+   if (stat (tmp,&sbuf2) < 0) {
+ 	/* no uid validity file found, if uid_validity == 0, we have
+ 	   to set it to something other than 0, and then create the
+ 	   .uidvalidity file for future accesses */
+ 
+ 	if (stream->uid_validity == 0) {
+ 		FILE *fl;
+ 		struct utimbuf tbuf;
+ 		
+ 		stream->uid_validity = time(0);
+ 		tbuf.actime = stream->uid_validity;
+ 		tbuf.modtime = stream->uid_validity;
+ 
+ 		if ((fl = fopen(tmp, "w"))) {
+ 			fclose(fl);
+ 			chmod (tmp, S_IRUSR|S_IWUSR);
+ 			utime(tmp, &tbuf);
+ 			}
+ 		}
+ 		uidinvalid = T; /* UID's are invalid, update them */
+ 	} else {
+ 	/* valid file, lets set UID if uid_validity = 0 */
+ 	if (stream->uid_validity == 0) {
+ 	stream->uid_validity = sbuf2.st_mtime;
+ 		}
+ 	}
+ 
+   #ifdef NO_UID_VALIDITY
+   uidinvalid = T; /* force the UIDs to be invalid and reset every time,
+   		     useful in an environment without imap servers and
+   		     clients that screw up the UIDs.. i'd leave it to
+   		     OFF until I really need it though... */
+   #endif
+ 
+   stream->silent = T;  
+   if (sbuf.st_ctime != LOCAL->scantime) {
+     /* update the message list */
+     struct direct **names = NIL;
+     nfiles = scandir (LOCAL->dir,&names,maildir_select,maildir_namesort);
+ 
+     for (i = 0; i < nfiles; i++) {
+ 
+ 	/* check if file has executable bit set */
+ 	sprintf(tmp, "%s/%s", LOCAL->dir, names[i]->d_name);
+   	stat (tmp,&sbuf2);
+ 	if (sbuf2.st_mode & S_IXUSR) {
+ 		/* executable bit set, modtime is uid */
+ 		if (sbuf2.st_mtime > stream->uid_last)
+ 			stream->uid_last = sbuf2.st_mtime+1;
+ 		}
+ 	/* this is kept for backwards compatibility */
+         if ((s = strstr (names[i]->d_name,":3,")))
+ 		s += 3;
+         if (s && (s2 = strstr (s, ",U"))) {
+       		s2 += 2;
+ 		sscanf(s2, "%d", &old);
+ 		if (old > stream->uid_last) {
+ 			stream->uid_last = old+1;
+ 			}
+ 		}	
+ 	
+     }
+ 
+     mm_critical (stream);	/* go critical */
+     old = stream->uid_last;
+     LOCAL->scantime = sbuf.st_ctime;
+ 
+ 				/* check if old files same */
+     for (i = 0; i < stream->nmsgs; i++) {
+ 
+       if (strcmp ((char *) mail_elt (stream, i + 1)->maildirp,
+ 		  names[i]->d_name)) {
+ 	reloadall = T;
+ 	break;
+       }
+     }
+ 
+     if (reloadall) { /* files are out of order, rebuild cache */
+ 
+       i = 1;
+       while (i <= stream->nmsgs)
+ 				/* clean out cache */
+ 	if ((elt = (MESSAGECACHE *) (*mc) (stream,i,CH_ELT))) {
+ 	  fs_give ((void **) &elt->maildirp);
+ 	  mail_expunged (stream,i);
+ 	}
+ 	else
+ 	  i++;
+       
+       mm_log ("Warning: Mailbox has changed in an unexpected way.  Reloading.",
+ 	      WARN);
+       stream->nmsgs = 0;
+     }
+     nmsgs = stream->nmsgs;
+     
+     stream->nmsgs = nfiles; /* hm? */    
+ 
+     for (i = nmsgs; i < nfiles; i++) {
+ 
+       mail_exists(stream, i+1);
+ 				/* if newly seen, add to list */
+       (elt = mail_elt (stream, i + 1))->maildirp = (long) cpystr (names[i]->d_name);
+        elt->valid = T;
+ 
+       /* grab the flags */
+       if ((s = strstr (names[i]->d_name,":3,"))) {
+ 	s += 3;
+ 	if (strchr (s,'F'))
+ 	  elt->flagged = T;
+ 	if (strchr (s,'R'))
+ 	  elt->answered = T;
+ 	if (strchr (s,'S'))
+ 	  elt->seen = T;
+ 	if (strchr (s,'T'))
+ 	  elt->deleted = T;
+       } else if ((s = strstr (names[i]->d_name,":2,"))) {
+ 	/* this is the :2, id where all files go nowadays */
+ 	s += 3;
+ 	if (strchr (s,'F'))
+ 	  elt->flagged = T;
+ 	if (strchr (s,'R'))
+ 	  elt->answered = T;
+ 	if (strchr (s,'S'))
+ 	  elt->seen = T;
+ 	if (strchr (s,'T'))
+ 	  elt->deleted = T;
+ 	sprintf(tmp, "%s/%s", LOCAL->dir, names[i]->d_name);
+   	stat (tmp,&sbuf2);
+ 	if (sbuf2.st_mode & S_IXUSR) {
+ 		/* executable bit set, modtime is uid */
+ 		elt->private.uid = sbuf2.st_mtime;
+ 		}
+ 	/* and if we could not retrieve UID from modtime, or if
+ 	   UIDs are invalid, go here */
+ 	if (elt->private.uid == 0 || uidinvalid) {
+         	stream->uid_last = (elt = mail_elt (stream,i+1))->private.uid = stream->uid_last+1;
+ 		maildir_flagmsg(stream, elt);
+ 		}	
+ 	s = 0; /* make sure next if statement does not trigger */      
+       	}
+ 
+       if (s)
+       if ((s2 = strstr (s, ",U"))) {
+       	s2 += 2;
+ 	sscanf(s2, "%d", &elt->private.uid);
+ 	if (elt->private.uid == 0 || uidinvalid) {
+         	stream->uid_last = (elt = mail_elt (stream,i+1))->private.uid = stream->uid_last+1;
+ 		maildir_flagmsg(stream, elt);
+ 		}	
+ 	
+       	} else { /* assign new UID */
+         stream->uid_last = (elt = mail_elt (stream,i+1))->private.uid = stream->uid_last+1;
+ 	elt->recent = T;
+ 	recent++;
+ 	maildir_flagmsg(stream, elt); /* store the UID that we assigned to it */
+ 	}	
+ 
+ 
+ 
+     }
+ 
+     mm_nocritical (stream);	/* release critical */
+ 				/* free the names stuff */
+     for (i = 0; i < nfiles; i++)
+       fs_give ((void **) &names[i]);
+     if (names)
+       fs_give ((void **) &names);
+   }
+   stream->silent = silent;
+   mail_exists(stream,nfiles);
+ /*  if (!reloadall)  */
+   	mail_recent (stream,recent);
+ 
+   return T;			/* return that we are alive */
+ }
+ 
+ long maildir_ping (MAILSTREAM *stream)
+ {
+   maildir_copynew (LOCAL->dir);
+   return maildir_ping_core (stream);
+ }
+ 
+ void maildir_copynew (const char *mailbox)
+ {
+   char tmp[MAILTMPLEN],file[MAILTMPLEN],newfile[MAILTMPLEN];
+   DIR *dir;
+   struct dirent *d;
+   struct stat sbuf;
+   
+   sprintf (tmp,"%s/../new",mailbox);
+   if (!(dir = opendir (tmp)))
+     return;
+ 
+   while (d = readdir (dir)) {
+     if (d->d_name[0] == '.')
+       continue;			/* skip .files */
+ 
+     sprintf (file,"%s/%s",tmp,d->d_name);
+ 				/* make sure this is a normal file */
+     if (stat (file,&sbuf) == 0 && S_ISREG (sbuf.st_mode)) {
+       
+       if (strstr (d->d_name,":3,")) /* this message already has flags */
+ 	sprintf (newfile,"%s/%s",mailbox,d->d_name);
+       else
+ 	sprintf (newfile,"%s/%s:3,",mailbox,d->d_name);
+       
+ 				/* move the new mail to the cur dir */
+       if (link (file,newfile) == -1)
+ 	mm_log("Unable to read new mail!",WARN);
+       else
+ 	unlink (file);	
+     }
+   }
+   closedir (dir);
+ }
+ 
+ int maildir_select (struct direct *name)
+ {
+   if (name->d_name[0] != '.')
+     return T;
+ 
+   return NIL;
+ }
+ 
+ int maildir_namesort (struct direct **d1,struct direct **d2)
+ {
+ /* this maildir module is kind of lame and expects files it just moved
+  * from new/ to cur/ to show up at the end of the sorting... this mostly
+  * works fine when the timestamp is less than 1000000000 -- you can just
+  * strcmp.  but when the timestamp went past that point we need to do
+  * this convoluted sort.
+  */
+   unsigned long t1, t2;
+ 
+   t1 = strtoul((*d1)->d_name, NULL, 10);
+   t2 = strtoul((*d2)->d_name, NULL, 10);
+   if (t1 == t2) {
+     return strcmp ((*d1)->d_name,(*d2)->d_name);
+   }
+   else if (t1 > t2) {
+     return 1;
+   }
+   return -1;
+ }
+ 
+ 
+ /* Maildir garbage collect stream
+  */
+ 
+ void maildir_gc (MAILSTREAM *stream,long gcflags)
+ {
+   unsigned long i;
+   
+   if (gcflags & GC_TEXTS) {	/* garbage collect texts? */
+ 				/* flush texts from cache */
+ /*    if (LOCAL->hdr) fs_give ((void **) &LOCAL->hdr);
+ //    if (stream->text) fs_give ((void **) &stream->text);
+ //    stream->msgno = 0;		invalidate stream text
+ */
+   }
+ }
+ 
+ /* Maildir close
+  */
+ 
+ void maildir_close (MAILSTREAM *stream, long options)
+ {
+   MESSAGECACHE *elt;
+   int i;
+   mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
+  
+ /*  CL_EXPUNGE OPTION SUPPORT HERE SOMEWHERE! */
+ 				/* clean out the cached paths */
+   for (i = 1; i <= stream->nmsgs; i++)
+     if ((elt = (MESSAGECACHE *) (*mc) (stream,i,CH_ELT)) && elt->maildirp) {
+       fs_give ((void **) &elt->maildirp);
+       elt->maildirp = 0; /* otherwise pine coredumps */  
+ 	}  
+   
+   if (LOCAL) {			/* only if a stream is open */
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+     maildir_gc (stream,GC_TEXTS); /* free local cache */
+ 				/* free local scratch buffer */
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+ 				/* nuke the local data */
+     fs_give ((void **) &stream->local);
+     stream->dtb = NIL;		/* log out the DTB */
+   }
+ }
+ 
+ void maildir_check (MAILSTREAM *stream)
+ {
+   /* Perhaps in the future this will preserve flags */
+   if (maildir_ping (stream)) mm_log ("Check completed",(long) NIL);   
+ }
+ 
+ long maildir_fetchtext (MAILSTREAM *stream,unsigned long msgno,STRING *bs, long flags)
+ {
+   unsigned long i;
+   MESSAGECACHE *elt;
+                                 /* UID call "impossible" */
+   if (flags & FT_UID) return NIL;
+   elt = mail_elt (stream,msgno);/* get elt */
+                                 /* snarf message if don't have it yet */
+   if (!elt->private.msg.text.text.data) {
+     maildir_fetchheader (stream,msgno,&i,flags);
+     if (!elt->private.msg.text.text.data) return NIL;
+   }
+   if (!(flags & FT_PEEK)) {     /* mark as seen */
+     mail_elt (stream,msgno)->seen = T;
+     maildir_flagmsg (stream, mail_elt(stream,msgno));
+     mm_flags (stream,msgno);
+   }
+   if (!elt->private.msg.text.text.data) return NIL;
+   INIT (bs,mail_string,elt->private.msg.text.text.data,
+         elt->private.msg.text.text.size);
+   return T;
+ }
+ 
+ 
+ /* Maildir fetch message header
+  */
+ 
+ char *maildir_fetchheader (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags)
+ {
+   unsigned long i,hdrsize;
+   int fd;
+   char *t;
+   char tmp[MAILTMPLEN];
+   char *s,*b;
+   struct stat sbuf;
+   struct tm *tm;
+   MESSAGECACHE *elt;
+   *length = 0;                  /* default to empty */
+   if (flags & FT_UID) return "";/* UID call "impossible" */
+   elt = mail_elt (stream,msgno);/* get elt */
+   if (!elt->private.msg.header.text.data) {
+ 
+ /*    maildir_gc (stream,GC_TEXTS);  invalidate current cache */
+ 				/* build message file name */
+     sprintf (tmp,"%s/%s",LOCAL->dir,(char *) elt->maildirp);
+     if ((fd = open (tmp,O_RDONLY,NIL)) >= 0) {
+       fstat (fd,&sbuf);		/* get size of message */
+ 				/* make plausible IMAPish date string */
+       tm = gmtime (&sbuf.st_mtime);
+       elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+       elt->year = tm->tm_year + 1900 - BASEYEAR;
+       elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+       elt->seconds = tm->tm_sec;
+       elt->zhours = 0; elt->zminutes = 0;
+ 				/* slurp message */
+       read (fd,s = (char *) fs_get (sbuf.st_size + 1),sbuf.st_size);
+       s[sbuf.st_size] = '\0';	/* tie off file */
+       close (fd);		/* close file */
+ 
+       for (i = 0,b = s; *b && !(i && (*b == '\n')); i = (*b++ == '\n'));
+       hdrsize = (*b ? ++b:b)-s;	/* number of header bytes */
+ 
+       elt->rfc822_size =          /* size of entire message in CRLF form */
+        (elt->private.msg.header.text.size =
+         strcrlfcpy ((char **) &elt->private.msg.header.text.data,&i,s,
+                     hdrsize)) +
+           (elt->private.msg.text.text.size =
+            strcrlfcpy ((char **) &elt->private.msg.text.text.data,&i,b,
+                        sbuf.st_size - hdrsize));
+       fs_give ((void **) &s);
+     } else return "";
+ 
+   }
+ 
+   *length = elt->private.msg.header.text.size;
+   return (char *) elt->private.msg.header.text.data;
+ }
+ 
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i,j;
+ 				/* ugly and slow */
+   if (stream && LOCAL && ((flags & FT_UID) ?
+ 			  mail_uid_sequence (stream,sequence) :
+ 			  mail_sequence (stream,sequence)))
+     for (i = 1; i <= stream->nmsgs; i++)
+       if (mail_elt (stream,i)->sequence) maildir_fetchheader (stream,i,&j,NIL);
+ }
+ 
+ /* Maildir find list of subscribed mailboxes
+  * Accepts: mail stream
+  *	    pattern to search
+  */
+ 
+ void maildir_list (MAILSTREAM *stream,char *ref, char *pat)
+ {
+   return;
+ }
+ 
+ void *maildir_parameters (long function,void *value)
+ {
+   return NIL;
+ }
+ 
+ long maildir_create (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN];
+   char err[MAILTMPLEN];
+   char *s, *s2;
+   int fnlen, i;
+   char *subdir_names[] = {"/cur","/new","/tmp",NULL};
+ 
+ 				/* must not already exist */
+   if (access (maildir_file (tmp,mailbox),F_OK) == 0) {
+     sprintf (err,"Can't create mailbox %s: mailbox already exists",mailbox);
+     mm_log (err,ERROR);
+     return NIL;
+   }
+   
+   maildir_file (tmp,mailbox);	/* get file name */
+   fnlen = strlen (tmp);
+   /*syslog(LOG_INFO, "fname: '%s'", tmp);*/
+   tmp[fnlen - 4] = '\0';	/* making main directory's name */
+   fnlen -= 4;
+ 
+   /* okay, try to add support for adding hiearchys of directories, this
+      is done by scanning for /'s.... */
+      
+   /*syslog(LOG_INFO, "tmp '%s'", tmp);*/
+   s = tmp;
+ 
+   while ((s = strstr(s, "/")) != 0) {
+ 	/*syslog(LOG_INFO, "Before make: '%s'", s);*/
+   	*s = '\0';
+   	/*syslog(LOG_INFO, "Trying to make: '%s'", tmp);*/
+ 	if (mkdir (tmp,0700) && *s != '\0') /* trying to make the dir */
+ 	  if (errno != EEXIST) {
+ 	    sprintf (err,"Can't create mailbox %s: %s %s",
+ 		     mailbox,tmp,strerror (errno));
+     	     mm_log (err,ERROR);
+              return NIL;
+ 	  }
+   	*s = '/';
+ 	s++;
+   	} 
+ 
+   if (mkdir (tmp,0700)) {	/* try to make new dir */
+     sprintf (err,"Can't create mailbox %s: %s %s",
+ 	     mailbox,tmp,strerror (errno));
+     mm_log (err,ERROR);
+     return NIL;
+   }
+ 
+   /*syslog(LOG_INFO, "create maildir");*/
+   for (i = 0; subdir_names[i]; i++) {
+     strcpy (tmp + fnlen,subdir_names[i]);
+ 
+     if (mkdir (tmp,0700)) {	/* try to make new dir */
+       sprintf (err,"Can't create mailbox %s: %s %s",
+ 	       mailbox,tmp,strerror (errno));
+       mm_log (err,ERROR);
+       return NIL;
+     }
+   }
+ 
+   return T;			/* return success */
+ }
+ 
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+   char oldfile[MAILTMPLEN],newfile[MAILTMPLEN],fn[MAILTMPLEN];
+   struct utimbuf tbuf;
+   char *s;
+ 
+                                 /* build the new filename */
+   sprintf (oldfile,"%s/%s",LOCAL->dir,(char *) elt->maildirp);
+   if ((s = strchr ((char *) elt->maildirp,':'))) *s = '\0';
+   sprintf (fn,"%s:2,%s%s%s%s",(char *) elt->maildirp,elt->flagged ? "F" : "",
+            elt->answered ? "R" : "",elt->seen ? "S" : "",
+            elt->deleted ? "T" : "");
+   sprintf (newfile,"%s/%s",LOCAL->dir,fn);
+                                 /* rename the file with new flags */
+   if (rename (oldfile,newfile) < 0) {
+     sprintf(oldfile,"Unable to write flags to disk: %s",strerror (errno));
+     mm_log(oldfile,ERROR);
+     return;
+   }
+                                 /* update the file name in cache */
+   fs_give ((void **) &elt->maildirp);
+   elt->maildirp = (long) cpystr (fn);
+ 
+   /* fix the UID on the file */
+   tbuf.actime = elt->private.uid;
+   tbuf.modtime = elt->private.uid;
+   chmod (newfile, S_IRUSR|S_IWUSR|S_IXUSR);
+   utime (newfile, &tbuf);
+ 
+ }
+ 
+ void maildir_expunge (MAILSTREAM *stream)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i = 1;
+   unsigned long n = 0;
+   unsigned long recent = stream->recent;
+   
+   maildir_gc (stream,GC_TEXTS);	/* invalidate texts */
+   mm_critical (stream);		/* go critical */
+   while (i <= stream->nmsgs) {	/* for each message */
+ 				/* if deleted, need to trash it */
+     if ((elt = mail_elt (stream,i))->deleted) {
+       sprintf (LOCAL->buf,"%s/%s",LOCAL->dir,(char *) elt->maildirp);
+       if (unlink (LOCAL->buf)) {/* try to delete the message */
+ 	sprintf (LOCAL->buf,"Expunge of message %ld failed, aborted: %s",i,
+ 		 strerror (errno));
+ 	mm_log (LOCAL->buf,WARN);
+ 	break;
+       }
+ 				/* free the cached filename */
+       if (elt->maildirp) {
+ 	      fs_give ((void **) &elt->maildirp);
+ 	      elt->maildirp = 0; /* otherwise pine coredumps */
+ 		}
+       if (elt->recent) --recent;/* if recent, note one less recent message */
+       mail_expunged (stream,i);	/* notify upper levels */
+       n++;			/* count up one more expunged message */
+     }
+     else i++;			/* otherwise try next message */
+   }
+   if (n) {			/* output the news if any expunged */
+     sprintf (LOCAL->buf,"Expunged %ld messages",n);
+     mm_log (LOCAL->buf,(long) NIL);
+   }
+   else mm_log ("No messages deleted, so no update needed",(long) NIL);
+   mm_nocritical (stream);	/* release critical */
+ 				/* notify upper level of new mailbox size */
+   mail_exists (stream,stream->nmsgs);
+   mail_recent (stream,recent);
+ }
+ 
+ /* dont forget to process options in here */
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   STRING st;
+   MESSAGECACHE *elt;
+   struct stat sbuf;
+   int fd;
+   long i;
+   char *s,tmp[MAILTMPLEN];
+ 				/* copy the messages */
+   if ((options & CP_UID) ? mail_uid_sequence (stream, sequence) : 
+   	mail_sequence (stream,sequence)) 
+   for (i = 1; i <= stream->nmsgs; i++)
+     if ((elt = mail_elt (stream,i))->sequence) {
+       sprintf (LOCAL->buf,"%s/%s",LOCAL->dir,(char *) elt->maildirp);
+       if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return NIL;
+       fstat (fd,&sbuf);		/* get size of message */
+ 				/* slurp message */
+       read (fd,s = (char *) fs_get (sbuf.st_size +1),sbuf.st_size);
+       s[sbuf.st_size] = '\0';	/* tie off file */
+       close (fd);		/* flush message file */
+       INIT (&st,mail_string,(void *) s,sbuf.st_size);
+       sprintf (LOCAL->buf,"%s%s%s%s%s)",
+ 	       elt->seen ? " \\Seen" : "",
+ 	       elt->deleted ? " \\Deleted" : "",
+ 	       elt->flagged ? " \\Flagged" : "",
+ 	       elt->answered ? " \\Answered" : "",
+ 	       (elt->seen || elt->deleted || elt->flagged || elt->answered) ?
+ 	       "" : " ");
+       LOCAL->buf[0] = '(';	/* open list */
+       mail_date (tmp,elt);	/* generate internal date */
+       if (!maildir_append (stream,mailbox,LOCAL->buf,tmp,&st)) {
+ 	fs_give ((void **) &s);	/* give back temporary space */
+ 	return NIL;
+       }
+       fs_give ((void **) &s);	/* give back temporary space */
+     }
+   return T;			/* return success */
+ }
+ 
+ long maildir_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		   STRING *message)
+ {
+   int fd;
+   char c,*s;
+   char tmp[MAILTMPLEN],file[MAILTMPLEN],path1[MAILTMPLEN],path2[MAILTMPLEN];
+   MESSAGECACHE elt;
+   long i;
+   long size = 0;
+   long ret = LONGT;
+   short uf = 0;
+   
+   /*  
+      This is intentionaly made static.  Users can ask to save a LOT of messages
+      at once and this program can do that within one second. Dan's assumption
+      that time+pid+hostname always will be unique stops being true in this
+      case. So we will add yet another number to host part of message file's
+      name. Hostname is used only to make filename unique and Dan  explicitly
+      says that "<...>  Other than this [skipping filenames starting at dot] ,
+      readers should not attempt to parse filenames. <...>". Therefore this 
+      addition should be no problem. Am I right, Dan?   --AK
+   */ 
+   
+   static unsigned int transact = 0;
+ 
+   if (flags) 			/* get flags if given */
+     uf = maildir_getflags (user_flags (&maildirproto),flags);
+ 
+ /*  if (date) {			want to preserve date?
+     //syslog(LOG_INFO, "date: '%s'", date);
+ 				// yes, parse date into an elt
+     if (!mail_parse_date (&elt,date)) {
+       sprintf (tmp,"Bad date in append: %s",date);
+       mm_log (tmp,ERROR);
+       return NIL;
+     }
+   } */
+ 				/* N.B.: can't use LOCAL->buf for tmp */
+ 				/* make sure valid mailbox */
+   if (!maildir_isvalid (mailbox, NIL)) {
+     sprintf (tmp,"Not a valid Maildir mailbox: %s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* build file name we will use */
+   sprintf (file,"%u.%d.%09u.%s:3,%s%s%s%s",
+ 	   time (0),getpid (),transact++,mylocalhost (),
+ 	   uf&fFLAGGED ? "F" : "",uf&fANSWERED ? "R" : "",
+ 	   uf&fSEEN ? "S" : "",uf&fDELETED ? "T" : "");
+ 				/* build tmp file name */
+   sprintf (path1,"%s/../tmp/%s",maildir_file (tmp,mailbox),file);
+   
+   if ((fd = open (path1,O_WRONLY|O_CREAT|O_EXCL,S_IREAD|S_IWRITE)) < 0) {
+     sprintf (tmp,"Can't open append mailbox: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   i = SIZE (message);		/* get size of message */
+   s = (char *) fs_get (i + 1);	/* get space for the data */
+ 				/* copy the data w/o CR's */
+   while (i--) if ((c = SNX (message)) != '\015') s[size++] = c;
+   mm_critical (stream);		/* go critical */
+ 				/* write the data */
+   if ((write (fd,s,size) < 0) || fsync (fd)) {
+     unlink (path1);		/* delete message */
+     sprintf (tmp,"Message append failed: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     ret = NIL;
+   }
+ 				/* build final filename to use */
+   sprintf (path2,"%s/../new/%s",maildir_file (tmp,mailbox),file);
+   if (link (path1,path2) < 0) {
+     sprintf (tmp,"Message append failed: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     ret = NIL;
+   }
+   unlink (path1);
+   
+   close (fd);			/* close the file */
+   mm_nocritical (stream);	/* release critical */
+   fs_give ((void **) &s);	/* flush the buffer */
+   return ret;
+ }
+ 
+ short bezerk_getflags (MAILSTREAM *stream,char *flag)
+ {
+   char *t,tmp[MAILTMPLEN],err[MAILTMPLEN];
+   short f = 0;
+   short i,j;
+   if (flag && *flag) {		/* no-op if no flag string */
+ 				/* check if a list and make sure valid */
+     if ((i = (*flag == '(')) ^ (flag[strlen (flag)-1] == ')')) {
+       mm_log ("Bad flag list",ERROR);
+       return NIL;
+     }
+ 				/* copy the flag string w/o list construct */
+     strncpy (tmp,flag+i,(j = strlen (flag) - (2*i)));
+     tmp[j] = '\0';
+     t = ucase (tmp);		/* uppercase only from now on */
+ 
+     while (t && *t) {		/* parse the flags */
+       if (*t == '\\') {		/* system flag? */
+ 	switch (*++t) {		/* dispatch based on first character */
+ 	case 'S':		/* possible \Seen flag */
+ 	  if (t[1] == 'E' && t[2] == 'E' && t[3] == 'N') i = fSEEN;
+ 	  t += 4;		/* skip past flag name */
+ 	  break;
+ 	case 'D':		/* possible \Deleted flag */
+ 	  if (t[1] == 'E' && t[2] == 'L' && t[3] == 'E' && t[4] == 'T' &&
+ 	      t[5] == 'E' && t[6] == 'D') i = fDELETED;
+ 	  t += 7;		/* skip past flag name */
+ 	  break;
+ 	case 'F':		/* possible \Flagged flag */
+ 	  if (t[1] == 'L' && t[2] == 'A' && t[3] == 'G' && t[4] == 'G' &&
+ 	      t[5] == 'E' && t[6] == 'D') i = fFLAGGED;
+ 	  t += 7;		/* skip past flag name */
+ 	  break;
+ 	case 'A':		/* possible \Answered flag */
+ 	  if (t[1] == 'N' && t[2] == 'S' && t[3] == 'W' && t[4] == 'E' &&
+ 	      t[5] == 'R' && t[6] == 'E' && t[7] == 'D') i = fANSWERED;
+ 	  t += 8;		/* skip past flag name */
+ 	  break;
+ 	default:		/* unknown */
+ 	  i = 0;
+ 	  break;
+ 	}
+ 				/* add flag to flags list */
+ 	if (i && ((*t == '\0') || (*t++ == ' '))) f |= i;
+       }
+       else {			/* no user flags yet */
+ 	t = strtok (t," ");	/* isolate flag name */
+ 	sprintf (err,"Unknown flag: %.80s",t);
+ 	t = strtok (NIL," ");	/* get next flag */
+ 	mm_log (err,ERROR);
+       }
+     }
+   }
+   return f;
+ }
+ 
+ short maildir_getflags (MAILSTREAM *stream,char *flag)
+ {
+   return bezerk_getflags (stream,flag); /* nothing exciting, reuse old code */
+ }
+ 
+ long maildir_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   DIR *dirp;
+   struct direct *d;
+   int i,j;
+   char tmp[MAILTMPLEN],err[MAILTMPLEN];
+   char *subdir_names[] = {"cur/","new/","tmp/",NULL};
+ 
+ 				/* check if mailbox even exists */
+   if (!maildir_isvalid (mailbox,NIL)) {
+ /*    sprintf (tmp,"Can't delete mailbox %s: no such mailbox",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL; */
+     /*syslog(LOG_INFO, "Invalid maildir in delete()"); */
+     return T; /* well.. a stupid hack to get by a problem in netscape ..
+     		it remembers folders locally, and if a folder is deleted on
+     		another machine, you have no way removing it on any other
+     		netscapes... */
+   }
+ 
+ 				/* get name of directory */
+   i = strlen (maildir_file (tmp,mailbox)) + 1;
+   for (j = 0; subdir_names[j]; j++) {
+     strcpy (tmp + i - 4,subdir_names[j]);
+     if (dirp = opendir (tmp)) {	/* open directory */
+       while (d = readdir (dirp))	/* empty the directory */
+ 	if (strcmp (d->d_name,".") && strcmp (d->d_name,"..")) {
+ 	  strcpy (tmp + i,d->d_name);
+ 	  /*syslog(LOG_INFO, "unlink1: '%s'");*/
+ 	  unlink (tmp);
+ 	}
+       closedir (dirp);		/* flush directory */
+     }
+ 				/* remove the subdir */
+     tmp[i + 3] = '\0';
+     /*syslog(LOG_INFO, "tmp: '%s'", tmp);*/
+     if (rmdir (tmp)) {
+     /*  sprintf (err,"Can't delete directory %s: %s",tmp,strerror (errno));
+       mm_log (err,ERROR);*/
+     }
+   }
+ 
+ 				/* try to remove the directory */
+   *(tmp + i - 5) = '\0';
+   /*syslog(LOG_INFO, "tmp2: '%s'", tmp);*/
+   if (rmdir (tmp)) {
+ /*    sprintf (err,"Can't delete mailbox %s: %s",mailbox,strerror (errno));
+     mm_log (err,ERROR);
+     return NIL; */
+   }
+   return T;			/* return success */
+ }
+ 
+ long maildir_rename (MAILSTREAM *stream,char *old,char *new)
+ {
+   char tmp[MAILTMPLEN],tmpnew[MAILTMPLEN];
+ 
+ 				/* old mailbox name must be valid */
+   if (!maildir_isvalid (old,NIL)) {
+     sprintf (tmp,"Can't rename mailbox %s: no such mailbox",old);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 
+ 				/* new mailbox name must not exist */
+   if (access (maildir_file (tmp,new),F_OK) == 0) {
+     sprintf (tmp,"Can't rename to mailbox %s: destination already exists",new);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 
+ 				/* try to rename the directory */
+   if (rename (maildir_file (tmp,old),maildir_file (tmpnew,new))) {
+     sprintf (tmp,"Can't rename mailbox %s to %s: %s",old,new,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ long maildir_sub (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN];
+   return sm_subscribe (mailbox);
+ }
+ 
+ long maildir_unsub (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN];
+   return sm_unsubscribe (mailbox);
+ }
+ 
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+  void *sdb = NIL;
+   char *s;
+                                 /* get canonical form of name */
+   if ((s = sm_read (&sdb))) {
+     do if (pmatch_full (s,pat,'/')) mm_lsub (stream,'/',s,NIL);
+     while (s = sm_read (&sdb)); /* until no more subscriptions */
+   }
+ 
+ }
diff -c -r --new-file pine4.44/imap/src/osdep/unix/maildir.h pine4.44-gentoo/imap/src/osdep/unix/maildir.h
*** pine4.44/imap/src/osdep/unix/maildir.h	Wed Dec 31 18:00:00 1969
--- pine4.44-gentoo/imap/src/osdep/unix/maildir.h	Fri Sep 27 11:32:42 2002
***************
*** 0 ****
--- 1,56 ----
+ /*
+  * Please read maildir.c for license and information
+  *
+  */
+ 
+ #define MAILDIRPATH ".maildir"
+ 	
+ typedef struct maildir_local {
+   unsigned int inbox : 1;	/* if it is an INBOX or not */
+   unsigned int dirty : 1;	/* diskcopy needs updating */
+   char *dir;			/* mail directory name */
+   char *buf;			/* temporary buffer */
+   char *hdr;			/* current header */
+   unsigned long buflen;		/* current size of temporary buffer */
+   time_t scantime;		/* last time directory scanned */
+ } MAILDIRLOCAL;
+ 
+ /* Convenient access to local data */
+ 
+ #define LOCAL ((MAILDIRLOCAL *) stream->local)
+ 
+ /* Function prototypes */
+ 
+ DRIVER *maildir_valid (char *name);
+ int maildir_isvalid (char *name,long justname);
+ MAILSTREAM *maildir_open (MAILSTREAM *stream);
+ void maildir_gc (MAILSTREAM *stream,long gcflags);
+ void maildir_close (MAILSTREAM *stream, long options);
+ long maildir_ping (MAILSTREAM *stream);
+ long maildir_ping_core (MAILSTREAM *stream);
+ void maildir_check (MAILSTREAM *stream);
+ long maildir_fetchtext (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
+ char *maildir_fetchheader (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags);
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags);
+ void maildir_list (MAILSTREAM *stream,char *ref,char *pat);
+ void *maildir_parameters (long function,void *value);
+ long maildir_create (MAILSTREAM *stream,char *mailbox);
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt);
+ void maildir_expunge (MAILSTREAM *stream);
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
+ long maildir_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+                    STRING *message);
+ short maildir_getflags (MAILSTREAM *stream,char *flag);
+ long maildir_delete (MAILSTREAM *stream,char *mailbox);
+ long maildir_rename (MAILSTREAM *stream,char *old,char *new);
+ long maildir_sub (MAILSTREAM *stream,char *mailbox);
+ long maildir_unsub (MAILSTREAM *stream,char *mailbox);
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat);
+ 
+ /* utility functions */
+ char *maildir_file (char *dst,char *name);
+ void maildir_copynew (const char *mailbox);
+ int maildir_select (struct direct *name);
+ int maildir_namesort (struct direct **d1,struct direct **d2);
+ void maildir_listwork(char *name, MAILSTREAM *stream, char *s2, char *subdir, int flag);
diff -c -r --new-file pine4.44/imap/src/osdep/unix/mh.c pine4.44-gentoo/imap/src/osdep/unix/mh.c
*** pine4.44/imap/src/osdep/unix/mh.c	Fri Sep 28 19:57:34 2001
--- pine4.44-gentoo/imap/src/osdep/unix/mh.c	Fri Sep 27 11:10:55 2002
***************
*** 21,27 ****
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! extern int errno;		/* just in case */
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
--- 21,28 ----
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! #include <time.h>
! 
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
diff -c -r --new-file pine4.44/imap/src/osdep/unix/mx.c pine4.44-gentoo/imap/src/osdep/unix/mx.c
*** pine4.44/imap/src/osdep/unix/mx.c	Fri Sep 28 19:57:38 2001
--- pine4.44-gentoo/imap/src/osdep/unix/mx.c	Fri Sep 27 11:10:55 2002
***************
*** 21,27 ****
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! extern int errno;		/* just in case */
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
--- 21,27 ----
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! #include <time.h>
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
diff -c -r --new-file pine4.44/imap/src/osdep/unix/news.c pine4.44-gentoo/imap/src/osdep/unix/news.c
*** pine4.44/imap/src/osdep/unix/news.c	Fri Sep 28 19:57:40 2001
--- pine4.44-gentoo/imap/src/osdep/unix/news.c	Fri Sep 27 11:10:55 2002
***************
*** 21,27 ****
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! extern int errno;		/* just in case */
  #include "mail.h"
  #include "osdep.h"
  #include <sys/stat.h>
--- 21,27 ----
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
! #include <time.h>
  #include "mail.h"
  #include "osdep.h"
  #include <sys/stat.h>
diff -c -r --new-file pine4.44/imap/src/osdep/unix/os_lnx.c pine4.44-gentoo/imap/src/osdep/unix/os_lnx.c
*** pine4.44/imap/src/osdep/unix/os_lnx.c	Fri Sep 28 19:57:58 2001
--- pine4.44-gentoo/imap/src/osdep/unix/os_lnx.c	Fri Sep 27 11:10:55 2002
***************
*** 23,28 ****
--- 23,29 ----
  #include "osdep.h"
  #include <stdio.h>
  #include <sys/time.h>
+ #include <time.h>
  #include <sys/stat.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
diff -c -r --new-file pine4.44/imap/src/osdep/unix/os_slx.c pine4.44-gentoo/imap/src/osdep/unix/os_slx.c
*** pine4.44/imap/src/osdep/unix/os_slx.c	Fri Sep 28 19:58:13 2001
--- pine4.44-gentoo/imap/src/osdep/unix/os_slx.c	Fri Sep 27 11:37:35 2002
***************
*** 23,28 ****
--- 23,29 ----
  #include "osdep.h"
  #include <stdio.h>
  #include <sys/time.h>
+ #include <time.h>
  #include <sys/stat.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
diff -c -r --new-file pine4.44/imap/src/osdep/unix/phile.c pine4.44-gentoo/imap/src/osdep/unix/phile.c
*** pine4.44/imap/src/osdep/unix/phile.c	Fri Sep 28 19:58:20 2001
--- pine4.44-gentoo/imap/src/osdep/unix/phile.c	Fri Sep 27 11:10:55 2002
***************
*** 21,28 ****
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
- extern int errno;		/* just in case */
  #include <signal.h>
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
--- 21,28 ----
  #include <stdio.h>
  #include <ctype.h>
  #include <errno.h>
  #include <signal.h>
+ #include <time.h>
  #include "mail.h"
  #include "osdep.h"
  #include <pwd.h>
diff -c -r --new-file pine4.44/pico/osdep/term.cap pine4.44-gentoo/pico/osdep/term.cap
*** pine4.44/pico/osdep/term.cap	Thu Jun 21 12:48:09 2001
--- pine4.44-gentoo/pico/osdep/term.cap	Fri Sep 27 11:10:55 2002
***************
*** 141,148 ****
       */
      kpinsert("\033[4J", KEY_PGUP, 1);
      kpinsert("\033[3J", KEY_PGDN, 1);
!     kpinsert("\033[2J", KEY_HOME, 1);
!     kpinsert("\033[N",  KEY_END, 1);
  
      /* 
       * ANSI mode.
--- 141,148 ----
       */
      kpinsert("\033[4J", KEY_PGUP, 1);
      kpinsert("\033[3J", KEY_PGDN, 1);
!     kpinsert("\033[1~", KEY_HOME, 1);
!     kpinsert("\033[4~", KEY_END, 1);
  
      /* 
       * ANSI mode.
diff -c -r --new-file pine4.44/pico/osdep/term.inf pine4.44-gentoo/pico/osdep/term.inf
*** pine4.44/pico/osdep/term.inf	Thu Jun 21 12:48:09 2001
--- pine4.44-gentoo/pico/osdep/term.inf	Fri Sep 27 11:10:55 2002
***************
*** 139,146 ****
       */
      kpinsert("\033[4J", KEY_PGUP, 1);
      kpinsert("\033[3J", KEY_PGDN, 1);
!     kpinsert("\033[2J", KEY_HOME, 1);
!     kpinsert("\033[N",  KEY_END, 1);
  
      /* 
       * ANSI mode.
--- 139,146 ----
       */
      kpinsert("\033[4J", KEY_PGUP, 1);
      kpinsert("\033[3J", KEY_PGDN, 1);
!     kpinsert("\033[1~", KEY_HOME, 1);
!     kpinsert("\033[4~", KEY_END, 1);
  
      /* 
       * ANSI mode.
diff -c -r --new-file pine4.44/pico/pico.c pine4.44-gentoo/pico/pico.c
*** pine4.44/pico/pico.c	Thu Jun 21 12:50:03 2001
--- pine4.44-gentoo/pico/pico.c	Fri Sep 27 11:10:55 2002
***************
*** 219,225 ****
  	    switch(pico_all_done){	/* prepare for/handle final events */
  	      case COMP_EXIT :		/* already confirmed */
  		packheader();
! 		stripwhitespace();
  		c |= COMP_EXIT;
  		break;
  
--- 219,225 ----
  	    switch(pico_all_done){	/* prepare for/handle final events */
  	      case COMP_EXIT :		/* already confirmed */
  		packheader();
! //		stripwhitespace();
  		c |= COMP_EXIT;
  		break;
  
diff -c -r --new-file pine4.44/pine/mailcmd.c pine4.44-gentoo/pine/mailcmd.c
*** pine4.44/pine/mailcmd.c	Thu Nov  1 15:28:10 2001
--- pine4.44-gentoo/pine/mailcmd.c	Fri Sep 27 11:34:33 2002
***************
*** 2712,2719 ****
  	 * the destination folder will need...
  	 */
  	context_apply(tmp, context, save_folder, sizeof(tmp));
!         save_stream = (stream->dtb->flags & DR_LOCAL) && !IS_REMOTE(tmp) ?
! 	  stream : context_same_stream(context, save_folder, stream);
      }
  
      /* if needed, this'll get set in mm_notify */
--- 2712,2718 ----
  	 * the destination folder will need...
  	 */
  	context_apply(tmp, context, save_folder, sizeof(tmp));
! 	 	save_stream = context_same_stream(context, save_folder, stream);
      }
  
      /* if needed, this'll get set in mm_notify */
diff -c -r --new-file pine4.44/pine/osdep/lstcmpnt pine4.44-gentoo/pine/osdep/lstcmpnt
*** pine4.44/pine/osdep/lstcmpnt	Mon Oct 30 16:45:08 2000
--- pine4.44-gentoo/pine/osdep/lstcmpnt	Fri Sep 27 11:10:55 2002
***************
*** 9,18 ****
  last_cmpnt(filename)
      char *filename;
  {
!     register char *p = NULL, *q = filename;
  
!     if(!q)
!       return(q);
  
      while(q = strchr(q, '/'))
        if(*++q)
--- 9,18 ----
  last_cmpnt(filename)
      char *filename;
  {
!     char *p = NULL, *q = filename;
  
!     if(filename == 0)
!       return 0;
  
      while(q = strchr(q, '/'))
        if(*++q)
diff -c -r --new-file pine4.44/pine/osdep/os-lnx.h pine4.44-gentoo/pine/osdep/os-lnx.h
*** pine4.44/pine/osdep/os-lnx.h	Tue Feb  6 19:05:06 2001
--- pine4.44-gentoo/pine/osdep/os-lnx.h	Fri Sep 27 11:10:55 2002
***************
*** 223,229 ****
  
  
  /*--------- Program employed by users to change their password ---------*/
! #define	PASSWD_PROG	"/bin/passwd"
  
  
  /*-------------- A couple constants used to size arrays ----------------*/
--- 223,229 ----
  
  
  /*--------- Program employed by users to change their password ---------*/
! #define	PASSWD_PROG	"/usr/bin/passwd"
  
  
  /*-------------- A couple constants used to size arrays ----------------*/
diff -c -r --new-file pine4.44/pine/pine.h pine4.44-gentoo/pine/pine.h
*** pine4.44/pine/pine.h	Tue Jan  8 14:55:49 2002
--- pine4.44-gentoo/pine/pine.h	Fri Sep 27 11:35:06 2002
***************
*** 63,69 ****
  #ifndef _PINE_INCLUDED
  #define _PINE_INCLUDED
  
! #define PINE_VERSION		"4.50"
  #define	PHONE_HOME_VERSION	"-count"
  #define	PHONE_HOME_HOST		"docserver.cac.washington.edu"
  
--- 63,69 ----
  #ifndef _PINE_INCLUDED
  #define _PINE_INCLUDED
  
! #define PINE_VERSION		"4.50L0"
  #define	PHONE_HOME_VERSION	"-count"
  #define	PHONE_HOME_HOST		"docserver.cac.washington.edu"
  
