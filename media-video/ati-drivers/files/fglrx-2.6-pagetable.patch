--- lib/modules/fglrx/build_mod/firegl_public.c.orig	2005-02-05 08:18:17.301667616 -0500
+++ lib/modules/fglrx/build_mod/firegl_public.c	2005-02-05 08:45:50.522339872 -0500
@@ -1659,13 +1659,22 @@
 {
     unsigned long pte_linear;
     pgd_t* pgd_p;
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_t* pud_p;
+#endif
     pmd_t* pmd_p;
     pte_t* pte_p;
     pte_t  pte;
 
     pte_linear = VMALLOC_VMADDR(virtual_addr);  // convert to pte linear address (x86 => nop)
     pgd_p = pgd_offset(mm, pte_linear);
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_p = pud_offset(pgd_p, pte_linear);
+    pmd_p = pmd_offset(pud_p, pte_linear);
+#else
     pmd_p = pmd_offset(pgd_p, pte_linear);
+#endif
+
 #ifndef FGL_ATOMIC_PTE
 #if LINUX_VERSION_CODE > 0x020500
     pte_p = pte_offset_kernel(pmd_p, pte_linear);
@@ -2085,6 +2094,9 @@
                                                    unsigned long address)
 {
     pgd_t* pgd_p;
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_t* pud_p;
+#endif
     pmd_t* pmd_p;
     pte_t* pte_p;
     pte_t  pte;
@@ -2185,7 +2197,12 @@
         /* alternatively we could generate a NOPAGE_OOM "out of memory" */
     }
     /*  locate medium level page table (x86 => nop) */
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_p = pud_offset(pgd_p, pte_linear);
+    pmd_p = pmd_offset(pud_p, pte_linear);
+#else
     pmd_p = pmd_offset(pgd_p, pte_linear);
+#endif
     if (!pmd_present(*pmd_p))
     {
         __KE_ERROR("FATAL ERROR: User queue buffer not present! (pmd)\n");
@@ -2549,13 +2566,21 @@
 {
     unsigned long pte_linear;
     pgd_t* pgd_p;
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_t* pud_p;
+#endif
     pmd_t* pmd_p;
     pte_t* pte_p;
     pte_t  pte;
 
     pte_linear = VMALLOC_VMADDR(virtual_addr);  // convert to pte linear address (x86 => nop)
     pgd_p = pgd_offset(vma->vm_mm, pte_linear);
+#if LINUX_VERSION_CODE > 0x02060a	/* KERNEL_VERSION(2,6,10) */
+    pud_p = pud_offset(pgd_p, pte_linear);
+    pmd_p = pmd_offset(pud_p, pte_linear);
+#else
     pmd_p = pmd_offset(pgd_p, pte_linear);
+#endif
 #ifndef FGL_ATOMIC_PTE
 #if LINUX_VERSION_CODE > 0x020500
     pte_p = pte_offset_kernel(pmd_p, pte_linear);
@@ -2704,13 +2729,13 @@
 #endif /* __ia64__ */
                 vma->vm_flags |= VM_IO; /* not in core dump */
             }
-            if (remap_page_range(FGL_VMA_API_PASS
+            if (remap_pfn_range(FGL_VMA_API_PASS
                                  vma->vm_start,
-                                 __ke_vm_offset(vma),
+                                 __ke_vm_offset(vma) >> PAGE_SHIFT,
                                  vma->vm_end - vma->vm_start,
                                  vma->vm_page_prot))
             {
-                __KE_DEBUG("remap_page_range failed\n");
+                __KE_DEBUG("remap_pfn_range failed\n");
                 return -EAGAIN;
             }
             vma->vm_flags |= VM_SHM | VM_RESERVED; /* Don't swap */
@@ -2771,13 +2796,13 @@
 			{
 				if (__ke_vm_offset(vma) >= __pa(high_memory))
 					vma->vm_flags |= VM_IO; /* not in core dump */
-				if (remap_page_range(FGL_VMA_API_PASS
+				if (remap_pfn_range(FGL_VMA_API_PASS
 									 vma->vm_start,
-									 __ke_vm_offset(vma),
+									 __ke_vm_offset(vma) >> PAGE_SHIFT,
 									 vma->vm_end - vma->vm_start,
 									 vma->vm_page_prot))
 				{
-					__KE_DEBUG("remap_page_range failed\n");
+					__KE_DEBUG("remap_pfn_range failed\n");
 					return -EAGAIN;
 				}
 #ifdef __x86_64__
@@ -2808,13 +2833,13 @@
 			{
 				if (__ke_vm_offset(vma) >= __pa(high_memory))
 					vma->vm_flags |= VM_IO; /* not in core dump */
-				if (remap_page_range(FGL_VMA_API_PASS
+				if (remap_pfn_range(FGL_VMA_API_PASS
 									 vma->vm_start,
-									 __ke_vm_offset(vma),
+									 __ke_vm_offset(vma) >> PAGE_SHIFT,
 									 vma->vm_end - vma->vm_start,
 									 vma->vm_page_prot))
 				{
-					__KE_DEBUG("remap_page_range failed\n");
+					__KE_DEBUG("remap_pfn_range failed\n");
 					return -EAGAIN;
 				}
 #ifdef __x86_64__
@@ -2858,6 +2883,37 @@
 
 #if LINUX_VERSION_CODE >= 0x020400
 
+#if LINUX_VERSION_CODE >= 0x02060b
+
+typedef struct {
+	void			(*free_memory)(struct agp_memory *);
+	struct agp_memory *	(*allocate_memory)(size_t, u32);
+	int			(*bind_memory)(struct agp_memory *, off_t);
+	int			(*unbind_memory)(struct agp_memory *);
+	void			(*enable)(u32);
+	int			(*acquire)(void);
+	void			(*release)(void);
+	int			(*copy_info)(struct agp_kern_info *);
+} drm_agp_t;
+
+static const drm_agp_t drm_agp = {
+	&agp_free_memory,
+	&agp_allocate_memory,
+	&agp_bind_memory,
+	&agp_unbind_memory,
+	&agp_enable,
+	&agp_backend_acquire,
+	&agp_backend_release,
+	&agp_copy_info
+};
+#undef DRM_AGP_MODULE_GET
+#undef DRM_AGP_MODULE_PUT
+
+#define DRM_AGP_MODULE_GET	&drm_agp
+#define DRM_AGP_MODULE_PUT
+
+#endif
+
 static const drm_agp_t  *drm_agp_module_stub = NULL;
 
 #define AGP_FUNCTIONS		8
