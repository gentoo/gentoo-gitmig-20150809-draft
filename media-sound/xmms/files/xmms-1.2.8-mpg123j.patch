diff -urN xmms-1.2.8/Input/mpg123/common.c xmms-1.2.8-jp/Input/mpg123/common.c
--- xmms-1.2.8/Input/mpg123/common.c	2003-03-17 06:49:07.000000000 -0800
+++ xmms-1.2.8-jp/Input/mpg123/common.c	2003-09-12 09:22:37.000000000 -0700
@@ -8,6 +8,16 @@
 
 #include "config.h"
 
+#ifdef HAVE_ICONV_OPEN
+#include <iconv.h>
+#endif
+
+#include <errno.h>
+
+#ifdef HAVE_CODESET
+#include <langinfo.h>
+#endif
+
 #include "mpg123.h"
 #include "id3.h"
 #include "id3_header.h"
@@ -15,6 +25,13 @@
 /* max = 1728 */
 #define MAXFRAMESIZE 1792
 
+/* Japanese charset list for mpg123_Iconv() */
+#define MAXCHARSET 6
+char *mpg123_lconv_from[MAXCHARSET] =
+{
+	"ISO-2022-JP", "SJIS", "EUCJP", "UTF8", "UTF16", "UTF16BE"
+};
+
 const int tabsel_123[2][3][16] = {
 {{0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,},
  {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,},
@@ -505,3 +522,95 @@
 		return 0;
 	return ((double) stream_tell()) / mpg123_info->filesize;
 }
+
+gchar *mpg123_lconv(char *string, char *outto, size_t allow_trunc)
+{
+#if !defined(HAVE_ICONV_OPEN) || !defined(HAVE_CODESET)
+	return g_strdup(string);
+#else
+	size_t length, bufsize, outleft, inleft, ret;
+	iconv_t cd;
+	char *out, *outptr, *inptr;
+	char *from, *to, *froml;
+	int i;
+
+	if (!string)
+		return NULL;
+	length = strlen(string);
+
+	if (outto) {
+		froml = nl_langinfo(CODESET);
+		to    = outto;
+	} else {
+		froml = NULL;
+		to    = nl_langinfo(CODESET);
+	}
+	if ((outto && !froml) || (!outto && !to)) {
+		g_warning("mpg123_lconv(): Cannot get current character set.");
+		return g_strdup(string);
+	}
+
+	/* Iconv() requires extra work area to outbuf.
+           Round outbuf_size up to 3 multiple of 4 */
+	bufsize = (length + 11) & ~3;
+	out = g_malloc(bufsize);
+	if (!out) {
+		g_warning("mpg123_lconv(): Cannot allocate %d bytes buffer.",
+			bufsize);
+		return NULL;
+	}
+
+	/* One shot for froml, or loop for mpg123_lconv_from[] */
+	for (i=0, from = froml ? froml : mpg123_lconv_from[i];
+		from && i < MAXCHARSET;
+		from = froml ? NULL : mpg123_lconv_from[++i])
+	{
+		inptr = string;
+		inleft = length;
+		outptr = out;
+		outleft = bufsize - 1;
+
+		cd = iconv_open(to, from);
+		if (cd == (iconv_t)-1) {
+			g_warning("mpg123_lconv(): iconv_open %s %s -> %s",
+				strerror(errno), from, to);
+			continue;
+		}
+
+		ret = iconv(cd, &inptr, &inleft, &outptr, &outleft);
+		if (ret == (size_t)-1) {
+			switch (errno) {
+			case E2BIG:
+				g_warning("mpg123_lconv(): iconv err %d; %s -> %s \"%s\"",
+					errno, from, to, string);
+				iconv_close(cd);
+				continue;
+			case EINVAL:
+			case EILSEQ:
+				if (inleft > allow_trunc) {
+					iconv_close(cd);
+					continue;
+				}
+				/* Truncate trailing incomplete or invalid */
+				g_message("xmms mpg123: Truncate %d byte.",
+					inleft);
+				break;
+			default:
+				g_warning("mpg123_lconv(): iconv err %d; %s -> %s \"%s\"",
+					errno, from, to, string);
+				iconv_close(cd);
+				continue;
+			}
+		}
+		/* Conversion suceeded */
+		*outptr = '\0';
+		iconv_close(cd);
+		return out;
+	}
+	/* All Conversion failed */
+	g_warning("mpg123_lconv(): Failed to convert to %s. \"%s\"",
+		outto ? outto : "locale", string);
+	g_free(out);
+	return g_strdup(string);
+#endif
+}
diff -urN xmms-1.2.8/Input/mpg123/fileinfo.c xmms-1.2.8-jp/Input/mpg123/fileinfo.c
--- xmms-1.2.8/Input/mpg123/fileinfo.c	2003-07-14 06:24:28.000000000 -0700
+++ xmms-1.2.8-jp/Input/mpg123/fileinfo.c	2003-09-12 09:13:39.000000000 -0700
@@ -26,6 +26,10 @@
 #include <libxmms/xentry.h>
 #include "mpg123.h"
 
+#ifdef HAVE_CODESET
+#include <langinfo.h>
+#endif
+
 static GtkWidget *window = NULL;
 static GtkWidget *filename_entry, *id3_frame;
 static GtkWidget *title_entry, *artist_entry, *album_entry, *year_entry, *tracknum_entry, *comment_entry;
@@ -45,21 +49,29 @@
 static void set_entry_tag(GtkEntry * entry, gchar * tag, gint length)
 {
 	gint stripped_len;
-	gchar *text;
+	gchar *text, *tmp;
 
 	stripped_len = mpg123_strip_spaces(tag, length);
-	text = g_strdup_printf("%-*.*s", stripped_len, stripped_len, tag);
-	gtk_entry_set_text(entry, text);
+	text = g_strndup(tag, stripped_len);
+	tmp = mpg123_lconv(text, NULL, 0);
+	gtk_entry_set_text(entry, tmp);
+	g_free(tmp);
 	g_free(text);
 }
 
 static void get_entry_tag(GtkEntry * entry, gchar * tag, gint length)
 {
-	gchar *text;
+	gchar *text, *tmp;
 
 	text = gtk_entry_get_text(entry);
+	tmp  = g_strndup(text, length);
+	if (strlen(text) - strlen(tmp) > 0)
+		g_message("xmms mpg123: Truncate to \"%s\"", tmp);
+	text = mpg123_lconv(tmp, "SJIS", 1);
 	memset(tag, ' ', length);
 	memcpy(tag, text, strlen(text) > length ? length : strlen(text));
+	g_free(text);
+	g_free(tmp);
 }
 
 static gint find_genre_id(gchar * text)
diff -urN xmms-1.2.8/Input/mpg123/id3_frame_content.c xmms-1.2.8-jp/Input/mpg123/id3_frame_content.c
--- xmms-1.2.8/Input/mpg123/id3_frame_content.c	2002-09-30 07:03:18.000000000 -0700
+++ xmms-1.2.8-jp/Input/mpg123/id3_frame_content.c	2003-09-12 09:17:13.000000000 -0700
@@ -51,12 +51,18 @@
     /* Check if frame is compressed */
     if (id3_decompress_frame(frame) == -1)
 	    return NULL;
-
-    if (*(guint8 *) frame->fr_data == ID3_ENCODING_ISO_8859_1)
-	text_beg = text = g_strdup((char *) frame->fr_data + 1);
-    else
-	text_beg = text = 
-	    id3_utf16_to_ascii((char *) frame->fr_data + 1);
+	
+	switch( *(guint8 *) frame->fr_data ) {
+		case ID3_ENCODING_ISO_8859_1:
+		case ID3_ENCODING_UTF8:
+			text_beg = text = g_strdup((char *) frame->fr_data + 1);
+			break;
+		case ID3_ENCODING_UTF16:
+		case ID3_ENCODING_UTF16BE:
+		default:
+		text_beg = text = 
+			id3_utf16_to_ascii((char *) frame->fr_data + 1);
+	}
 
     /*
      * If content is just plain text, return it.
diff -urN xmms-1.2.8/Input/mpg123/id3_frame_text.c xmms-1.2.8-jp/Input/mpg123/id3_frame_text.c
--- xmms-1.2.8/Input/mpg123/id3_frame_text.c	2002-10-28 07:24:23.000000000 -0800
+++ xmms-1.2.8-jp/Input/mpg123/id3_frame_text.c	2003-09-12 09:20:55.000000000 -0700
@@ -127,28 +127,36 @@
 char *id3_get_text(struct id3_frame *frame)
 {
     /* Type check */
-    if ( frame->fr_desc->fd_idstr[0] != 'T' )
+    if ( frame->fr_desc->fd_idstr[0] != 'T' &&
+         frame->fr_desc->fd_id != ID3_COMM )
 	return NULL;
 
     /* Check if frame is compressed */
     if (id3_decompress_frame(frame) == -1)
 	    return NULL;
 
-    if ( frame->fr_desc->fd_id == ID3_TXXX ) {
+    if ( frame->fr_desc->fd_id == ID3_TXXX ||
+         frame->fr_desc->fd_id == ID3_COMM )
+    {
 	/*
 	 * This is a user defined text frame.  Skip the description.
 	 */
 	switch ( *(guint8 *) frame->fr_data ) {
 	case ID3_ENCODING_ISO_8859_1:
+	case ID3_ENCODING_UTF8:
 	{
 	    char *text = (char *) frame->fr_data + 1;
+	    guint len = frame->fr_size - 1;
 
-	    while ( *text != 0 )
+	    while ( *text != 0 ) {
 		text++;
+		len--;
+	    }
 
-	    return g_strdup(++text);
+	    return g_strndup(++text,--len);
 	}
 	case ID3_ENCODING_UTF16:
+	case ID3_ENCODING_UTF16BE:
 	{
 	    char *text16 = (char *) frame->fr_data + 1;
 
@@ -161,11 +169,16 @@
 	    return NULL;
 	}
     }
-
-    if (*(guint8 *) frame->fr_data == ID3_ENCODING_ISO_8859_1)
-	return g_strdup((char *) frame->fr_data + 1);
+	switch (*(guint8 *) frame->fr_data) {
+		case ID3_ENCODING_ISO_8859_1:
+		case ID3_ENCODING_UTF8:
+			return g_strdup((char *) frame->fr_data + 1);
+		case ID3_ENCODING_UTF16:
+		case ID3_ENCODING_UTF16BE:
+		default:
     else
-	return id3_utf16_to_ascii(((char *) frame->fr_data + 1));
+		return id3_utf16_to_ascii(((char *) frame->fr_data + 1));
+	}
 }
 
 
diff -urN xmms-1.2.8/Input/mpg123/mpg123.c xmms-1.2.8-jp/Input/mpg123/mpg123.c
--- xmms-1.2.8/Input/mpg123/mpg123.c	2003-07-10 06:12:19.000000000 -0700
+++ xmms-1.2.8-jp/Input/mpg123/mpg123.c	2003-09-12 09:13:39.000000000 -0700
@@ -556,6 +556,33 @@
 
 	if (tag)
 	{
+		gchar *tmp;
+		
+		tmp = mpg123_lconv(tag->artist, NULL, 0);
+		strncpy(tag->artist, tmp, sizeof(tag->artist)-1);
+		tag->artist[sizeof(tag->artist)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_lconv(tag->album, NULL, 0);
+		strncpy(tag->album, tmp, sizeof(tag->album)-1);
+		tag->album[sizeof(tag->album)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_lconv(tag->title, NULL, 0);
+		strncpy(tag->title, tmp, sizeof(tag->title)-1);
+		tag->title[sizeof(tag->title)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_lconv(tag->genre, NULL, 0);
+		strncpy(tag->genre, tmp, sizeof(tag->genre)-1);
+		tag->genre[sizeof(tag->genre)-1] = '\0';
+		g_free(tmp);
+                
+		tmp = mpg123_lconv(tag->comment, NULL, 0);
+		strncpy(tag->comment, tmp, sizeof(tag->comment)-1);
+		tag->comment[sizeof(tag->comment)-1] = '\0';
+		g_free(tmp);
+                
 		input->performer = mpg123_getstr(tag->artist);
 		input->album_name = mpg123_getstr(tag->album);
 		input->track_name = mpg123_getstr(tag->title);
diff -urN xmms-1.2.8/Input/mpg123/mpg123.h xmms-1.2.8-jp/Input/mpg123/mpg123.h
--- xmms-1.2.8/Input/mpg123/mpg123.h	2003-09-04 06:48:34.000000000 -0700
+++ xmms-1.2.8-jp/Input/mpg123/mpg123.h	2003-09-12 09:13:39.000000000 -0700
@@ -299,6 +299,7 @@
 void mpg123_get_id3v2(struct id3_tag * id3d, struct id3tag_t *tag);
 gchar *mpg123_format_song_title(struct id3tag_t *tag, gchar *filename);
 double mpg123_relative_pos(void);
+gchar *mpg123_lconv(char *string, char *to, size_t allow_trunc);
 
 
 
