Index: acconfig.h
===================================================================
RCS file: /cvs/xmms/acconfig.h,v
retrieving revision 1.13
diff -u -r1.13 acconfig.h
--- acconfig.h	14 Nov 2001 22:08:14 -0000	1.13
+++ acconfig.h	8 Apr 2002 19:05:50 -0000
@@ -57,6 +57,7 @@
 #undef PACKAGE
 #undef VERSION
 #undef USE_SIMD
+#undef USE_IPV6
 #undef WITH_SYMBOL_UNDERSCORE
 #undef WITH_SM
 #undef ENABLE_NLS
Index: configure.in
===================================================================
RCS file: /cvs/xmms/configure.in,v
retrieving revision 1.116
diff -u -r1.116 configure.in
--- configure.in	24 Mar 2002 14:38:22 -0000	1.116
+++ configure.in	8 Apr 2002 19:05:51 -0000
@@ -338,6 +338,17 @@
 fi
 AM_CONDITIONAL(USE_SIMD,test "x$USE_SIMD" = xyes)
 AC_SUBST(USE_SIMD_TRUE)
+
+dnl IPv6 support
+dnl ========================
+AC_ARG_ENABLE(ipv6,
+	[  --enable-ipv6		  enable IPv6 support [default=no]],
+			enable_ipv6=$enableval, enable_ipv6=no)
+if test "x$enable_ipv6" = xyes; then
+  AC_DEFINE(USE_IPV6)
+fi
+AM_CONDITIONAL(USE_IPV6,test "x$enable_ipv6" = xyes)
+AC_SUBST(USE_IPV6)
 dnl ========================
 
 AC_CACHE_CHECK(for socklen_t, xmms_cv_type_socklen_t,
Index: Input/cdaudio/http.c
===================================================================
RCS file: /cvs/xmms/Input/cdaudio/http.c,v
retrieving revision 1.5
diff -u -r1.5 http.c
--- Input/cdaudio/http.c	21 Jul 2000 08:54:17 -0000	1.5
+++ Input/cdaudio/http.c	8 Apr 2002 19:05:51 -0000
@@ -25,9 +25,45 @@
 gint http_open_connection(gchar * server, gint port)
 {
 	gint sock;
+#ifdef USE_IPV6
+	struct addrinfo hints, *res, *res0;
+	char service[6];
+#else
 	struct hostent *host;
 	struct sockaddr_in address;
+#endif
 
+#ifdef USE_IPV6
+	snprintf(service, 6, "%d", port);
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+
+	if (getaddrinfo(server, service, &hints, &res0))
+		return 0;
+
+	for (res = res0; res; res = res->ai_next) {
+		sock = socket (res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (sock < 0) {
+			if (res->ai_next)
+				continue;
+			else {
+				freeaddrinfo(res0);
+				return 0;
+			}
+		}
+		if (connect(sock, res->ai_addr, res->ai_addrlen) < 0) {
+			if (res->ai_next) {
+				close(sock);
+				continue;
+			} else {
+				freeaddrinfo(res0);
+				return 0;
+			}
+		}
+		freeaddrinfo(res0);
+		return sock;
+	}
+#else
 	sock = socket(AF_INET, SOCK_STREAM, 0);
 	address.sin_family = AF_INET;
 
@@ -40,6 +76,7 @@
 	if (connect(sock, (struct sockaddr *) &address, sizeof (struct sockaddr_in)) == -1)
 		return 0;
 
+#endif
 	return sock;
 }
 
Index: Input/mpg123/http.c
===================================================================
RCS file: /cvs/xmms/Input/mpg123/http.c,v
retrieving revision 1.26
diff -u -r1.26 http.c
--- Input/mpg123/http.c	6 Jan 2002 22:13:16 -0000	1.26
+++ Input/mpg123/http.c	8 Apr 2002 19:05:52 -0000
@@ -332,8 +332,13 @@
 	gboolean redirect;
 	int udp_sock = 0;
 	fd_set set;
+#ifdef USE_IPV6
+	struct addrinfo hints, *res, *res0;
+	char service[6];
+#else
 	struct hostent *hp;
 	struct sockaddr_in address;
+#endif
 	struct timeval tv;
 
 	url = (gchar *) arg;
@@ -355,6 +360,45 @@
 		chost = mpg123_cfg.use_proxy ? mpg123_cfg.proxy_host : host;
 		cport = mpg123_cfg.use_proxy ? mpg123_cfg.proxy_port : port;
 
+#ifdef USE_IPV6
+		snprintf(service, 6, "%d", cport);
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		if (! getaddrinfo(chost, service, &hints, &res0)) {
+			eof = TRUE;
+			for (res = res0; res; res = res->ai_next) {
+				if ((sock = socket (res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)
+					continue;
+				fcntl(sock, F_SETFL, O_NONBLOCK);
+				status = g_strdup_printf(_("CONNECTING TO %s:%d"), chost, cport);
+				mpg123_ip.set_info_text(status);
+				g_free(status);
+				((struct sockaddr_in6 *)res->ai_addr)->sin6_port = htons(cport);
+				if (connect(sock, res->ai_addr, res->ai_addrlen) < 0) {
+					if (errno != EINPROGRESS) {
+						close(sock);
+						continue;
+					}
+				}
+				eof = FALSE;
+				break;
+			}
+			freeaddrinfo(res0);
+			if (eof) {
+				status = g_strdup_printf(_("Couldn't connect to host %s:%d"), chost, cport);
+				show_error_message(status);
+				g_free(status);
+				mpg123_ip.set_info_text(NULL);
+			}
+		} else {
+			status = g_strdup_printf(_("Couldn't look up host %s"), chost);
+			show_error_message(status);
+			g_free(status);
+
+			mpg123_ip.set_info_text(NULL);
+			eof = TRUE;
+		}
+#else
 		sock = socket(AF_INET, SOCK_STREAM, 0);
 		fcntl(sock, F_SETFL, O_NONBLOCK);
 		address.sin_family = AF_INET;
@@ -372,9 +416,11 @@
 			mpg123_ip.set_info_text(NULL);
 			eof = TRUE;
 		}
+#endif
 
 		if (!eof)
 		{
+#ifndef USE_IPV6
 			memcpy(&address.sin_addr.s_addr, *(hp->h_addr_list), sizeof (address.sin_addr.s_addr));
 			address.sin_port = g_htons(cport);
 
@@ -393,6 +439,7 @@
 					eof = TRUE;
 				}
 			}
+#endif
 			while (going)
 			{
 				tv.tv_sec = 0;
@@ -697,14 +744,23 @@
 /* Find a good local udp port and bind udp_sock to it, return the port */
 static int udp_establish_listener(int *sock)
 {
+#ifdef USE_IPV6
+	struct sockaddr_in6 sin;
+	socklen_t sinlen = sizeof (struct sockaddr_in6);
+#else
 	struct sockaddr_in sin;
 	socklen_t sinlen = sizeof (struct sockaddr_in);
+#endif
 	
 #ifdef DEBUG_UDP
 	fprintf (stderr,"Establishing udp listener\n");
 #endif
 	
+#ifdef USE_IPV6
+	if ((*sock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
+#else
 	if ((*sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+#endif
 	{
 		g_log(NULL, G_LOG_LEVEL_CRITICAL,
 		      "udp_establish_listener(): unable to create socket");
@@ -712,8 +768,12 @@
 	}
 
 	memset(&sin, 0, sinlen);
+#ifdef USE_IPV6
+	sin.sin6_family = AF_INET6;
+#else
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = g_htonl(INADDR_ANY);
+#endif
 			
 	if (bind(*sock, (struct sockaddr *)&sin, sinlen) < 0)
 	{
@@ -743,7 +803,11 @@
 	fprintf (stderr,"Listening on local %s:%d\n", inet_ntoa(sin.sin_addr), g_ntohs(sin.sin_port));
 #endif
 	
+#ifdef USE_IPV6
+	return g_ntohs(sin.sin6_port);
+#else
 	return g_ntohs(sin.sin_port);
+#endif
 }
 
 static int udp_check_for_data(int sock)
@@ -752,10 +816,14 @@
 	char *valptr;
 	gchar *title;
 	gint len, i;
+#ifdef USE_IPV6
+	struct sockaddr_in6 from;
+#else
 	struct sockaddr_in from;
+#endif
 	socklen_t fromlen;
 
-	fromlen = sizeof(struct sockaddr_in);
+	fromlen = sizeof(from);
 	
 	if ((len = recvfrom(sock, buf, 1024, 0, (struct sockaddr *)&from, &fromlen)) < 0)
 	{
@@ -840,7 +908,14 @@
 #ifdef DEBUG_UDP
 			else
 				fprintf(stderr,"Sent ack: %s", obuf);
+#ifdef USE_IPV6
+{
+			char adr[INET6_ADDRSTRLEN];
+			inet_ntop(AF_INET6, &from.sin6_addr, adr, INET6_ADDRSTRLEN);
+			fprintf (stderr,"Remote: [%s]:%d\n", adr, g_ntohs(from.sin6_port));
+#else
 			fprintf (stderr,"Remote: %s:%d\n", inet_ntoa(from.sin_addr), g_ntohs(from.sin_port));
+#endif
 #endif
 		}
 	}
Index: Input/vorbis/http.c
===================================================================
RCS file: /cvs/xmms/Input/vorbis/http.c,v
retrieving revision 1.4
diff -u -r1.4 http.c
--- Input/vorbis/http.c	29 Dec 2001 19:03:38 -0000	1.4
+++ Input/vorbis/http.c	8 Apr 2002 19:05:52 -0000
@@ -287,8 +287,13 @@
 	gint cnt, written, error, err_len, port, cport;
 	gboolean redirect;
 	fd_set set;
+#ifdef USE_IPV6
+	struct addrinfo hints, *res, *res0;
+	char service[6];
+#else
 	struct hostent *hp;
 	struct sockaddr_in address;
+#endif
 	struct timeval tv;
 
 	url = (gchar *) arg;
@@ -310,6 +315,44 @@
 		chost = vorbis_cfg.use_proxy ? vorbis_cfg.proxy_host : host;
 		cport = vorbis_cfg.use_proxy ? vorbis_cfg.proxy_port : port;
 
+#ifdef USE_IPV6
+		snprintf(service, 6, "%d", cport);
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		if (! getaddrinfo(chost, service, &hints, &res0)) {
+			eof = TRUE;
+			for (res = res0; res; res = res->ai_next) {
+				if ((sock = socket (res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)
+					continue;
+				fcntl(sock, F_SETFL, O_NONBLOCK);
+				status = g_strdup_printf(_("CONNECTING TO %s:%d"), chost, cport);
+				vorbis_ip.set_info_text(status);
+				g_free(status);
+				((struct sockaddr_in6 *)res->ai_addr)->sin6_port = htons(cport);
+				if (connect(sock, res->ai_addr, res->ai_addrlen) < 0) {
+					if (errno != EINPROGRESS) {
+						close(sock);
+						continue;
+					}
+				}
+				eof = FALSE;
+				break;
+			}
+			freeaddrinfo(res0);
+			if (eof) {
+				status = g_strdup_printf(_("Couldn't connect to host %s:%d"), chost, cport);
+				vorbis_ip.set_info_text(status);
+				g_free(status);
+				eof = TRUE;
+				break;
+			}
+		} else {
+			status = g_strdup_printf(_("Couldn't look up host %s"), chost);
+			vorbis_ip.set_info_text(status);
+			g_free(status);
+			eof = TRUE;
+		}
+#else
 		sock = socket(AF_INET, SOCK_STREAM, 0);
 		fcntl(sock, F_SETFL, O_NONBLOCK);
 		address.sin_family = AF_INET;
@@ -327,9 +370,11 @@
 			vorbis_ip.set_info_text(NULL);
 			eof = TRUE;
 		}
+#endif
 
 		if (!eof)
 		{
+#ifndef USE_IPV6
 			memcpy(&address.sin_addr.s_addr, *(hp->h_addr_list), sizeof (address.sin_addr.s_addr));
 			address.sin_port = g_htons(cport);
 
@@ -348,6 +393,7 @@
 					eof = TRUE;
 				}
 			}
+#endif
 			while (going)
 			{
 				tv.tv_sec = 0;
