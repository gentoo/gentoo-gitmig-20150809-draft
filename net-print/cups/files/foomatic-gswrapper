#! /usr/bin/perl

# $Revision: 1.1 $

# This is a little Ghostscript regularization script.  It massages
# arguments to make Ghostscript execute properly as a filter, with
# output on stdout and errors etc on stderr.

# Arbitrary other option processing could happen here, too.

# IT WOULD BE WRONG to have this file do any processing of the input
# or output data.  Such job transforms belong in actual filters, or
# inside Ghostscript itself.

grep (m!\-sOutputFile=\-! 
      && do {
	  # Send the job to fd 3; errors will be on 2(stderr) and job
	  # ps program interpreter output on 1(stdout)
	  # The /dev/fd/3 is equivalent to "| cat >&3" but it works with
	  # all versions of GhostScript under every shell and every Unix.
	  $_ = '-sOutputFile=/dev/fd/3';	# quoted properly below...
      }, @ARGV);

grep (m!^\-$! 
      && do {
	  # Get the input from fd 0; The /dev/fd/0 is equivalent to
	  # "-" but there are some pesky PostScript files which do not
	  # work with "-". This works with all versions of GhostScript
	  # under every shell and every Unix.
	  $_ = '/dev/fd/0';
      }, @ARGV);

# Turn *off* -q (quiet!); now that stderr is useful! :)
my @myargs = grep (! m!^\-q$!, @ARGV);

# Escape any quotes, and then quote everything just to be sure...
grep (s!\'!\\'!g, @myargs);
#'# Fix Emacs syntax highlighting
my $args = "'" . join("' '", @myargs) . "'";

# Execute Ghostscript, with both job and gs errors on stderr, and job
# output on stdout...

print STDERR "foomatic-gswrapper: gs $args 3>&1 1>&2\n";
exec "gs $args 3>&1 1>&2";

die "Failed to execute Ghostscript?!";
