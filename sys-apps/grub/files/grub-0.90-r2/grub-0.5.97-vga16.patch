diff -ur grub.bak/ChangeLog grub/ChangeLog
--- grub.bak/ChangeLog	Thu Jun 21 22:32:55 2001
+++ grub/ChangeLog	Sun Jun 24 23:44:19 2001
@@ -1331,6 +1331,18 @@
 	[!STAGE1_5] (CMDLINE_WIDTH): New macro.
 	[!STAGE1_5] (CMDLINE_MARGIN): Likewise.
 	* stage2/shared.h (TERMINAL_DUMB): Likewise.
+
+2000-08-29  Paulo César Pereira de Andrade <pcpa@conectiva.com.br>
+
+        * configure.in: Added --disable-vga16 option, in case user does not
+        want the new VGA graphics interface.
+        * stage2/asm.S: Added some new functions, for graphics operations,
+        and renamed several functions to allow wrapping them.
+        * stage2/stage2.c: Main changes for VGA16 support.
+        * stage2/char_io.c: Modified calls of grub_putchar to putchar
+        * stage2/disk_io.c: Same as for char_io.c
+        * stage2/cmdline.c: Also, the same as for char_io.c
+        * stage2/shared.h: Definitions for externs and wrapping functions.
 	
 2000-08-28  OKUJI Yoshinori  <okuji@gnu.org>
 
Only in grub: ChangeLog.vga16
diff -ur grub.bak/configure.in grub/configure.in
--- grub.bak/configure.in	Thu Jun 21 22:32:56 2001
+++ grub/configure.in	Sun Jun 24 23:44:19 2001
@@ -18,6 +18,7 @@
 AC_PREREQ(2.13)
 
 AC_CANONICAL_HOST
+AM_PROG_LIBTOOL
 
 case "$host_cpu" in
 i[[3456]]86) host_cpu=i386 ;;
@@ -564,6 +565,12 @@
 AC_SUBST(NET_EXTRAFLAGS)
 AC_SUBST(NETBOOT_DRIVERS)
 
+AC_ARG_ENABLE(vga16,
+  [  --disable-vga16        disable VGA graphics interface])
+
+if test x"$enable_vga16" != xno; then
+  STAGE2_CFLAGS="$STAGE2_CFLAGS -DVGA16=1"
+fi
 
 dnl Output.
 AC_OUTPUT([Makefile stage1/Makefile stage2/Makefile docs/Makefile \
Only in grub: configure.in.vga16
diff -ur grub.bak/stage2/asm.S grub/stage2/asm.S
--- grub.bak/stage2/asm.S	Tue Feb 27 07:59:00 2001
+++ grub/stage2/asm.S	Sun Jun 24 23:44:19 2001
@@ -1857,7 +1857,7 @@
  *                      %cl = cursor ending scanline
  */
 
-ENTRY(nocursor)
+ENTRY(grub_nocursor)
 	push	%ebp
 	push	%ebx                    /* save EBX */
 
@@ -1943,7 +1943,7 @@
 
 
 /*
- * console_set_attrib(attr) :  Sets the character attributes for character at
+ * grub_set_attrib(attr) :  Sets the character attributes for character at
  *		current cursor position.
  *
  *  Bitfields for character's display attribute:
@@ -1977,7 +1977,7 @@
  *			%cx = count to display (???, possible side-effects!!)
  */
 
-ENTRY(console_set_attrib)
+ENTRY(grub_set_attrib)
 	push	%ebp
 	push	%ebx
 
@@ -2001,6 +2001,263 @@
 	pop	%ebp
 	ret
 
+#ifdef VGA16
+VARIABLE(cursorX)
+.word	0
+VARIABLE(cursorY)
+.word	0
+VARIABLE(cursorWidth)
+.word	0
+VARIABLE(cursorHeight)
+.word	0
+VARIABLE(cursorCount)
+.word	0
+VARIABLE(cursorBuf)
+.byte	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+
+/*
+ * set_int1c_handler(void)
+ */
+ENTRY(set_int1c_handler)
+	pushl	%edi
+
+	/* save the original int1c handler */
+	movl	$0x70, %edi
+	movw	(%edi), %ax
+	movw	%ax, ABS(int1c_offset)
+	movw	2(%edi), %ax
+	movw	%ax, ABS(int1c_segment)
+
+	/* save the new int1c handler */
+	movw	$ABS(int1c_handler), %ax
+	movw	%ax, (%edi)
+	xorw	%ax, %ax
+	movw	%ax, 2(%edi)
+
+	popl	%edi
+	ret
+
+
+/*
+ * unset_int1c_handler(void)
+ */
+ENTRY(unset_int1c_handler)
+	pushl	%edi
+
+	/* check if int1c_handler is set */
+	movl	$0x70, %edi
+	movw	$ABS(int1c_handler), %ax
+	cmpw	%ax, (%edi)
+	jne	int1c_1
+	xorw	%ax, %ax
+	cmpw	%ax, 2(%edi)
+	jne	int1c_1
+
+	/* restore the original */
+	movw	ABS(int1c_offset), %ax
+	movw	%ax, (%edi)
+	movw	ABS(int1c_segment), %ax
+	movw	%ax, 2(%edi)
+
+int1c_1:
+	popl	%edi
+	ret
+
+/*
+ * blinks graphics cursor
+ */
+	.code16
+write_data:
+	movw	$0, %ax
+	movw	%ax, %ds
+
+	mov	$0xA000, %ax		/* video in es:di */
+	mov	%ax, %es
+	mov	$80, %ax
+	movw	$ABS(cursorY), %si
+	mov	%ds:(%si), %bx
+	mul	%bx
+	movw	$ABS(cursorX), %si
+	mov	%ds:(%si), %bx
+	shr	$3, %bx			/* %bx /= 8 */
+	add	%bx, %ax
+	mov	%ax, %di
+
+	movw	$ABS(cursorBuf), %si	/* fontBuf in ds:si */
+
+	/* prepare for data moving */
+	mov	$16, %dx		/* altura da fonte */
+	mov	$80, %bx		/* bytes por linha */
+
+write_loop:
+	movb	%ds:(%si), %al
+	xorb	$0xff, %al
+	movb	%al, %ds:(%si)		/* invert cursorBuf */
+	movb	%al, %es:(%di)		/* write to video */
+	add	%bx, %di
+	inc	%si
+	dec	%dx
+	jg	write_loop
+	ret
+
+int1c_handler:
+	pusha
+	mov	$0, %ax
+	mov	%ax, %ds
+	mov	$ABS(cursorCount), %si
+	mov	%ds:(%si), %ax
+	inc	%ax
+	mov	%ax, %ds:(%si)
+	cmp	$9, %ax
+	jne	int1c_done
+
+	mov	$0, %ax
+	mov	%ax, %ds:(%si)
+/*
+	movw	$0x3c4, %dx
+	movb	$0x020f, %ax
+	outw	%ax, %dx
+*/
+	call	write_data
+
+int1c_done:
+	popa
+	iret
+	/* call previous int1c handler */
+	/* ljmp */
+	.byte	0xea
+int1c_offset:	.word	0
+int1c_segment:	.word	0
+	.code32
+
+
+ENTRY(get_font)
+	push	%ebp
+	push	%ebx
+	push	%ecx
+	push	%edx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$0x1130, %ax
+	movb	$6, %bh		/* font 8x16 */
+	int	$0x10
+	movw	%bp, %dx
+	movw	%es, %cx
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	xorl	%eax, %eax
+	movw	%cx, %ax
+	shll	$4, %eax
+	movw	%dx, %ax
+
+	pop	%edx
+	pop	%ecx
+	pop	%ebx
+	pop	%ebp
+	ret
+
+/*
+ * set_videomode(mode)
+ * BIOS call "INT 10H Function 0h" to set video mode
+ *	Call with	%ah = 0x0
+ *			%al = video mode
+ */
+ENTRY(set_videomode)
+	push	%ebp
+	push	%ebx
+	push	%ecx
+
+	movb	0x10(%esp), %cl
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	xorw	%bx, %bx
+	movb	$0xf, %ah
+	int	$0x10			/* Get Current Video mode */
+	movb	%al, %ch
+	xorb	%ah, %ah
+	movb	%cl, %al
+        int	$0x10			/* Set Video mode */
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	xorb	%ah, %ah
+	movb	%ch, %al
+
+	pop	%ecx
+	pop	%ebx
+	pop	%ebp
+	ret
+
+/*
+ * set_palette(index, red, green, blue)
+ * BIOS call "INT 10H Function 10h" to set individual dac register
+ *	Call with	%ah = 0x10
+ *			%bx = register number
+ *			%ch = new value for green (0-63)
+ *			%cl = new value for blue (0-63)
+ *			%dh = new value for red (0-63)
+ */
+
+ENTRY(set_palette)
+	push	%ebp
+	push	%eax
+	push	%ebx
+	push	%ecx
+	push	%edx
+
+	movw	$0x3c8, %bx		/* address write mode register */
+
+	/* wait vertical retrace */
+
+	movw	$0x3da, %dx
+l1b:	inb	%dx, %al	/* wait vertical active display */
+	test	$8, %al
+	jnz	l1b
+
+l2b:	inb	%dx, %al	/* wait vertical retrace */
+	test	$8, %al
+	jnz	l2b
+
+	mov	%bx, %dx
+	movb	0x18(%esp), %al		/* index */
+	outb	%al, %dx
+	inc	%dx
+
+	movb	0x1c(%esp), %al		/* red */
+	outb	%al, %dx
+
+	movb	0x20(%esp), %al		/* green */
+	outb	%al, %dx
+
+	movb	0x24(%esp), %al		/* blue */
+	outb	%al, %dx
+
+	movw	0x18(%esp), %bx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movb	%bl, %bh
+	movw	$0x1000, %ax
+	int	$0x10
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32	
+
+	pop	%edx
+	pop	%ecx
+	pop	%ebx
+	pop	%eax
+	pop	%ebp
+	ret
+#endif
 
 /*
  * getrtsecs()
Only in grub/stage2: asm.S.vga16
diff -ur grub.bak/stage2/builtins.c grub/stage2/builtins.c
--- grub.bak/stage2/builtins.c	Thu Jun 21 19:15:02 2001
+++ grub/stage2/builtins.c	Sun Jun 24 23:44:19 2001
@@ -133,6 +133,36 @@
   grub_printf ("[%d,%d,%d]", sector, offset, length);
 }
 
+#ifdef VGA16
+/* background */
+static int
+background_func(char *arg, int flags)
+{
+    if (grub_strlen(arg) == 6) {
+	int r = ((hex(arg[0]) << 4) | hex(arg[1])) >> 2;
+	int g = ((hex(arg[2]) << 4) | hex(arg[3])) >> 2;
+	int b = ((hex(arg[4]) << 4) | hex(arg[5])) >> 2;
+
+	background = (r << 16) | (g << 8) | b;
+	if (vga_inited)
+	    set_palette(0, r, g, b);
+	return (0);
+    }
+
+    return (1);
+}
+
+static struct builtin builtin_background =
+{
+  "background",
+  background_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "background RRGGBB",
+  "Sets the background color when in graphics mode."
+  "RR is red, GG is green, and BB blue. Numbers must be in hexadecimal."
+};
+#endif  /* VGA16 */
+
 
 /* blocklist */
 static int
@@ -394,6 +424,40 @@
 #endif /* SUPPORT_NETBOOT */
 
 
+#ifdef VGA16
+
+/* foreground */
+static int
+border_func(char *arg, int flags)
+{
+    if (grub_strlen(arg) == 6) {
+	int r = ((hex(arg[0]) << 4) | hex(arg[1])) >> 2;
+	int g = ((hex(arg[2]) << 4) | hex(arg[3])) >> 2;
+	int b = ((hex(arg[4]) << 4) | hex(arg[5])) >> 2;
+
+	border = (r << 16) | (g << 8) | b;
+	if (vga_inited)
+	    set_palette(0x11, r, g, b);
+
+	return (0);
+    }
+
+    return (1);
+}
+
+static struct builtin builtin_border =
+{
+  "border",
+  border_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "border RRGGBB",
+  "Sets the border video color when in graphics mode."
+  "RR is red, GG is green, and BB blue. Numbers must be in hexadecimal."
+};
+
+#endif /* VGA16 */
+
+
 /* cat */
 static int
 cat_func (char *arg, int flags)
@@ -404,7 +468,7 @@
     return 1;
 
   while (grub_read (&c, 1))
-    grub_putchar (c);
+    putchar (c);
 
   grub_close ();
   return 0;
@@ -958,6 +1022,44 @@
   return 0;
 }
 
+
+#ifdef VGA16
+/* display */
+static int
+display_func(char *arg, int flags)
+{
+    int i;
+
+    for (i = 0; i < MAX_DISPLAYS; i++) {
+	if (grub_strcmp(arg, display_entries[i].name) == 0)
+	    break;
+    }
+
+    if (i >= MAX_DISPLAYS)
+	return (1);
+
+    display_idx = i;
+    if (display->End)
+	(*display->End)();
+    display = &display_entries[display_idx];
+
+    /* Restart cmain */
+    grub_longjmp (restart_env, 0);
+    /*NOTREACHED*/
+
+    return (0);
+}
+
+static struct builtin builtin_display =
+{
+  "display",
+  display_func,
+  BUILTIN_CMDLINE,
+  "display MODEL",
+  "Changes display type. Available modes are \"text\" and \"vga16\"."
+};
+#endif /* VGA16 */
+
 static struct builtin builtin_displaymem =
 {
   "displaymem",
@@ -1233,6 +1335,39 @@
   " the devices which contain the file."
 };
 
+#ifdef VGA16
+
+/* foreground */
+static int
+foreground_func(char *arg, int flags)
+{
+    if (grub_strlen(arg) == 6) {
+	int r = ((hex(arg[0]) << 4) | hex(arg[1])) >> 2;
+	int g = ((hex(arg[2]) << 4) | hex(arg[3])) >> 2;
+	int b = ((hex(arg[4]) << 4) | hex(arg[5])) >> 2;
+
+	foreground = (r << 16) | (g << 8) | b;
+	if (vga_inited)
+	    set_palette(15, r, g, b);
+
+	return (0);
+    }
+
+    return (1);
+}
+
+static struct builtin builtin_foreground =
+{
+  "foreground",
+  foreground_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "foreground RRGGBB",
+  "Sets the foreground color when in graphics mode."
+  "RR is red, GG is green, and BB blue. Numbers must be in hexadecimal."
+};
+
+#endif /* VGA16 */
+
 
 /* fstest */
 static int
@@ -1385,12 +1520,13 @@
 
 
 /* help */
-#define MAX_SHORT_DOC_LEN	39
-#define MAX_LONG_DOC_LEN	66
 
 static int
 help_func (char *arg, int flags)
 {
+  int MAX_SHORT_DOC_LEN = (view_x1 - view_x0 + 1) / 2 - 1;
+  int MAX_LONG_DOC_LEN = (view_x1 - view_x0) - 14;
+
   if (! *arg)
     {
       /* Invoked with no argument. Print the list of the short docs.  */
@@ -1413,13 +1549,13 @@
 	    len = MAX_SHORT_DOC_LEN - 1;
 
 	  for (i = 0; i < len; i++)
-	    grub_putchar ((*builtin)->short_doc[i]);
+	    putchar ((*builtin)->short_doc[i]);
 
 	  for (; i < MAX_SHORT_DOC_LEN; i++)
-	    grub_putchar (' ');
+	    putchar (' ');
 
 	  if (! left)
-	    grub_putchar ('\n');
+	    putchar ('\n');
 
 	  left = ! left;
 	}
@@ -1469,8 +1605,8 @@
 
 		      grub_printf ("    ");
 		      for (i = 0; i < len; i++)
-			grub_putchar (*doc++);
-		      grub_putchar ('\n');
+			putchar (*doc++);
+		      putchar ('\n');
 		    }
 		}
 	    }
@@ -3144,6 +3280,74 @@
   "Save the current entry as the default boot entry."
 };
 
+#ifdef VGA16
+/*splashimage*/
+static int
+splashimage_func(char *arg, int flags)
+{
+    if (strlen(arg) > 63)
+	return (1);
+    if (flags == BUILTIN_CMDLINE) {
+	if (!grub_open(arg))
+	    return (1);
+	grub_close();
+    }
+
+    if (flags == BUILTIN_CMDLINE || !splash_set) {
+	strcpy(splashimage, arg);
+	splash_set = 1;
+    }
+
+    if (flags == BUILTIN_CMDLINE && vga_inited) {
+	display->End();
+	display->Begin();
+	cls();
+/*	grub_longjmp(restart_env, 0);*/
+    }
+
+    return (0);
+}
+
+static struct builtin builtin_splashimage =
+{
+  "splashimage",
+  splashimage_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "splashimage FILE",
+  "Load FILE as the background image when in graphics mode."
+};
+
+/*shade*/
+static int
+shade_func(char *arg, int flags)
+{
+   int new_shade;
+
+    if (!arg || safe_parse_maxint(&arg, &new_shade) == 0)
+	return (1);
+
+    if (shade != new_shade) {
+	shade = new_shade;
+	if (flags == BUILTIN_CMDLINE && vga_inited) {
+	    display->End();
+	    display->Begin();
+	    cls();
+	}
+    }
+
+    return (0);
+}
+
+static struct builtin builtin_shade =
+{
+  "shade",
+  shade_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "shade INTEGER",
+  "If set to 0, disables the use of shaded text, else enables it."
+};
+#endif /* VGA16 */
+
 
 #ifdef SUPPORT_SERIAL
 /* serial */
@@ -4420,16 +4624,79 @@
   "Probe VBE information. If the mode number MODE is specified, show only"
   "the information about only the mode."
 };
-  
+
+#ifdef VGA16
 
+/* viewport */
+static int
+viewport_func (char *arg, int flags)
+{
+    int i;
+    int x0 = 80, y0 = 25, x1 = 0, y1 = 0;
+    int *pos[4] = { &x0, &y0, &x1, &y1 };
+    extern int viewport_set;
+
+    if (!arg)
+	return (1);
+    for (i = 0; i < 4; i++) {
+	if (!*arg)
+	    return (1);
+	while (*arg && (*arg == ' ' || *arg == '\t'))
+	    ++arg;
+	if (!safe_parse_maxint(&arg, pos[i]))
+	    return (1);
+	while (*arg && (*arg != ' ' && *arg != '\t'))
+	    ++arg;
+    }
+
+    x1 += x0;
+    y1 += y0;
+
+    /* minimum size is 60 colums and 16 rows */
+    if (x0 > x1 - 60 || y0 > y1 - 16 || x0 < 0 || y0 < 0 || x1 > 80 || y1 > 30)
+	return (1);
+
+    viewport_set = 1;
+    view_x0 = x0;
+    view_y0 = y0;
+    view_x1 = x1;
+    view_y1 = y1;
+
+    if (flags == BUILTIN_CMDLINE && vga_inited) {
+	display->End();
+	display->Begin();
+	cls();
+    }
+
+    return (0);
+}
+
+static struct builtin builtin_viewport =
+{
+  "viewport",
+  viewport_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU,
+  "viewport x y width height",
+  "Changes grub internals to output text in the window defined by"
+  " four parameters. The x and y parameters are 0 based. This option"
+  " only works with the vga interface."
+};
+#endif /* VGA16 */
+  
 /* The table of builtin commands. Sorted in dictionary order.  */
 struct builtin *builtin_table[] =
 {
+#ifdef VGA16
+  &builtin_background,
+#endif /* VGA16 */
   &builtin_blocklist,
   &builtin_boot,
 #ifdef SUPPORT_NETBOOT
   &builtin_bootp,
 #endif /* SUPPORT_NETBOOT */
+#ifdef VGA16
+  &builtin_border,
+#endif /* VGA16 */
   &builtin_cat,
   &builtin_chainloader,
   &builtin_cmp,
@@ -4443,11 +4710,17 @@
 #ifdef SUPPORT_NETBOOT
   &builtin_dhcp,
 #endif /* SUPPORT_NETBOOT */
+#ifdef VGA16
+  &builtin_display,
+#endif /* VGA16 */
   &builtin_displayapm,
   &builtin_displaymem,
   &builtin_embed,
   &builtin_fallback,
   &builtin_find,
+#ifdef VGA16
+  &builtin_foreground,
+#endif /* VGA16 */
   &builtin_fstest,
   &builtin_geometry,
   &builtin_halt,
@@ -4490,6 +4763,10 @@
 #endif /* SUPPORT_SERIAL */
   &builtin_setkey,
   &builtin_setup,
+#ifdef VGA16
+  &builtin_shade,
+  &builtin_splashimage,
+#endif /* VGA16 */
 #if defined(SUPPORT_SERIAL) || defined(SUPPORT_HERCULES)
   &builtin_terminal,
 #endif /* SUPPORT_SERIAL || SUPPORT_HERCULES */
@@ -4503,5 +4780,8 @@
   &builtin_unhide,
   &builtin_uppermem,
   &builtin_vbeprobe,
+#ifdef VGA16
+  &builtin_viewport,
+#endif /* VGA16 */
   0
 };
Only in grub/stage2: builtins.c.vga16
diff -ur grub.bak/stage2/char_io.c grub/stage2/char_io.c
--- grub.bak/stage2/char_io.c	Thu Jun 21 22:32:56 2001
+++ grub/stage2/char_io.c	Sun Jun 24 23:44:19 2001
@@ -263,8 +263,8 @@
 
   /* XXX: These should be defined in shared.h, but I leave these here,
      until this code is freezed.  */
-#define CMDLINE_WIDTH	78
-#define CMDLINE_MARGIN	10
+  int CMDLINE_WIDTH = (view_x1 - view_x0) - 2;
+  int CMDLINE_MARGIN = 10;
   
   int xpos, lpos, c, section;
   /* The length of PROMPT.  */
@@ -314,7 +314,7 @@
 	    {
 	      int y = getxy () & 0xFF;
 	      
-	      gotoxy (xpos, y);
+	      gotoxy (xpos + view_x0, y);
 	    }
 # ifdef SUPPORT_SERIAL
 	  else if (! (terminal & TERMINAL_DUMB) && (count > 4))
@@ -326,7 +326,7 @@
 	      int i;
 	      
 	      for (i = 0; i < count; i++)
-		grub_putchar ('\b');
+		putchar ('\b');
 	    }
 # endif /* SUPPORT_SERIAL */
 	}
@@ -352,7 +352,7 @@
 	    {
 	      int y = getxy () & 0xFF;
 	      
-	      gotoxy (xpos, y);
+	      gotoxy (xpos + view_x0, y);
 	    }
 # ifdef SUPPORT_SERIAL
 	  else if (! (terminal & TERMINAL_DUMB) && (count > 4))
@@ -366,9 +366,9 @@
 	      for (i = lpos - count; i < lpos; i++)
 		{
 		  if (! echo_char)
-		    grub_putchar (buf[i]);
+		    putchar (buf[i]);
 		  else
-		    grub_putchar (echo_char);
+		    putchar (echo_char);
 		}
 	    }
 # endif /* SUPPORT_SERIAL */
@@ -395,7 +395,7 @@
 	  /* From the start to the end.  */
 	  len = CMDLINE_WIDTH;
 	  pos = 0;
-	  grub_putchar ('\r');
+	  putchar ('\r');
 
 	  /* If SECTION is the first section, print the prompt, otherwise,
 	     print `<'.  */
@@ -407,7 +407,7 @@
 	    }
 	  else
 	    {
-	      grub_putchar ('<');
+	      putchar ('<');
 	      len--;
 	      pos++;
 	    }
@@ -443,9 +443,9 @@
       for (i = start; i < start + len && i < llen; i++)
 	{
 	  if (! echo_char)
-	    grub_putchar (buf[i]);
+	    putchar (buf[i]);
 	  else
-	    grub_putchar (echo_char);
+	    putchar (echo_char);
 
 	  pos++;
 	}
@@ -453,7 +453,7 @@
       /* Fill up the rest of the line with spaces.  */
       for (; i < start + len; i++)
 	{
-	  grub_putchar (' ');
+	  putchar (' ');
 	  pos++;
 	}
 
@@ -462,9 +462,9 @@
       if (pos == CMDLINE_WIDTH)
 	{
 	  if (start + len < llen)
-	    grub_putchar ('>');
+	    putchar ('>');
 	  else
-	    grub_putchar (' ');
+	    putchar (' ');
 	  
 	  pos++;
 	}
@@ -478,7 +478,7 @@
 	{
 	  int y = getxy () & 0xFF;
 	  
-	  gotoxy (xpos, y);
+	  gotoxy (xpos + view_x0, y);
 	}
 # ifdef SUPPORT_SERIAL      
       else if (! (terminal & TERMINAL_SERIAL) && (pos - xpos > 4))
@@ -488,7 +488,7 @@
       else
 	{
 	  for (i = 0; i < pos - xpos; i++)
-	    grub_putchar ('\b');
+	    putchar ('\b');
 	}
 # endif /* SUPPORT_SERIAL */
     }
@@ -497,7 +497,7 @@
   void cl_init (void)
     {
       /* Distinguish us from other lines and error messages!  */
-      grub_putchar ('\n');
+      putchar ('\n');
 
       /* Print full line and set position here.  */
       cl_refresh (1, 0);
@@ -628,7 +628,7 @@
 			/* There are more than one candidates, so print
 			   the list.  */
 
-			grub_putchar ('\n');
+			putchar ('\n');
 			/* Enable the auto fill mode temporarily.  */
 			auto_fill = 1;
 			print_completions (is_filename, 0);
@@ -770,7 +770,7 @@
 	}
     }
 
-  grub_putchar ('\n');
+  putchar ('\n');
 
   /* If ECHO_CHAR is NUL, remove the leading spaces.  */
   lpos = 0;
@@ -1116,7 +1116,7 @@
     {
       /* Fold a line only if AUTO_FILL is true.  */
       if (auto_fill && col >= 79)
-	grub_putchar ('\n');
+	putchar ('\n');
 
       col++;
     }
@@ -1139,7 +1139,7 @@
 
 #ifndef STAGE1_5
 void
-gotoxy (int x, int y)
+grub_gotoxy (int x, int y)
 {
   if (terminal & TERMINAL_CONSOLE)
     console_gotoxy (x, y);
@@ -1163,7 +1163,7 @@
 #endif /* SUPPORT_SERIAL */
 
 int
-getxy (void)
+grub_getxy (void)
 {
   int ret = 0;
   
@@ -1268,7 +1268,7 @@
 #endif /* SUPPORT_SERIAL */
 
 void
-cls (void)
+grub_cls (void)
 {
   if (terminal & TERMINAL_CONSOLE)
     console_cls ();
@@ -1289,7 +1289,7 @@
 {
   /* If the terminal is dumb, there is no way to clean the terminal.  */
   if (terminal & TERMINAL_DUMB)
-    grub_putchar ('\n');
+    putchar ('\n');
   else
     grub_printf ("\e[H\e[J");
 }
Only in grub/stage2: char_io.c.vga16
diff -ur grub.bak/stage2/cmdline.c grub/stage2/cmdline.c
--- grub.bak/stage2/cmdline.c	Tue Oct 17 09:37:27 2000
+++ grub/stage2/cmdline.c	Sun Jun 24 23:44:19 2001
@@ -126,7 +126,7 @@
   init_page ();
 #ifdef SUPPORT_DISKLESS
   print_network_configuration ();
-  grub_putchar ('\n');
+  putchar ('\n');
 #endif
   print_cmdline_message (forever);
 
Only in grub/stage2: cmdline.c.vga16
diff -ur grub.bak/stage2/disk_io.c grub/stage2/disk_io.c
--- grub.bak/stage2/disk_io.c	Thu Jun 21 22:32:56 2001
+++ grub/stage2/disk_io.c	Sun Jun 24 23:44:19 2001
@@ -1243,7 +1243,7 @@
 	}
 
       if (! is_completion)
-	grub_putchar ('\n');
+	putchar ('\n');
       
       print_error ();
       do_completion = 0;
@@ -1310,7 +1310,7 @@
 		}
 
 	      if (! is_completion)
-		grub_putchar ('\n');
+		putchar ('\n');
 	    }
 	  else
 	    {
@@ -1384,7 +1384,7 @@
 	    }
 	  
 	  if (! is_completion)
-	    grub_putchar ('\n');
+	    putchar ('\n');
 	}
       else
 	errnum = ERR_BAD_FILENAME;
Only in grub/stage2: disk_io.c.vga16
diff -ur grub.bak/stage2/shared.h grub/stage2/shared.h
--- grub.bak/stage2/shared.h	Thu Jun 21 22:32:56 2001
+++ grub/stage2/shared.h	Sun Jun 24 23:44:43 2001
@@ -45,6 +45,12 @@
 # define RAW_SEG(x) (x)
 #endif
 
+#if defined(VGA16)
+#if defined(GRUB_UTIL) || defined(STAGE1_5)
+#undef VGA16
+#endif
+#endif
+
 /*
  *  Integer sizes
  */
@@ -362,8 +368,10 @@
 #define isspace grub_isspace
 #define printf grub_printf
 #define sprintf grub_sprintf
+#ifndef VGA16
 #undef putchar
 #define putchar grub_putchar
+#endif
 #define strncat grub_strncat
 #define strstr grub_strstr
 #define memcmp grub_memcmp
@@ -378,6 +386,9 @@
 /*
  *  Below this should be ONLY defines and other constructs for C code.
  */
+#ifdef VGA16
+#define VIDEO		0xA0000
+#endif
 
 /* multiboot stuff */
 
@@ -763,26 +774,26 @@
 int currticks (void);
 
 /* Clear the screen. */
-void cls (void);
+void grub_cls (void);
 
 /* The console part of cls.  */
 void console_cls (void);
 
 #ifndef GRUB_UTIL
 /* Turn off cursor. */
-void nocursor (void);
+void grub_nocursor (void);
 #endif
 
 /* Get the current cursor position (where 0,0 is the top left hand
    corner of the screen).  Returns packed values, (RET >> 8) is x,
    (RET & 0xff) is y. */
-int getxy (void);
+int grub_getxy (void);
 
 /* The console part of getxy.  */
 int console_getxy (void);
 
 /* Set the cursor position. */
-void gotoxy (int x, int y);
+void grub_gotoxy (int x, int y);
 
 /* The console part of gotoxy.  */
 void console_gotoxy (int x, int y);
@@ -812,8 +823,64 @@
    constants defined above. */
 void set_attrib (int attr);
 
+extern int view_x0, view_y0, view_x1, view_y1;
+#ifdef VGA16
+#define MAX_DISPLAYS	2
+
+#define cls()		(display->Cls ? (*display->Cls)() : 0)
+#define gotoxy(x, y)	(display->Gotoxy ? (*display->Gotoxy)(x, y) : 0)
+#define putchar(c)	(display->Putchar ? (*display->Putchar)(c) : 0)
+#define console_set_attrib(a)	(display->SetAttrib ? (*display->SetAttrib)(a) : 0)
+#define getxy()		(display->Getxy ? (*display->Getxy)() : 0)
+#define nocursor()	(display->Nocursor ? (*display->Nocursor)() : 0)
+struct display_entry {
+    char *name;
+    int (*Begin)(void);
+    void (*End)(void);
+    void (*Cls)(void);
+    void (*Gotoxy)(int x, int y);
+    void (*Putchar)(int ch);
+    void (*SetAttrib)(int attr);
+    int (*Getxy)(void);
+    void (*Nocursor)(void);
+};
+struct display_entry display_entries[MAX_DISPLAYS + 1];
+extern struct display_entry *display;
+
+extern int vga_inited, foreground, background, shade, border;
+extern int display_idx, splash_set;
+extern short cursorX, cursorY, cursorWidth, cursorHeight;
+extern char cursorBuf[16], splashimage[64];
+
+int vga16_begin(void);
+void vga16_end(void);
+void vga16_cls(void);
+void vga16_gotoxy(int x, int y);
+void vga16_putchar(int ch);
+int vga16_getxy(void);
+void vga16_nocursor(void);
+void vga16_set_attrib(int attr);
+
+int read_image();
+void set_palette(int index, int red, int green, int blue);
+void *get_font(void);
+/* return previous video mode */
+int set_videomode(int mode);
+
+int hex(int);
+void set_int1c_handler();
+void unset_int1c_handler();
+void cursor(int state);
+#else
+#define cls		grub_cls
+#define gotoxy		grub_gotoxy
+#define console_set_attrib	grub_set_attrib
+#define getxy		grub_getxy
+#define nocursor	grub_nocursor
+#endif
+
 /* The console part of set_attrib.  */
-void console_set_attrib (int attr);
+void grub_set_attrib (int attr);
 
 /* Low-level disk I/O */
 int get_diskinfo (int drive, struct geometry *geometry);
Only in grub/stage2: shared.h.vga16
diff -ur grub.bak/stage2/stage2.c grub/stage2/stage2.c
--- grub.bak/stage2/stage2.c	Fri May 25 03:57:57 2001
+++ grub/stage2/stage2.c	Sun Jun 24 23:44:19 2001
@@ -20,7 +20,12 @@
 
 #include "shared.h"
 
+int view_x0 = 0, view_y0 = 0, view_x1 = 80, view_y1 = 25;
 grub_jmp_buf restart_env;
+#ifdef VGA16
+int vga_disabled = 0, viewport_set = 0;
+int sx0, sy0, sx1, sy1;
+#endif
 
 #ifdef PRESET_MENU_STRING
 
@@ -96,12 +101,12 @@
     }
 #endif /* SUPPORT_SERIAL */
   
-  gotoxy (77, y + 1);
+  gotoxy (view_x1 - 3, y + 1);
 
   if (first)
-    grub_putchar (disp_up);
+    putchar (disp_up);
   else
-    grub_putchar (' ');
+    putchar (' ');
 
   menu_entries = get_entry (menu_entries, first, 0);
 
@@ -109,13 +114,13 @@
     {
       int j = 0;
 
-      gotoxy (3, y + i);
+      gotoxy (view_x0 + 3, y + i);
 
       while (*menu_entries)
 	{
-	  if (j < 71)
+	  if (j < (view_x1 - view_x0) - 9)
 	    {
-	      grub_putchar (*menu_entries);
+	      putchar (*menu_entries);
 	      j++;
 	    }
 
@@ -125,16 +130,16 @@
       if (*(menu_entries - 1))
 	menu_entries++;
 
-      for (; j < 71; j++)
-	grub_putchar (' ');
+      for (; j < (view_x1 - view_x0) - 9; j++)
+	putchar (' ');
     }
 
-  gotoxy (77, y + size);
+  gotoxy (view_x0 + 3, y + size);
 
   if (*menu_entries)
-    grub_putchar (disp_down);
+    putchar (disp_down);
   else
-    grub_putchar (' ');
+    putchar (' ');
 }
 
 
@@ -198,10 +203,10 @@
       )
 # endif
     {
-      for (i = 0; i < 14; i++)
+      for (i = 0; i < 12; i++)
 	{
 	  int j;
-	  for (j = 0; j < 75; j++)
+	  for (j = view_x0; j < (view_x1 - view_x0) - 5; j++)
 	    {
 	      gotoxy (j + 1, i + y);
 	      set_attrib (normal_color);
@@ -210,33 +215,33 @@
     }
 #endif
 
-  gotoxy (1, y);
+  gotoxy (view_x0 + 1, y);
 
-  grub_putchar (disp_ul);
-  for (i = 0; i < 73; i++)
-    grub_putchar (disp_horiz);
-  grub_putchar (disp_ur);
+  putchar (disp_ul);
+  for (i = view_x0; i < view_x1 - 7; i++)
+    putchar (disp_horiz);
+  putchar (disp_ur);
 
   i = 1;
 
   while (1)
     {
-      gotoxy (1, y + i);
+      gotoxy (view_x0 + 1, y + i);
 
       if (i > size)
 	break;
 
-      grub_putchar (disp_vert);
-      gotoxy (75, y + i);
-      grub_putchar (disp_vert);
+      putchar (disp_vert);
+      gotoxy (view_x1 - 5, y + i);
+      putchar (disp_vert);
 
       i++;
     }
 
-  grub_putchar (disp_ll);
-  for (i = 0; i < 73; i++)
-    grub_putchar (disp_horiz);
-  grub_putchar (disp_lr);
+  putchar (disp_ll);
+  for (i = view_x0; i < view_x1 - 7; i++)
+    putchar (disp_horiz);
+  putchar (disp_lr);
 }
 
 static void
@@ -248,27 +253,27 @@
   if (terminal & TERMINAL_SERIAL)
     {
       menu_entries = get_entry (menu_entries, entryno, 0);
-      gotoxy (2, y);
-      grub_putchar (' ');
-      for (x = 3; x < 75; x++)
+      gotoxy (view_x0 + 2, y);
+      putchar (' ');
+      for (x = view_x0 + 3; x < view_x1 - 5; x++)
 	{
-	  if (*menu_entries && x < 71)
-	    grub_putchar (*menu_entries++);
+	  if (*menu_entries && x < view_x1 - 9)
+	    putchar (*menu_entries++);
 	  else
-	    grub_putchar (' ');
+	    putchar (' ');
 	}
     }
   else
 #endif /* SUPPORT_SERIAL */
     {
-      for (x = 2; x < 75; x++)
+      for (x = view_x0 + 2; x < view_x1 - 5; x++)
 	{
 	  gotoxy (x, y);
 	  set_attrib (attr);
 	}
     }
 
-  gotoxy (74, y);
+  gotoxy (view_x1 - 6, y);
 }
 
 /* Set the attribute of the line Y to normal state.  */
@@ -321,7 +326,8 @@
      invariant for TERMINAL_DUMB: first_entry == 0  */
   if (! (terminal & TERMINAL_DUMB))
     {
-      while (entryno > 11)
+      errnum = ERR_NONE;
+      while (entryno > 9)
 	{
 	  first_entry++;
 	  entryno--;
@@ -386,7 +392,7 @@
 #endif /* ! GRUB_UTIL */
 
       if (! (terminal & TERMINAL_DUMB))      
-	  print_border (3, 12);
+	  print_border (3 + view_y0, 12);
 
 #ifdef GRUB_UTIL
       /* In the grub shell, always use ACS_*.  */
@@ -442,10 +448,10 @@
 	grub_printf ("\n\nThe selected entry is %d ", entryno);
       else
       {
-	  print_entries (3, 12, first_entry, menu_entries);
+	  print_entries (view_y0 + 3, 12, first_entry, menu_entries);
 	  
 	  /* highlight initial line */
-	  set_line_highlight (4 + entryno, first_entry + entryno, 
+	  set_line_highlight (view_y0 + 4 + entryno, first_entry + entryno, 
 			      menu_entries);
       }
     }
@@ -474,9 +480,9 @@
 			   entryno, grub_timeout);
 	  else
 	  {
-	      gotoxy (3, 22);
+	      gotoxy (view_x0 + 3, view_y1 - 3);
 	      printf ("The highlighted entry will be booted automatically in %d seconds.    ", grub_timeout);
-	      gotoxy (74, 4 + entryno);
+	      gotoxy (view_x0 - 6, view_y0 + 4 + entryno);
 	  }
 	  
 	  grub_timeout--;
@@ -502,12 +508,12 @@
 	      if (terminal & TERMINAL_DUMB)
 		grub_putchar ('\r');
 	      else
-		gotoxy (3, 22);
+		gotoxy (view_x0 + 3, 22);
 	      printf ("                                                                    ");
 	      grub_timeout = -1;
 	      fallback_entry = -1;
 	      if (! (terminal & TERMINAL_DUMB))
-		gotoxy (74, 4 + entryno);
+		gotoxy (view_x1 - 6, view_x0 + 4 + entryno);
 	    }
 
 	  /* We told them above (at least in SUPPORT_SERIAL) to use
@@ -523,17 +529,17 @@
 		{
 		  if (entryno > 0)
 		    {
-		      set_line_normal (4 + entryno, first_entry + entryno,
+		      set_line_normal (view_y0 + 4 + entryno, first_entry + entryno,
 				       menu_entries);
 		      entryno--;
-		      set_line_highlight (4 + entryno, first_entry + entryno,
+		      set_line_highlight (view_y0 + 4 + entryno, first_entry + entryno,
 					  menu_entries);
 		    }
 		  else if (first_entry > 0)
 		    {
 		      first_entry--;
-		      print_entries (3, 12, first_entry, menu_entries);
-		      set_line_highlight (4, first_entry + entryno, 
+		      print_entries (view_y0 + 3, 12, first_entry, menu_entries);
+		      set_line_highlight (view_y0 + 4, first_entry + entryno, 
 					  menu_entries);
 		    }
 		}
@@ -545,17 +551,17 @@
 	      else
 		if (entryno < 11)
 		  {
-		    set_line_normal (4 + entryno, first_entry + entryno,
+		    set_line_normal (view_y0 + 4 + entryno, first_entry + entryno,
 				     menu_entries);
 		    entryno++;
-		    set_line_highlight (4 + entryno, first_entry + entryno,
+		    set_line_highlight (view_y0 + 4 + entryno, first_entry + entryno,
 					menu_entries);
 		  }
 		else if (num_entries > 12 + first_entry)
 		  {
 		    first_entry++;
-		    print_entries (3, 12, first_entry, menu_entries);
-		    set_line_highlight (15, first_entry + entryno, menu_entries);
+		    print_entries (view_y0 + 3, 12, first_entry, menu_entries);
+		    set_line_highlight (view_y0 + 15, first_entry + entryno, menu_entries);
 		  }
 	    }
 
@@ -569,7 +575,7 @@
 	      if ((c == 'd') || (c == 'o') || (c == 'O'))
 		{
 		  if (! (terminal & TERMINAL_DUMB))
-		    set_line_normal (4 + entryno, first_entry + entryno,
+		    set_line_normal (view_y0 + 4 + entryno, first_entry + entryno,
 				     menu_entries);
 
 		  /* insert after is almost exactly like insert before */
@@ -627,8 +633,8 @@
 		    }
 		  else
 		    {
-		      print_entries (3, 12, first_entry, menu_entries);
-		      set_line_highlight (4 + entryno, first_entry + entryno,
+		      print_entries (view_y0 + 3, 12, first_entry, menu_entries);
+		      set_line_highlight (view_y0 + 4 + entryno, first_entry + entryno,
 					  menu_entries);
 		    }
 		}
@@ -651,7 +657,7 @@
 		  if (terminal & TERMINAL_DUMB)
 		    grub_printf ("\r                                    ");
 		  else
-		    gotoxy (1, 21);
+		    gotoxy (view_x0 + 1, view_y1 + 21);
 
 		  /* Wipe out the previously entered password */
 		  memset (entered, 0, sizeof (entered));
@@ -798,6 +804,11 @@
   while (1)
     {
       cls ();
+#ifdef VGA16
+      if (display->End)
+	(*display->End)();
+      display = &display_entries[0];
+#endif
 
       if (config_entries)
 	printf ("  Booting \'%s\'\n\n",
@@ -827,6 +838,16 @@
 	break;
     }
 
+#ifdef VGA16
+      if (display_idx >= 0)
+	display = &display_entries[display_idx];
+      else if (!vga_disabled)
+	display = &display_entries[1];
+
+      if (!display->Begin || !(*display->Begin)())
+	display = &display_entries[0];
+#endif
+
   show_menu = 1;
   goto restart;
 }
@@ -891,6 +912,560 @@
   return pos;
 }
 
+#ifdef VGA16
+struct display_entry display_entries[MAX_DISPLAYS + 1] = {
+    {"text", 0, 0, grub_cls, grub_gotoxy, grub_putchar, grub_set_attrib,
+     grub_getxy, grub_nocursor},
+    {"vga16",
+     vga16_begin, vga16_end, vga16_cls, vga16_gotoxy, vga16_putchar,
+     vga16_set_attrib, vga16_getxy, vga16_nocursor},
+    {0, 0, 0, 0, 0, 0, 0, 0, 0}
+};
+struct display_entry *display;
+int display_idx = -1;
+
+/* default vga palette */
+char vga16pal[16][3] = {
+    { 0,  0,  0},
+    { 0,  0, 42},
+    { 0, 42,  0},
+    { 0, 42, 42},
+    {42,  0,  0},
+    {42,  0, 42},
+    {42, 21,  0},
+    {42, 42, 42},
+    {21, 21, 21},
+    {21, 21, 63},
+    {21, 63, 21},
+    {21, 63, 63},
+    {63, 21, 21},
+    {63, 21, 63},
+    {63, 63, 21},
+    {63, 63, 63},
+};
+
+int fontx, fonty;
+unsigned char *font8x16;
+int saved_videomode, no_scroll = 0, no_cursor = 0, shade = 1, vga_inited = 0;
+unsigned short text[80 * 30];
+int foreground = (63 << 16) | (63 << 8) | (63), background = 0, border = 0;
+int splash_set;
+char splashimage[64];
+#define VSHADOW VSHADOW1
+unsigned char VSHADOW1[38400];
+unsigned char VSHADOW2[38400];
+unsigned char VSHADOW4[38400];
+unsigned char VSHADOW8[38400];
+
+static inline void
+outb(unsigned short port, unsigned char val)
+{
+    __asm __volatile ("outb %0,%1"::"a" (val), "d" (port));
+}
+
+static void
+ModeReg(int value)
+{
+    outb(0x3ce, 5);
+    outb(0x3cf, value);
+}
+
+static void
+MapMask(int value)
+{
+    outb(0x3c4, 2);
+    outb(0x3c5, value);
+}
+
+/* set/reset register */
+static void
+SetRes(int value)
+{
+    outb(0x3ce, 0);
+    outb(0x3cf, value);
+}
+
+/* enable set/reset register */
+static void
+ESetRes(int value)
+{
+    outb(0x3ce, 1);
+    outb(0x3cf, value);
+}
+
+static void
+ReadMap(int value)
+{
+    outb(0x3ce, 4);
+    outb(0x3cf, value);
+}
+
+/* bit mask register */
+static void
+BitMask(int value)
+{
+    outb(0x3ce, 8);
+    outb(0x3cf, value);
+}
+
+void
+grub_memcpy(void *dest, const void *src, int len)
+{
+    int i;
+    register char *d = (char*)dest, *s = (char*)src;
+
+    for (i = 0; i < len; i++)
+	d[i] = s[i];
+}
+
+int
+hex(int v)
+{
+    if (v >= 'A' && v <= 'F')
+	return (v - 'A' + 10);
+    if (v >= 'a' && v <= 'f')
+	return (v - 'a' + 10);
+    return (v - '0');
+}
+
+static void
+SetXY(int col, int row)
+{
+    if (col >= view_x0 && col < view_x1) {
+	fontx = col;
+	cursorX = col << 3;
+    }
+    if (row >= view_y0 && row < view_y1) {
+	fonty = row;
+	cursorY = row << 4;
+    }
+}
+
+void
+cursor(int set)
+{
+    unsigned char *pat, *mem, *ptr, chr[16 << 2];
+    int i, ch, invert, offset;
+
+    if (set && (no_cursor || no_scroll))
+	return;
+
+    offset = cursorY * 80 + fontx;
+    ch = text[fonty * 80 + fontx] & 0xff;
+    invert = (text[fonty * 80 + fontx] & 0xff00) != 0;
+    pat = font8x16 + (ch << 4);
+
+    mem = (unsigned char*)VIDEO + offset;
+
+    if (!set) {
+	for (i = 0; i < 16; i++) {
+	    unsigned char mask = pat[i];
+
+	    if (!invert) {
+		chr[i	  ] = ((unsigned char*)VSHADOW1)[offset];
+		chr[16 + i] = ((unsigned char*)VSHADOW2)[offset];
+		chr[32 + i] = ((unsigned char*)VSHADOW4)[offset];
+		chr[48 + i] = ((unsigned char*)VSHADOW8)[offset];
+
+		if (shade) {
+		    if (ch == DISP_VERT || ch == DISP_LL ||
+			ch == DISP_UR || ch == DISP_LR) {
+			unsigned char pmask = ~(pat[i] >> 1);
+
+			chr[i     ] &= pmask;
+			chr[16 + i] &= pmask;
+			chr[32 + i] &= pmask;
+			chr[48 + i] &= pmask;
+		    }
+		    if (i > 0 && ch != DISP_VERT) {
+			unsigned char pmask = ~(pat[i - 1] >> 1);
+
+			chr[i	  ] &= pmask;
+			chr[16 + i] &= pmask;
+			chr[32 + i] &= pmask;
+			chr[48 + i] &= pmask;
+			if (ch == DISP_HORIZ || ch == DISP_UR || ch == DISP_LR) {
+			    pmask = ~pat[i - 1];
+
+			    chr[i     ] &= pmask;
+			    chr[16 + i] &= pmask;
+			    chr[32 + i] &= pmask;
+			    chr[48 + i] &= pmask;
+			}
+		    }
+		}
+		chr[i     ] |= mask;
+		chr[16 + i] |= mask;
+		chr[32 + i] |= mask;
+		chr[48 + i] |= mask;
+
+		offset += 80;
+	    }
+	    else {
+		chr[i	  ] = mask;
+		chr[16 + i] = mask;
+		chr[32 + i] = mask;
+		chr[48 + i] = mask;
+	    }
+	}
+    }
+    else {
+	MapMask(15);
+	ptr = mem;
+	for (i = 0; i < 16; i++, ptr += 80) {
+	    cursorBuf[i] = pat[i];
+	    *ptr = ~pat[i];
+	}
+	return;
+    }
+
+    offset = 0;
+    for (i = 1; i < 16; i <<= 1, offset += 16) {
+	int j;
+
+	MapMask(i);
+	ptr = mem;
+	for (j = 0; j < 16; j++, ptr += 80)
+	    *ptr = chr[j + offset];
+    }
+
+    MapMask(15);
+}
+
+int
+read_image(void)
+{
+    char buf[32], pal[16];
+    unsigned char c, base, mask, *s1, *s2, *s4, *s8;
+    unsigned i, len, idx, colors, x, y, width, height;
+
+    if (!grub_open(splashimage))
+	return (0);
+
+    /* read header */
+    if (!grub_read((char*)&buf, 10) || grub_memcmp(buf, "/* XPM */\n", 10)) {
+	grub_close();
+	return (0);
+    }
+
+    /* parse info */
+    while (grub_read(&c, 1)) {
+	if (c == '"')
+	    break;
+    }
+
+    while (grub_read(&c, 1) && (c == ' ' || c == '\t'))
+	;
+
+    i = 0;
+    width = c - '0';
+    while (grub_read(&c, 1)) {
+	if (c >= '0' && c <= '9')
+	    width = width * 10 + c - '0';
+	else
+	    break;
+    }
+    while (grub_read(&c, 1) && (c == ' ' || c == '\t'))
+	;
+
+    height = c - '0';
+    while (grub_read(&c, 1)) {
+	if (c >= '0' && c <= '9')
+	    height = height * 10 + c - '0';
+	else
+	    break;
+    }
+    while (grub_read(&c, 1) && (c == ' ' || c == '\t'))
+	;
+
+    colors = c - '0';
+    while (grub_read(&c, 1)) {
+	if (c >= '0' && c <= '9')
+	    colors = colors * 10 + c - '0';
+	else
+	    break;
+    }
+
+    base = 0;
+    while (grub_read(&c, 1) && c != '"')
+	;
+
+    /* palette */
+    for (i = 0, idx = 1; i < colors; i++) {
+	len = 0;
+
+	while (grub_read(&c, 1) && c != '"')
+	    ;
+	grub_read(&c, 1);	/* char */
+	base = c;
+	grub_read(buf, 4);	/* \t c # */
+
+	while (grub_read(&c, 1) && c != '"') {
+	    if (len < sizeof(buf))
+		buf[len++] = c;
+	}
+
+	if (len == 6 && idx < 15) {
+	    int r = ((hex(buf[0]) << 4) | hex(buf[1])) >> 2;
+	    int g = ((hex(buf[2]) << 4) | hex(buf[3])) >> 2;
+	    int b = ((hex(buf[4]) << 4) | hex(buf[5])) >> 2;
+
+	    pal[idx] = base;
+	    set_palette(idx, r, g, b);
+	    ++idx;
+	}
+    }
+
+    x = y = len = 0;
+
+    s1 = (unsigned char*)VSHADOW1;
+    s2 = (unsigned char*)VSHADOW2;
+    s4 = (unsigned char*)VSHADOW4;
+    s8 = (unsigned char*)VSHADOW8;
+
+    for (i = 0; i < 38400; i++)
+	s1[i] = s2[i] = s4[i] = s8[i] = 0;
+
+    /* parse xpm data */
+    while (y < height) {
+	while (1) {
+	    if (!grub_read(&c, 1)) {
+		grub_close();
+		return (0);
+	    }
+	    if (c == '"')
+		break;
+	}
+
+	while (grub_read(&c, 1) && c != '"') {
+	    for (i = 1; i < 15; i++)
+		if (pal[i] == c) {
+		    c = i;
+		    break;
+		}
+
+	    mask = 0x80 >> (x & 7);
+	    if (c & 1)
+		s1[len + (x >> 3)] |= mask;
+	    if (c & 2)
+		s2[len + (x >> 3)] |= mask;
+	    if (c & 4)
+		s4[len + (x >> 3)] |= mask;
+	    if (c & 8)
+		s8[len + (x >> 3)] |= mask;
+
+	    if (++x >= 640) {
+		x = 0;
+
+		if (y < 480)
+		    len += 80;
+		++y;
+	    }
+	}
+    }
+
+    grub_close();
+
+    set_palette(0, (background >> 16), (background >> 8) & 63, background & 63);
+    set_palette(15, (foreground >> 16), (foreground >> 8) & 63, foreground & 63);
+
+    set_palette(0x11, (border >> 16), (border >> 8) & 63, border & 63);
+
+    return (1);
+}
+
+int
+vga16_begin(void)
+{
+    if (vga_inited)
+	return (1);
+
+    if (!*splashimage)
+	grub_strcpy(splashimage, "/boot/grub/splash.xpm");
+
+    saved_videomode = set_videomode(0x12);
+    if (!read_image()) {
+	set_videomode(saved_videomode);
+	return (0);
+    }
+
+    font8x16 = (unsigned char*)get_font();
+
+    cursorWidth = 8;
+    cursorHeight = 16;
+
+    set_int1c_handler();
+
+    view_x0 = sx0;
+    view_y0 = sy0;
+    view_x1 = sx1;
+    view_y1 = sy1;
+
+    return (vga_inited = 1);
+}
+
+void
+vga16_end(void)
+{
+    if (vga_inited) {
+	unset_int1c_handler();
+	set_videomode(saved_videomode);
+	vga_inited = 0;
+	no_cursor = 0;
+    }
+
+    sx0 = view_x0;
+    sy0 = view_y0;
+    sx1 = view_x1;
+    sy1 = view_y1;
+    view_x0 = 0;
+    view_x1 = 80;
+    view_y0 = 0;
+    view_y1 = 25;
+}
+
+void
+vga16_cls(void)
+{
+    int i;
+    unsigned char *mem, *s1, *s2, *s4, *s8;
+
+    SetXY(view_x0, view_y0);
+
+    mem = (unsigned char*)VIDEO;
+    s1 = (unsigned char*)VSHADOW1;
+    s2 = (unsigned char*)VSHADOW2;
+    s4 = (unsigned char*)VSHADOW4;
+    s8 = (unsigned char*)VSHADOW8;
+
+    for (i = 0; i < 80 * 30; i++)
+	text[i] = ' ';
+
+    BitMask(0xff);
+
+    /* plano 1 */
+    MapMask(1);
+    grub_memcpy(mem, s1, 38400);
+
+    /* plano 2 */
+    MapMask(2);
+    grub_memcpy(mem, s2, 38400);
+
+    /* plano 3 */
+    MapMask(4);
+    grub_memcpy(mem, s4, 38400);
+
+    /* plano 4 */
+    MapMask(8);
+    grub_memcpy(mem, s8, 38400);
+
+    MapMask(15);
+
+    if (no_cursor) {
+	no_cursor = 0;
+	set_int1c_handler();
+    }
+}
+
+void
+vga16_gotoxy(int x, int y)
+{
+    cursor(0);
+
+    SetXY(x, y);
+
+    cursor(1);
+}
+
+static void
+scroll(void)
+{
+    int i, j;
+
+    if (no_scroll)
+	return;
+
+    no_scroll = 1;
+
+    for (j = view_y0 + 1; j < view_y1; j++) {
+	gotoxy(view_x0, j - 1);
+	for (i = view_x0; i < view_x1; i++)
+	    putchar(text[j * 80 + i]);
+    }
+
+    gotoxy(view_x0, view_y1 - 1);
+    for (i = view_x0; i < view_x1; i++)
+	putchar(' ');
+
+    SetXY(view_x0, view_y1 - 1);
+
+    no_scroll = 0;
+}
+
+void
+vga16_putchar(int ch)
+{
+    ch &= 0xff;
+
+    cursor(0);
+
+    if (ch == '\n') {
+	SetXY(view_x0, fonty);
+	if (fonty + 1 < view_y1)
+	    SetXY(view_x0, fonty + 1);
+	else
+	    scroll();
+	cursor(1);
+	return;
+    }
+    else if (ch == '\r') {
+	SetXY(view_x0, fonty);
+	cursor(1);
+	return;
+    }
+
+    text[fonty * 80 + fontx] = ch;
+
+    cursor(0);
+
+    if ((fontx + 1) >= view_x1) {
+	SetXY(view_x0, fonty);
+	if (fonty + 1 < view_y1)
+	    SetXY(view_x0, fonty + 1);
+	else
+	    scroll();
+    }
+    else
+	SetXY(fontx + 1, fonty);
+
+    cursor(1);
+}
+
+int
+vga16_getxy()
+{
+    return ((fontx << 8) | fonty);
+}
+
+void
+vga16_nocursor()
+{
+    if (!no_cursor) {
+	no_cursor = 1;
+	unset_int1c_handler();
+	cursor(0);
+    }
+}
+
+void
+vga16_set_attrib(int attrib)
+{
+    text[fonty * 80 + fontx] &= 0x00ff;
+    if (attrib & 0xf0)
+	text[fonty * 80 + fontx] |= 0x100;
+    cursor(0);
+}
+#endif
 
 /* This is the starting function in C.  */
 void
@@ -900,6 +1475,14 @@
   char *config_entries, *menu_entries;
   char *kill_buf = (char *) KILL_BUF;
 
+#ifdef VGA16
+  /* Make sure it points to a valid entry */
+  display = &display_entries[0];
+
+  if (ASCII_CHAR(checkkey()) == 0x1b)
+    vga_disabled = 1;
+#endif
+
   /* Initialize the environment for restarting Stage 2.  */
   grub_setjmp (restart_env);
   
@@ -1038,6 +1621,29 @@
 	    grub_close ();
 	}
 
+#ifdef VGA16
+      if (display_idx >= 0)
+	display = &display_entries[display_idx];
+      else if (!vga_disabled) {
+	display = &display_entries[1];
+      }
+      if (!viewport_set)
+	view_y1 = 30;
+      sx0 = view_x0;
+      sy0 = view_y0;
+      sx1 = view_x1;
+      sy1 = view_y1;
+
+      if (!display->Begin || !(*display->Begin)())
+	display = &display_entries[0];
+
+      if (!vga_inited) {
+	sx0 = sy0 = view_x0 = view_y0 = 0;
+	sx1 = view_x1 = 80;
+	sy1 = view_y1 = 25;	  
+      }
+#endif
+
       if (! num_entries)
 	{
 	  /* If no acceptable config file, goto command-line, starting
Only in grub/stage2: stage2.c.vga16
