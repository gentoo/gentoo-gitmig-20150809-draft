#!/bin/bash
# Copyright 1999-2000 Daniel Robbins, Gentoo Technologies, Inc.
# Distributed under the GPL

if [ ! -f "/usr/lib/portage/bin/python" ]
then
   cp /usr/bin/python /usr/lib/portage/bin/python
fi

if [ "`whoami`" != "root" ]
then
	echo "Since ebuild can modify critical system files, only root is"
	echo "allowed to use the ebuild system."
	exit 1
fi

#allow any envvars to be set like QTDIR, even if Qt was just installed
export PATH=/usr/lib/portage/bin:${PATH}
eval `import-settings PROXY HTTP_PROXY FTP_PROXY DEBUG MAKEOPTS MAINTAINER CHOST CFLAGS CXXFLAGS PORTDIR DISTDIR BUILD_PREFIX PKGDIR RPMDIR PLATFORM ROOT`
eval `import-configsettings FETCHCOMMAND PACKAGE USE GENTOO_MIRRORS PLATFORM`
source /etc/rc.d/config/functions

initvars() {
	export DESTTREE=/usr
	export INSDESTTREE=""
	export EXEDESTTREE=""
	export DOCDESTTREE=""
	export INSOPTIONS="-m0644"
	export EXEOPTIONS="-m0755"	
	export LIBOPTIONS="-m0644"
	export DIROPTIONS="-m0755"
	export MOPREFIX=${PN}
	export KVERS=`uname -r`
}

initvars

src_unpack() { 
	unpack ${A} 
}

src_compile() { 
	return 
}

src_install() 
    { 
	return 
    }

pkg_preinst()
    {
	return
    }

pkg_postinst()
    {
	return
    }

pkg_prerm()
    {
	return
    }

pkg_postrm()
    {
	return
    }

try() {
	eval $*
	if [ $? -ne 0 ]
	then
		echo 
		echo '!!! '"ERROR: the $1 command did not complete successfully."
		echo '!!! '"(\"$*\")"
		echo '!!! '"Since this is a critical task, ebuild will be stopped."
		echo
		exit 1
	fi
}

dyn_touch() {
	local x
	for x in ${A} 
	do
		if [ -e ${DISTDIR}/${x} ]
		then	
			touch ${DISTDIR}/${x}
		fi
	done
}

dyn_digest() {
	local x
	if [ ! -d ${FILESDIR} ]
	then
		install -d ${FILESDIR}
		if [ -n ${MAINTAINER} ]
		then
			echo ">>> adding ${FILESDIR} to CVS (just in case it isn't there)"
			( echo; cd `/usr/bin/dirname ${FILESDIR}`; cvs add `/usr/bin/basename ${FILESDIR}`; echo)
		fi
	fi
	for x in ${A}
	do
		if [ ! -e ${DISTDIR}/${x} ]
		then
			echo '!!! Cannot compute message digests: '${x} not found
			echo "error, aborting."
			exit 1
		else
	    	mymd5=`md5sum ${DISTDIR}/${x} | cut -f1 -d" "`
	    	echo "MD5 $mymd5 $x" >> ${FILESDIR}/.digest-${PF}
		fi
    done
    mv ${FILESDIR}/.digest-${PF} ${FILESDIR}/digest-${PF}
    if [ -n "${MAINTAINER}" ]
    then
		echo ">>> adding digest-${PF} to CVS (just in case it isn't there)"
		( echo; cd ${FILESDIR}; cvs add digest-${PF}; echo )
    fi
    echo ">>> Computed message digests."
}

runtime_depend() {
	#the echo thing is a trick to get rid of newlines
    dopython portage.dep_frontend runtime "`echo ${RDEPEND}`"
    if [ $? -ne 0 ]
    then
		exit 1 
    fi
}

build_depend() {
	#the echo thing is a trick to get rid of newlines
	dopython portage.dep_frontend build "`echo ${DEPEND}`"
	if [ $? -ne 0 ]
	then
		exit 1 
	fi
}

gen_depend() {
	for x in $DEPEND
	do 
		echo "$x" >> ${FILESDIR}/depend-${PF}
	done
	for x in $RDEPEND
	do
		echo "$x" >> ${FILESDIR}/rdepend-${PF}
	done
	echo ">>> Completed generating dependencies for ${PF}."
}

merge_check() {
	dopython portage.merge_check "${CATEGORY}/${PF}"
    if [ $? -ne 0 ]
	then
		echo 
		echo '!!!' "${PF} already merged in ${ROOT} -- unmerge first" 
		echo
		exit 1
    fi
}

digest_check() {
	if [ ! -e ${FILESDIR}/digest-${PF} ]
	then
		echo '!!!'" No message digest file found."
		if [ -n "$MAINTAINER" ]
		then
			echo '>>> Maintainer mode: auto-computing digests.'
			dyn_digest
			return 0
		else
			echo '!!!'" Maintainer: ebuild digest to update message digests."
			return 1
		fi
    fi
	if [ ! -e ${DISTDIR}/${1} ]
	then
		echo '!!!'" ${1} not found."
		echo '!!!'" Ebuild fetch to retrieve files."
		return 1
	fi	
	local mycdigest=`grep " ${1}" ${FILESDIR}/digest-${PF} | cut -f2 -d" "`
	if [ -z "$mycdigest" ]
	then
		echo
		echo '!!!'" No message digest found for ${1}."
		if [ -n "$MAINTAINER" ]
		then
			echo '>>> Maintainer mode: auto-computing digests.'
			dyn_digest
			echo 
			return 0
		else
			echo '!!!'" Maintainer: ebuild digest to update message digests."
			echo
			return 1
		fi
	fi
	local mydigest=`md5sum ${DISTDIR}/${1} | cut -f1 -d" "`
	if [ "$mycdigest" != "$mydigest" ]
	then
		echo
		echo '!!!'" ${1}: message digests do not match!"
		echo '!!!'" ${1} is corrupt or incomplete"
		echo ">>> md5 con ${mycdigest}"
		echo ">>> md5 now ${mydigest}"
		echo ">>> Please delete/redownload ${DISTDIR}/${1}"
		echo
		return 1
	else
		echo ">>> md5 ;-) ${1}"
	fi
	return 0
}

dyn_batchdigest() {
    local x
    if [ ! -e ${FILESDIR}/digest-${PF} ]
    then
	if [ "${A}" != "" ]
	then
		echo "${CATEGORY}/${PF} has no digest file."
	fi
	exit 1
    fi
    	for x in ${A}
    	do
		if [ ! -e ${DISTDIR}/${x} ]
    		then
			echo "${CATEGORY}/${PF}:${x} does not exist in ${DISTDIR}."
			continue
		else
			local mycdigest=`grep " ${x}" ${FILESDIR}/digest-${PF} | cut -f2 -d" "`
			if [ -z "$mycdigest" ]
			then
				echo "${CATEGORY}/${PF}:${x} digest not yet recorded."
				continue
			fi
    			local mydigest=`md5sum ${DISTDIR}/${x} | cut -f1 -d" "`
    			if [ "$mycdigest" != "$mydigest" ]
   			then
				echo "${CATEGORY}/${PF}:${x} is corrupt or has an invalid digest."
			fi
		fi
	done
}


dyn_fetch() {
	local y
	for y in ${A}
	do
		if [ ! -e ${DISTDIR}/${y} ]
		then
			echo ">>> Fetching ${y}..."
			echo
			local x
			local _SRC_URI
		        for x in ${GENTOO_MIRRORS}
			do
			  _SRC_URI="${_SRC_URI} ${x}/distributions/gentoo/gentoo-sources/${y}"
			done
			_SRC_URI="${_SRC_URI} `/usr/bin/queryhost.sh "${SRC_URI}"`"
			for x in ${_SRC_URI}
			do
				if [ ! -e ${DISTDIR}/${y} ] 
				then
			    		if [ $y == ${x##*/} ]
			    		then
						echo ">>> Trying site ${x}..."
						eval "${FETCHCOMMAND}"
						if [ $? -ne 0 ]
		        			then
			    				echo '!!!'" Couldn't download ${y}."
						fi
		    			fi
				fi
			done
			if [ ! -e ${DISTDIR}/${y} ]
			then
  				echo '!!!'" Couldn't download ${y}.  Aborting."
				exit 1
			fi
			echo
    	fi	
	done
	for y in ${A}
	do
		digest_check ${y}
		if [ $? -ne 0 ]
		then
				exit 1
		fi
	done
}

dyn_unpack() {
	trap "abort_unpack" SIGINT SIGQUIT
	local unpackwork="yes"
	if [ -e ${WORKDIR} ]
	then
		local x
		for x in $A $EBUILD
		do
			echo ">>> Checking ${x}'s mtime..."
			if [ ${DISTDIR}/${x} -nt ${WORKDIR} ]
			then
				echo ">>> ${x} has been updated; recreating WORKDIR..."
				rm -rf ${WORKDIR}
				break
			fi
		done
		echo ">>> WORKDIR is up-to-date, not unpacking. (clean to force unpack)"
		unpackwork="no"
	fi
	if [ "$unpackwork" = "yes" ]
	then
		install -m0700 -d ${WORKDIR}
		cd ${WORKDIR}
		echo ">>> Unpacking source..."
		src_unpack
		echo ">>> Source unpacked."
		cd ..
    fi
    trap SIGINT SIGQUIT
}

dyn_clean() {
	if [ -d ${WORKDIR} ]
	then
		rm -rf ${WORKDIR} 
	fi
	if [ -d ${BUILDDIR}/image ]
	then
		rm -rf ${BUILDDIR}/image
	fi
	rm -rf ${BUILDDIR}/.compiled
}

into() {
	if [ $1 = "/" ]
	then
		export DESTTREE=""
	else
		export DESTTREE=$1
		if [ ! -d ${D}${DESTTREE} ]
		then
			install -d ${D}${DESTTREE}
		fi
	fi
}

insinto() {
    if [ $1 = "/" ]
    then
	export INSDESTTREE=""
    else
	export INSDESTTREE=$1
	if [ ! -d ${D}${INSDESTTREE} ]
	then
	    install -d ${D}${INSDESTTREE}
	fi
    fi
}

exeinto() {
    if [ $1 = "/" ]
    then
	export EXEDESTTREE=""
    else
	export EXEDESTTREE=$1
	if [ ! -d ${D}${EXEDESTTREE} ]
	then
	    install -d ${D}${EXEDESTTREE}
	fi
    fi
}
docinto() {
    if [ $1 = "/" ]
    then
	export DOCDESTTREE=""
    else
	export DOCDESTTREE=$1
	if [ ! -d ${D}usr/doc/${PF}/${DOCDESTTREE} ]
	then
	    install -d ${D}usr/doc/${PF}/${DOCDESTTREE} 
	fi
    fi
}

insopts() {
    INSOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             INSOPTIONS="$INSOPTIONS $x"
        fi
    done
    export INSOPTIONS
}

diropts() {
	DIROPTIONS=""
	for x in $*
	do
		DIROPTIONS="${DIROPTIONS} $x"
	done
	export DIROPTIONS
}

doins() {
    local mynum=${#}
    if [ ${mynum} -lt 1 ]
    then
	echo "${0}: at least one argument needed"
	return
    fi
    if [ ! -d ${D}${INSDESTTREE} ]
    then
	install -d ${D}${INSDESTTREE}
    fi
    local x
    local mysrc
    for x in "$@"
    do
	if [ -L $x ]
	then
	    cp $x ${T}
	    mysrc=${T}/`/usr/bin/basename ${x}`
	elif [ -d $x ]
	then
	    echo "doins: warning, skipping directory ${x}"
            continue
        else
	    mysrc=${x}
	fi
        install ${INSOPTIONS} ${mysrc} ${D}${INSDESTTREE}
    done
}

donewins() {
    local mynum=${#}
    if [ ${mynum} -lt 1 ]
    then
	echo "${0}: at least one argument needed"
	return
    fi
    if [ ! -d ${D}${INSDESTTREE} ]
    then
	install -d ${D}${INSDESTTREE}
    fi
    install -D ${INSOPTIONS} ${1} ${D}${INSDESTTREE}/${2}

}

exeopts() {
    EXEOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             EXEOPTIONS="$EXEOPTIONS $x"
        fi
    done
    export EXEOPTIONS
}

libopts() {
    LIBOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             LIBOPTIONS="$LIBOPTIONS $x"
        fi
    done
    export LIBOPTIONS
}

abort_compile() {
    echo 
    echo '*** Compilation Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .compiled
    trap SIGINT SIGQUIT
    exit 1
}

abort_unpack() {
    echo 
    echo '*** Unpack Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .unpacked
    rm -rf work
    trap SIGINT SIGQUIT
    exit 1
}

abort_package() {
    echo 
    echo '*** Packaging Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .packaged
    rm -f ${PKGDIR}/All/${PF}.t*
    trap SIGINT SIGQUIT
    exit 1
}

abort_image() {
    echo 
    echo '*** Imaging Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -rf image
    trap SIGINT SIGQUIT
    exit 1
}

dyn_compile() {
    trap "abort_compile" SIGINT SIGQUIT
    export CFLAGS CXXFLAGS LIBCFLAGS LIBCXXFLAGS
    if [ ${BUILDDIR}/.compiled -nt ${WORKDIR} ]
    then
	echo ">>> It appears that ${PN} is already compiled.  skipping."
	echo ">>> (clean to force compilation)"
	trap SIGINT SIGQUIT
	return
    fi
    if [ -d ${S} ]
    then
    cd ${S}
    fi
    src_compile 
    cd ${BUILDDIR}
    touch .compiled
    trap SIGINT SIGQUIT
}

dyn_package() {
    trap "abort_package" SIGINT SIGQUIT
    local PNAME=${PF}.${PACKAGE}
    cd ${BUILDDIR}/image
    echo ">>> Creating ${PNAME} in ${PKGDIR}/All..."
    if [ "$PACKAGE" = "tbz2" ]
    then
	tar cvf ${PKGDIR}/All/${PF}.tar *
	bzip2 ${PKGDIR}/All/${PF}.tar
	mv ${PKGDIR}/All/${PF}.tar.bz2 ${PKGDIR}/All/${PNAME}	
    elif [ "$PACKAGE" = "tgz" ]
    then
 	tar czvf ${PKGDIR}/All/${PNAME} *
    else
	echo '!!! Package format '${PACKAGE}' not recognized.  Please correct /etc/make.conf'
	exit 1
    fi
    ln -sf ${PKGDIR}/All/${PNAME} ${PKGDIR}/${CATEGORY}/${PNAME}
    echo ">>> Done."
    cd ${BUILDDIR}
    touch .packaged
    trap SIGINT SIGQUIT
}

dyn_install() {
    local ROOT
    trap "abort_image" SIGINT SIGQUIT
    rm -rf ${BUILDDIR}/image
    mkdir ${BUILDDIR}/image
    if [ -d ${S} ]
    then
    cd ${S}
    fi
    echo
    echo ">>> Install ${PF} into ${D} category ${CATEGORY}"
    src_install
    prepall
    install -d -m0700 ${D}var/db/pkg/${CATEGORY}/${PF}
    cp ${EBUILD} ${D}var/db/pkg/${CATEGORY}/${PF}
    local x
	#create provides database
	for x in $PROVIDE
	do
		echo "$x" >> ${D}var/db/pkg/${CATEGORY}/${PF}/PROVIDE
	done
	for x in $DEPEND
	do 
		echo "$x" >> ${D}/var/db/pkg/${CATEGORY}/${PF}/DEPEND
	done
	for x in $RDEPEND
	do
		echo "$x" >> ${D}/var/db/pkg/${CATEGORY}/${PF}/RDEPEND
	done
	echo ">>> Completed installing into ${D}"
    echo
    cd ${BUILDDIR}
    trap SIGINT SIGQUIT
}

dyn_merge() {
    trap "" SIGINT SIGQUIT
    pkg_preinst
    #/usr/sbin/portage-merge
	dopython portage.merge "$CATEGORY" "$PF" "$D"
	cd ${BUILDDIR}
    #zap it so that people don't look at a bad image and get confused
    rm -rf image
    pkg_postinst
    trap SIGINT SIGQUIT
}

dyn_unmerge() {
    trap "" SIGINT SIGQUIT
    #/usr/sbin/portage-unmerge ${PF}
    dopython portage.unmerge "$CATEGORY" "$PF"
    trap SIGINT_SIGQUIT
}


dyn_spec() {
    tar czf /usr/src/redhat/SOURCES/${PF}.tar.gz ${O}/${PF}.ebuild ${O}/files

    cat <<__END1__ > ${PF}.spec
Summary: ${DESCRIPTION}
Name: ${PN}
Version: ${PV}
Release: ${PR}
Copyright: GPL
Group: portage/${CATEGORY}
Source: ${PF}.tar.gz
Buildroot: ${D}
%description
${DESCRIPTION}

${HOMEPAGE}

%prep
%setup -c

%build

%install

%clean

%files
/
__END1__

}
dyn_rpm () {
    dyn_spec
    rpm -bb ${PF}.spec

    install -D /usr/src/redhat/RPMS/i386/${PN}-${PV}-${PR}.i386.rpm ${RPMDIR}/${CATEGORY}/${PN}-${PV}-${PR}.rpm
}

dyn_help() {
	echo
	echo "Portage"
	echo "Copyright 2000 Gentoo Technologies, Inc."
	echo 
	echo "How to use the ebuild command:"
	echo 
	echo "The first argument to ebuild should be an existing .ebuild file."
	echo
	echo "One or more of the following options can then be specified.  If more"
	echo "than one option is specified, each will be executed in order."
	echo
	echo "  check       : test if all dependencies get resolved"
	echo "  fetch       : download source archive(s) and patches"
	echo "  unpack      : unpack/patch sources (auto-fetch if needed)"
	echo "  compile     : compile sources (auto-fetch/unpack if needed)"
	echo "  merge       : merge image into live filesystem, recording files in db"
	echo "  remerge     : forces merge even if the package is installed"
	echo "                (auto-fetch/unpack/compile if needed)"
	echo "  unmerge     : remove package from live filesystem"
	echo "  package     : create tarball package of type ${PACKAGE}"
        echo "                (will be stored in ${PKGDIR}/All)"
	echo "  clean       : clean up all source and temporary files"
	echo
	echo "The following settings will be used for the ebuild process:"
	echo
	echo "  package     : ${PF}" 
	echo "  category    : ${CATEGORY}" 
	echo "  description : ${DESCRIPTION}"
	echo "  system      : ${CHOST}" 
	echo "  c flags     : ${CFLAGS}" 
	echo "  c++ flags   : ${CXXFLAGS}" 
	echo "  make flags  : ${MAKEOPTS}" 
	echo -n "  build mode  : "
	if [ -n "${DEBUG}" ]
	then
	    echo "debug (large)"
	else
	    echo "production (stripped)"
	fi
	echo "  merge to    : ${ROOT}" 
	echo "  db location : ${ROOT}var/db/pkg/${CATEGORY}/${P}/CONTENTS"
	echo 
	if [ -n "$USE" ]
	then
	    echo "Additionally, support for the following toolkits will be enabled if necessary:"
	    echo 
	    echo "  ${USE}"
	fi    
	echo
}

src_menu() {
    MYDIR=${BUILDDIR}
    local MYfoo
    for MYfoo in "$@" 
    do
	case "${MYfoo}" in
	noop)
	    ;;
	unpack)
	    dyn_fetch
	    dyn_unpack
	    ;;
	compile)
		build_depend
		dyn_fetch
		dyn_unpack
	    dyn_compile
		;;
	prerm|postrm|preinst|postinst|config)
	    pkg_${MYfoo}
	    ;;
	help|batchdigest|touch|clean|fetch|digest|pkginfo|pkgloc|unmerge|install)
	    dyn_${MYfoo}
	    ;;
	check)
	    # Exit with 1 if there are unresolved dependencies
	    build_depend
	    ;;
	package)
		build_depend
		dyn_fetch
		local PNAME=${PF}.${PACKAGE}
		if [ ! -d ${PKGDIR} ]
		then
			install -d ${PKGDIR}
		fi
		if [ ! -d ${PKGDIR}/All ]
		then
			install -d ${PKGDIR}/All
		fi	
		if [ ! -d ${PKGDIR}/${CATEGORY} ]
		then
			install -d ${PKGDIR}/${CATEGORY}
		fi
    		if [ -e ${PKGDIR}/All/${PNAME} ]
	    	then
			if [ ! -d ${PKGDIR}/${CATEGORY}/${PNAME} ]
			then
				ln -sf ${PKGDIR}/All/${PNAME} ${PKGDIR}/${CATEGORY}/${PNAME}
			fi
	    		local x
    			local dopackage
    			dopackage="no"
	    		for x in ${A} ${EBUILD}
    			do
				if [ ${x} -nt ${PKGDIR}/All/${PNAME} ]
				then
					dopackage="yes"
					break
				fi
	    		done
			if [ "$dopackage" = "no" ]
			then
				echo
				echo ">>> Package ${PNAME} appears to be up-to-date."
				echo ">>> To force rebuild, touch ${EBUILD}."
				echo
				continue
			fi
    		fi
		dyn_unpack
		dyn_compile
		dyn_install
		dyn_package
		;;

	remerge)
		#this is meant to merge over an existing version even if it exists
		build_depend
		dyn_fetch
		dyn_unpack
		dyn_compile
		dyn_install
		dyn_merge
		runtime_depend
		;;
	qmerge)
		#this means to run only dyn_merge
		dyn_merge
		;;
 	merge)
		#merge makes sure the package isn't already merged first
		merge_check
	    build_depend
		dyn_fetch
		dyn_unpack
	    dyn_compile
   		dyn_install
		dyn_merge
		runtime_depend
	    ;;
	gendeps)
		#create DEPEND and RDEPEND files in the same directory as the .ebuild file
		#this is used for the auto dependency resolving features of ebuild
		gen_depend
		;;
	rpm)
		build_depend
		dyn_fetch
	    dyn_unpack
		dyn_compile
		dyn_install	
		dyn_rpm
	    ;;
	*)
	    echo "Please specify a valid command."
		echo
		dyn_help
	esac
    done
    cd $MYDIR
}

#dummy value for help printouts
P=packagename

if [ $# -lt 1 ]
then
	echo
	echo '!!!' "At least two arguments expected."
	dyn_help
	exit 1
fi

if [ ! -e ${1} ]
then
	echo
	echo '!!!' "${1} not found."
	dyn_help
	exit 1
fi

# this function sets various environment variables that are used by 
# portage.  For a package called "foo-1.2-r1", they would be set as
# follows:
# P=foo-1.2
# PF=foo-1.2-r1 (r1 is the rev, or release of the ebuild script)
# PN=foo
# PV=1.2
# PR=1 (rev is zero if unspecified)

setp() {
	if [ $# -ne 3 ]
	then
		echo '!!!' ${P} is not a valid package name.  Exiting.
		exit 1
	fi
	if [ "${3}" = "0" ]
	then
		export PF="${1}-${2}"
	else
		export PF="${1}-${2}-r${3}"
	fi
	export P="${1}-${2}"
	export PN="${1}"
	export PV="${2}"
	export PR="${3}"
}

export STARTDIR=`pwd`

if [ "${1:0:1}" = "/" ]
then
	export O=`dirname ${1}`
else
	tmpfoo=`dirname ${1}`
	export O=`( cd ${tmpfoo}; pwd )`
fi
tmpfoo=`(cd ${O}/..;pwd)`
export CATEGORY=`/usr/bin/basename $tmpfoo`
export EBUILD=${O}/`basename ${1}`
export PEBUILD=${O}/files/${PLATFORM}.ebuild
export FILESDIR=${O}/files

tmpfoo=`/usr/bin/basename ${1%.*}`
setp `/usr/sbin/pkgname ${tmpfoo}`

#if [ $# -le 3 ]
#then
#	dyn_help
#	exit 1
#fi

#source ${1}
#if [ -e ${PEBUILD} ]
#then
#	source ${PEBUILD}
#fi

if [ ! -z ${BUILD_PREFIX} ]
then
    export BUILDDIR=${BUILD_PREFIX}/${PF}
else
    export BUILDDIR=${O}
fi
if [ ! -d ${BUILDDIR} ]
then
   install -d ${BUILDDIR}
fi

export T=${BUILDDIR}/temp
if [ ! -d ${T} ]
then
   install -d ${T}
fi
export WORKDIR=${BUILDDIR}/work
export D=${BUILDDIR}/image
dlen=$(( ${#D} -1 ))
if [ "${D:${dlen}:1}" != "/" ]
then
    export D=${D}/
fi

source ${1}
if [ -e ${PEBUILD} ]
then
	source ${PEBUILD}
fi

#set up dependency variables correctly...
if [ "$RDEPEND" = "" ]
then
	RDEPEND="$DEPEND"
fi

#auto-generate ${A} based on ${SRC_URI} if ${A} isn't defined...
if [ "${A}" = "" ]
then
	export SRC_URI
	eval `dopython portage.gen_archnames`
fi

foo=2
while [ $foo -le $# ]
do
eval "src_menu \${${foo}}"
if [ $? -ne 0 ]
then
        echo "***error***"
        exit 1
fi
foo=$(( $foo + 1))
done


