#!/bin/sh
# Copyright (c) 1995-1998 SuSE GmbH Nuernberg, Germany.
#
# Author: Vojtech Bubnik <bubnikv@suse.cz>
# Based on script from: Jeff Rush <jrush@taupro.com>
# modified for gentoo linux by Holger Brueckner <darks@gentoo.org>
#RCUPDATE:3 4:99

.  /etc/rc.d/config/functions

USEZEO="`/usr/lib/portage/bin/use zeo`"

SERVICE=zope
opts="start stop restart status"

export INSTANCE_HOME=/var/lib/zope
export INSTANCE_NAME=`basename ${INSTANCE_HOME}`
export ZOPE_HOME=/usr/share/zope
export ZOPE_PORT=80
export ZOPE_LOG="/var/log/zope"
export ZEO_SERVER_PORT=5800
export ZEO_SERVER_NAME="localhost"

ZOPE_PCGI="no"

# Logging to a remote server using syslogd can
# be done by using ZSYSLOG_SERVER instead if ZYSLOG.  If you do not define
# either of the ZSYSLOG* env vars, logging goes to the file specified by
# the -l <file> command argument instead.

# Note: For syslog logging to work from the ZServer/medusa subsystem, the
# ZSYSLOG variable must now contain the name of the socket to log to,
# usually /dev/log on Unix machines.

#export ZSYSLOG="/dev/log"
#export ZSYSLOG_SERVER="localhost:514"

start_zope() {
	
 	cd ${INSTANCE_HOME}
	if [ $ZOPE_PCGI = "yes" ] ; then
	    /usr/bin/env python z2.py           \
        	-p      $INSTANCE_HOME/Zope.cgi \
        	-u      nobody                  \
        	-z      $ZOPE_HOME              \
        	-Z      /var/run/zwatchdog.pid  \
        	-w      ''			\
        	-f      8021                    \
        	-m      ''                      \
        	-l      $ZOPE_LOG               \
        	2>&1 >> /var/log/zope           \
            &
	else 
	    if [ $USEZEO ]; then
	        export PYTHONPATH=/usr/lib/python2.1/:/usr/lib/python2.1/lib-dynload/
	        /usr/bin/env python zctl.py start_zeo
		unset PYTHONPATH
		/usr/bin/env python z2.py          \
        	    -u      nobody                  \
                    -p	    -			    \
            	    -z      $ZOPE_HOME              \
        	    -Z      /var/run/zwatchdog.pid  \
        	    -w      $ZOPE_PORT              \
        	    -f      8021                    \
		    -W	    8023		    \
        	    -m      ''                      \
        	    -l      $ZOPE_LOG               \
		    -D				    \
        	    2>&1 >> /var/log/zope           \
                &   
	    else
	         /usr/bin/env python z2.py          \
        	    -u      nobody                  \
                    -p      -			    \
            	    -z      $ZOPE_HOME              \
        	    -Z      /var/run/zwatchdog.pid  \
        	    -w      $ZOPE_PORT              \
        	    -f      8021                    \
		    -W	    8023		    \
        	    -m      ''                      \
        	    -l      $ZOPE_LOG               \
		    -D				    \
        	    2>&1 >> /var/log/zope           \
                &
	    fi
	 fi
	
}

# A function to find the pid of a program. We cannot use checkproc, 
# because we are handling scripts.
pidofproc() {
	# First try the "$INSTANCE_HOME/var/Z2.pid" file
	if [ -f ${INSTANCE_HOME}/var/Z2.pid ] ; then
	        if [ "$1" = "zwatchdog" ] ; then
	                pid=`sed -e 's/^\([0-9]\+\) [0-9]\+/\1/' ${INSTANCE_HOME}/var/Z2.pid`
		else
		        if [ "$1" = "zserver" ] ; then
		                pid=`sed -e 's/^[0-9]\+ \([0-9]\+\)/\1/' ${INSTANCE_HOME}/var/Z2.pid`
			fi
	        fi

		if [ "$pid" != "" ] ; then
			echo $pid
			return 0
		fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -n1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo $pid
	                return 0
	        fi
	fi

	# Next try "pidof"
	pid=`pidof -o $$ -o $PPID -o %PPID -x $1`
	if [ "$pid" != "" ] ; then
	        echo $pid
	        return 0
	fi
}

# Extracted from 'functions' to fix a tiny bug where it uses 'pidof'
# but should be using 'pidofproc'.
chkstatus() {
	# First try "pidofproc"
	pid=`pidofproc $1`
	if [ "$pid" != "" ] && ps h $pid >/dev/null 2>&1 ; then
	        echo "$1 (pid $pid) is running..."
	        return 0
        else
		pid=`pidof -o $$ -o $PPID -o %PPID -x $1`
		if [ "$pid" != "" ] ; then
		        echo "$1 (pid $pid) is running..."
		        return 0
		fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo "$1 dead but pid file exists"
	                return 1
	        fi
	fi

	# See if /var/lock/subsys/$1 exists
	if [ -f /var/lock/subsys/$1 ]; then
		echo "$1 dead but subsys locked"
		return 2
	fi
	echo "$1 is stopped"
	return 3
}

start() {
	ebegin "Starting zope"
	# See if it's already running.
	zw_pid=`pidofproc zwatchdog`
	zs_pid=`pidofproc zserver`
	if ( [ -z "$zw_pid" ] || ! ps h $zw_pid >/dev/null 2>&1 ) && \
	   ( [ -z "$zs_pid" ] || ! ps h $zs_pid >/dev/null 2>&1 ) ; then 
		rm -f ${INSTANCE_HOME}/var/Z2.pid
		start_zope
		ret=$? 
	fi
	eend $ret "Error starting $SERVICE"
  	}
stop(){
	ebegin "Shutting down zope"	
	pid=`pidofproc zwatchdog`
	[ -n "$pid" ] && (kill $pid 2>&1 >/dev/null)
	pid=`pidofproc zserver`
   	[ -n "$pid" ] && (kill $pid 2>&1 >/dev/null)
	rm -f ${INSTANCE_HOME}/var/Z2.pid /var/run/zwatchdog.pid
	if [ $USEZEO ]; then
	    /usr/bin/env python ${INSTANCE_HOME}/zctl.py stop_zeo
	fi
	eend $? "Error stopping $SERVICE"
       }
       
restart(){
         stop  
	 start  
	}
	
status(){
	echo "Checking for zope: "
	chkstatus zwatchdog
	chkstatus zserver
	if [ $USEZEO ]; then
	    /usr/bin/env python ${INSTANCE_HOME}/zctl.py status
	fi
        }

doservice ${@}
