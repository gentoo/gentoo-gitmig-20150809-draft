diff -Nru gaim-0.58/src/away.c gaim-0.58-t/src/away.c
--- gaim-0.58/src/away.c	Sat Feb 23 17:50:43 2002
+++ gaim-0.58-t/src/away.c	Wed Jun 12 20:09:47 2002
@@ -217,11 +217,20 @@
 		gtk_widget_show(sw);
 
 		awaytext = gtk_imhtml_new(NULL, NULL);
+
+		if ((trans_options & OPT_TRANS_AWAY) == OPT_TRANS_AWAY)
+			gtk_imhtml_set_background(GTK_IMHTML(awaytext), NULL, 1, 1);
+
 		gtk_container_add(GTK_CONTAINER(sw), awaytext);
+
 		GTK_LAYOUT(awaytext)->hadjustment->step_increment = 10.0;
 		GTK_LAYOUT(awaytext)->vadjustment->step_increment = 10.0;
 		gaim_setup_imhtml(awaytext);
 		gtk_widget_show(awaytext);
+
+		gtk_signal_connect_object(GTK_OBJECT(imaway), "configure_event",
+						GTK_SIGNAL_FUNC(win_move), GTK_OBJECT(awaytext));
+
 		buf = stylize(a->message, BUF_LONG);
 		gtk_imhtml_append_text(GTK_IMHTML(awaytext), buf, -1, GTK_IMHTML_NO_TITLE |
 				       GTK_IMHTML_NO_COMMENTS | GTK_IMHTML_NO_SCROLL);
diff -Nru gaim-0.58/src/buddy_chat.c gaim-0.58-t/src/buddy_chat.c
--- gaim-0.58/src/buddy_chat.c	Mon May  6 15:32:59 2002
+++ gaim-0.58-t/src/buddy_chat.c	Wed Jun 12 20:09:47 2002
@@ -1236,6 +1236,17 @@
 	gtk_widget_show(sw);
 
 	text = gtk_imhtml_new(NULL, NULL);
+
+	if ((trans_options & OPT_TRANS_CHAT) == OPT_TRANS_CHAT)
+		gtk_imhtml_set_background(GTK_IMHTML(text), NULL, 1, 1);
+
+	gtk_signal_connect_object(GTK_OBJECT(win), "configure_event",
+							  GTK_SIGNAL_FUNC(win_move), GTK_OBJECT(text));
+#if 0
+	gtk_signal_connect(GTK_OBJECT(win), "configure_event",
+			   GTK_SIGNAL_FUNC(win_move), text);
+#endif
+
 	b->text = text;
 	gtk_container_add(GTK_CONTAINER(sw), text);
 	GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
@@ -1334,17 +1345,23 @@
 	gtk_box_pack_end(GTK_BOX(bbox), send, dispstyle, dispstyle, 0);
 
 	b->font_dialog = NULL;
-	b->fg_color_dialog = NULL;
-	b->bg_color_dialog = NULL;
+	b->out_fg_color_dialog = NULL;
+	b->out_bg_color_dialog = NULL;
+	b->def_fg_color_dialog = NULL;
+	b->def_bg_color_dialog = NULL;
 	b->smiley_dialog = NULL;
 	b->link_dialog = NULL;
 	b->log_dialog = NULL;
 	sprintf(b->fontface, "%s", fontface);
 	b->hasfont = 0;
-	b->bgcol = bgcolor;
-	b->hasbg = 0;
-	b->fgcol = fgcolor;
-	b->hasfg = 0;
+	b->out_bgcol = out_bgcolor;
+	b->has_out_bg = 0;
+	b->out_fgcol = out_fgcolor;
+	b->has_out_fg = 0;
+	b->def_bgcol = def_bgcolor;
+	b->has_def_bg = 0;
+	b->def_fgcol = def_fgcolor;
+	b->has_def_fg = 0;
 
 	update_buttons_by_protocol(b);
 
diff -Nru gaim-0.58/src/buddy_chat.c~ gaim-0.58-t/src/buddy_chat.c~
--- gaim-0.58/src/buddy_chat.c~	Wed Dec 31 19:00:00 1969
+++ gaim-0.58-t/src/buddy_chat.c~	Mon May  6 15:32:59 2002
@@ -0,0 +1,1562 @@
+/*
+ * gaim
+ *
+ * Copyright (C) 1998-1999, Mark Spencer <markster@marko.net>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <string.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <gtk/gtk.h>
+#include "gtkimhtml.h"
+#include "gtkspell.h"
+#include <gdk/gdkkeysyms.h>
+
+#include "convo.h"
+#include "prpl.h"
+
+#include "pixmaps/tb_forward.xpm"
+#include "pixmaps/join.xpm"
+#include "pixmaps/close.xpm"
+
+GtkWidget *joinchat;
+static struct gaim_connection *joinchatgc;
+static GtkWidget *invite;
+static GtkWidget *inviteentry;
+static GtkWidget *invitemess;
+static GtkWidget *jc_vbox = NULL;
+static GList *chatentries = NULL;
+extern int state_lock;
+
+GList *chats = NULL;
+GtkWidget *all_chats = NULL;
+GtkWidget *chat_notebook = NULL;
+
+static char *ignored(struct conversation *b, char *who)
+{
+	GList *ignore = b->ignored;
+	while (ignore) {
+		char *ign = ignore->data;
+		if (!g_strcasecmp(who, ign))
+			return ign;
+		if (*ign == '+' && !g_strcasecmp(who, ign + 1))
+			return ign;
+		if (*ign == '@') {
+			ign++;
+			if (*ign == '+' && !g_strcasecmp(who, ign + 1))
+				return ign;
+			if (*ign != '+' && !g_strcasecmp(who, ign))
+				return ign;
+		}
+		ignore = ignore->next;
+	}
+	return NULL;
+}
+
+
+static void destroy_join_chat()
+{
+	if (joinchat)
+		gtk_widget_destroy(joinchat);
+	joinchat = NULL;
+}
+
+static void destroy_invite()
+{
+	if (invite)
+		gtk_widget_destroy(invite);
+	invite = NULL;
+}
+
+
+void do_join_chat()
+{
+	if (joinchat) {
+		GList *data = NULL;
+		GList *tmp = chatentries;
+		int *ival;
+		char *sval;
+		while (tmp) {
+			if (gtk_object_get_user_data(tmp->data)) {
+				ival = g_new0(int, 1);
+				*ival = gtk_spin_button_get_value_as_int(tmp->data);
+				data = g_list_append(data, ival);
+			} else {
+				sval = g_strdup(gtk_entry_get_text(tmp->data));
+				data = g_list_append(data, sval);
+			}
+			tmp = tmp->next;
+		}
+		serv_join_chat(joinchatgc, data);
+
+		tmp = data;
+		while (tmp) {
+			g_free(tmp->data);
+			tmp = tmp->next;
+		}
+		g_list_free(data);
+
+		gtk_widget_destroy(joinchat);
+		if (chatentries)
+			g_list_free(chatentries);
+		chatentries = NULL;
+	}
+	joinchat = NULL;
+}
+
+static void rebuild_jc()
+{
+	GList *list, *tmp;
+	struct proto_chat_entry *pce;
+	gboolean focus = TRUE;
+
+	if (!joinchatgc)
+		return;
+
+	while (GTK_BOX(jc_vbox)->children)
+		gtk_container_remove(GTK_CONTAINER(jc_vbox),
+				     ((GtkBoxChild *)GTK_BOX(jc_vbox)->children->data)->widget);
+	if (chatentries)
+		g_list_free(chatentries);
+	chatentries = NULL;
+
+	tmp = list = joinchatgc->prpl->chat_info(joinchatgc);
+	while (list) {
+		GtkWidget *label;
+		GtkWidget *rowbox;
+		pce = list->data;
+
+		rowbox = gtk_hbox_new(FALSE, 5);
+		gtk_box_pack_start(GTK_BOX(jc_vbox), rowbox, TRUE, TRUE, 0);
+		gtk_widget_show(rowbox);
+
+		label = gtk_label_new(pce->label);
+		gtk_box_pack_start(GTK_BOX(rowbox), label, FALSE, FALSE, 0);
+		gtk_widget_show(label);
+
+		if (pce->is_int) {
+			GtkObject *adjust;
+			GtkWidget *spin;
+			adjust = gtk_adjustment_new(pce->min, pce->min, pce->max, 1, 10, 10);
+			spin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);
+			gtk_object_set_user_data(GTK_OBJECT(spin), (void *)1);
+			chatentries = g_list_append(chatentries, spin);
+			gtk_widget_set_usize(spin, 50, -1);
+			gtk_box_pack_end(GTK_BOX(rowbox), spin, FALSE, FALSE, 0);
+			gtk_widget_show(spin);
+		} else {
+			GtkWidget *entry;
+			entry = gtk_entry_new();
+			chatentries = g_list_append(chatentries, entry);
+			gtk_box_pack_end(GTK_BOX(rowbox), entry, FALSE, FALSE, 0);
+			if (pce->def)
+				gtk_entry_set_text(GTK_ENTRY(entry), pce->def);
+			if (focus) {
+				gtk_widget_grab_focus(entry);
+				focus = FALSE;
+			}
+			gtk_signal_connect(GTK_OBJECT(entry), "activate",
+					   GTK_SIGNAL_FUNC(do_join_chat), NULL);
+			gtk_widget_show(entry);
+		}
+
+		g_free(pce);
+		list = list->next;
+	}
+	g_list_free(tmp);
+}
+
+static void joinchat_choose(GtkWidget *w, struct gaim_connection *g)
+{
+	if (joinchatgc == g)
+		return;
+	joinchatgc = g;
+	rebuild_jc();
+}
+
+static void create_joinchat_menu(GtkWidget *box)
+{
+	GtkWidget *optmenu;
+	GtkWidget *menu;
+	GtkWidget *opt;
+	GSList *c = connections;
+	struct gaim_connection *g;
+	char buf[2048];
+
+	optmenu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(box), optmenu, FALSE, FALSE, 0);
+
+	menu = gtk_menu_new();
+	joinchatgc = NULL;
+
+	while (c) {
+		g = (struct gaim_connection *)c->data;
+		c = c->next;
+		if (!g->prpl->join_chat)
+			continue;
+		if (!joinchatgc)
+			joinchatgc = g;
+		g_snprintf(buf, sizeof buf, "%s (%s)", g->username, g->prpl->name());
+		opt = gtk_menu_item_new_with_label(buf);
+		gtk_object_set_user_data(GTK_OBJECT(opt), g);
+		gtk_signal_connect(GTK_OBJECT(opt), "activate", GTK_SIGNAL_FUNC(joinchat_choose), g);
+		gtk_menu_append(GTK_MENU(menu), opt);
+		gtk_widget_show(opt);
+	}
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(optmenu), menu);
+	gtk_option_menu_set_history(GTK_OPTION_MENU(optmenu), 0);
+}
+
+void join_chat()
+{
+	GtkWidget *mainbox;
+	GtkWidget *frame;
+	GtkWidget *fbox;
+	GtkWidget *rowbox;
+	GtkWidget *bbox;
+	GtkWidget *join;
+	GtkWidget *cancel;
+	GtkWidget *label;
+	GSList *c = connections;
+	struct gaim_connection *gc = NULL;
+
+	while (c) {
+		gc = c->data;
+		if (gc->prpl->join_chat)
+			break;
+		gc = NULL;
+		c = c->next;
+	}
+	if (gc == NULL) {
+		do_error_dialog("You are not currently signed on with any protocols that have "
+				"the ability to chat.", "Unable to chat");
+		return;
+	}
+
+	if (!joinchat) {
+		GAIM_DIALOG(joinchat);
+		gtk_window_set_wmclass(GTK_WINDOW(joinchat), "joinchat", "Gaim");
+		gtk_window_set_policy(GTK_WINDOW(joinchat), FALSE, TRUE, TRUE);
+		gtk_widget_realize(joinchat);
+		gtk_signal_connect(GTK_OBJECT(joinchat), "delete_event",
+				   GTK_SIGNAL_FUNC(destroy_join_chat), joinchat);
+		gtk_window_set_title(GTK_WINDOW(joinchat), _("Join Chat"));
+		aol_icon(joinchat->window);
+
+		mainbox = gtk_vbox_new(FALSE, 5);
+		gtk_container_set_border_width(GTK_CONTAINER(mainbox), 5);
+		gtk_container_add(GTK_CONTAINER(joinchat), mainbox);
+
+		frame = gtk_frame_new(_("Buddy Chat"));
+		gtk_box_pack_start(GTK_BOX(mainbox), frame, TRUE, TRUE, 0);
+
+		fbox = gtk_vbox_new(FALSE, 5);
+		gtk_container_set_border_width(GTK_CONTAINER(fbox), 5);
+		gtk_container_add(GTK_CONTAINER(frame), fbox);
+
+#ifndef NO_MULTI
+		rowbox = gtk_hbox_new(FALSE, 5);
+		gtk_box_pack_start(GTK_BOX(fbox), rowbox, TRUE, TRUE, 0);
+
+		label = gtk_label_new(_("Join Chat As:"));
+		gtk_box_pack_start(GTK_BOX(rowbox), label, FALSE, FALSE, 0);
+
+		create_joinchat_menu(rowbox);
+
+		{
+			GtkWidget *tmp = fbox;
+			fbox = gtk_vbox_new(FALSE, 5);
+			gtk_container_add(GTK_CONTAINER(tmp), fbox);
+			gtk_container_set_border_width(GTK_CONTAINER(fbox), 0);
+			jc_vbox = fbox;
+		}
+#else
+		joinchatgc = connections->data;
+#endif
+		rebuild_jc();
+		/* buttons */
+
+		bbox = gtk_hbox_new(FALSE, 5);
+		gtk_box_pack_start(GTK_BOX(mainbox), bbox, FALSE, FALSE, 0);
+
+		cancel = picture_button(joinchat, _("Cancel"), cancel_xpm);
+		gtk_box_pack_end(GTK_BOX(bbox), cancel, FALSE, FALSE, 0);
+		gtk_signal_connect(GTK_OBJECT(cancel), "clicked",
+				   GTK_SIGNAL_FUNC(destroy_join_chat), joinchat);
+
+		join = picture_button(joinchat, _("Join"), join_xpm);
+		gtk_box_pack_end(GTK_BOX(bbox), join, FALSE, FALSE, 0);
+		gtk_signal_connect(GTK_OBJECT(join), "clicked", GTK_SIGNAL_FUNC(do_join_chat), NULL);
+	}
+	gtk_widget_show_all(joinchat);
+}
+
+
+static void do_invite(GtkWidget *w, struct conversation *b)
+{
+	char *buddy;
+	char *mess;
+
+	if (!b->is_chat) {
+		debug_printf("do_invite: expecting chat, got IM\n");
+		return;
+	}
+
+	buddy = gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(inviteentry)->entry));
+	mess = gtk_entry_get_text(GTK_ENTRY(invitemess));
+
+	if (invite) {
+		serv_chat_invite(b->gc, b->id, mess, buddy);
+		gtk_widget_destroy(invite);
+	}
+	invite = NULL;
+}
+
+
+GList *generate_invite_user_names(struct gaim_connection *gc)
+{
+	GSList *grp;
+	GSList *bl;
+	struct group *g;
+	struct buddy *buddy;
+
+	static GList *tmp = NULL;
+
+	if (tmp)
+		g_list_free(tmp);
+	tmp = NULL;
+
+	tmp = g_list_append(tmp, "");
+
+	if (gc) {
+		grp = gc->groups;
+
+		while (grp) {
+			g = (struct group *)grp->data;
+
+			bl = g->members;
+
+			while (bl) {
+				buddy = (struct buddy *)bl->data;
+
+				if (buddy->present)
+					tmp = g_list_append(tmp, buddy->name);
+
+				bl = g_slist_next(bl);
+			}
+
+			grp = g_slist_next(grp);
+		}
+	}
+
+	return tmp;
+
+}
+
+void invite_callback(GtkWidget *w, struct conversation *b)
+{
+	GtkWidget *cancel;
+	GtkWidget *invite_btn;
+	GtkWidget *label;
+	GtkWidget *bbox;
+	GtkWidget *vbox;
+	GtkWidget *table;
+	GtkWidget *frame;
+
+	if (!invite) {
+		GAIM_DIALOG(invite);
+		gtk_widget_realize(invite);
+
+		cancel = picture_button(invite, _("Cancel"), cancel_xpm);
+		invite_btn = picture_button(invite, _("Invite"), join_xpm);
+		inviteentry = gtk_combo_new();
+		invitemess = gtk_entry_new();
+		frame = gtk_frame_new(_("Invite"));
+		table = gtk_table_new(2, 2, FALSE);
+
+		gtk_table_set_row_spacings(GTK_TABLE(table), 5);
+		gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+		gtk_container_set_border_width(GTK_CONTAINER(table), 5);
+
+		gtk_container_set_border_width(GTK_CONTAINER(frame), 5);
+
+		/* Now we should fill out all of the names */
+		gtk_combo_set_popdown_strings(GTK_COMBO(inviteentry), generate_invite_user_names(b->gc));
+
+		vbox = gtk_vbox_new(FALSE, 0);
+		gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);
+		gtk_container_add(GTK_CONTAINER(frame), table);
+
+		label = gtk_label_new(_("Buddy"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1, 0.5);
+		gtk_widget_show(label);
+		gtk_table_attach(GTK_TABLE(table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+
+		label = gtk_label_new(_("Message"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1, 0.5);
+		gtk_widget_show(label);
+		gtk_table_attach(GTK_TABLE(table), label, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
+
+		/* Now the right side of the table */
+		gtk_table_attach(GTK_TABLE(table), inviteentry, 1, 2, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0,
+				 0);
+		gtk_table_attach(GTK_TABLE(table), invitemess, 1, 2, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0,
+				 0);
+
+		/* And now for the button box */
+		bbox = gtk_hbox_new(FALSE, 10);
+		gtk_box_pack_start(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);
+
+		gtk_box_pack_end(GTK_BOX(bbox), cancel, FALSE, FALSE, 0);
+		gtk_box_pack_end(GTK_BOX(bbox), invite_btn, FALSE, FALSE, 0);
+
+		/* Handle closes right */
+		gtk_signal_connect(GTK_OBJECT(invite), "delete_event",
+				   GTK_SIGNAL_FUNC(destroy_invite), invite);
+
+		gtk_signal_connect(GTK_OBJECT(cancel), "clicked", GTK_SIGNAL_FUNC(destroy_invite), b);
+		gtk_signal_connect(GTK_OBJECT(invite_btn), "clicked", GTK_SIGNAL_FUNC(do_invite), b);
+		gtk_signal_connect(GTK_OBJECT(GTK_ENTRY(GTK_COMBO(inviteentry)->entry)), "activate",
+				   GTK_SIGNAL_FUNC(do_invite), b);
+
+		/* Finish up */
+		gtk_widget_set_usize(GTK_WIDGET(invite), 550, 115);
+		gtk_widget_show(invite_btn);
+		gtk_widget_show(cancel);
+		gtk_widget_show(inviteentry);
+		gtk_widget_show(invitemess);
+		gtk_widget_show(vbox);
+		gtk_widget_show(bbox);
+		gtk_widget_show(table);
+		gtk_widget_show(frame);
+		gtk_window_set_title(GTK_WINDOW(invite), _("Gaim - Invite Buddy Into Chat Room"));
+		gtk_window_set_focus(GTK_WINDOW(invite), GTK_WIDGET(GTK_COMBO(inviteentry)->entry));
+		gtk_container_add(GTK_CONTAINER(invite), vbox);
+
+		aol_icon(invite->window);
+
+	}
+	gtk_widget_show(invite);
+}
+
+void tab_complete(struct conversation *c)
+{
+	int pos = GTK_OLD_EDITABLE(c->entry)->current_pos;
+	int start = pos;
+	int most_matched = -1;
+	char *entered, *partial = NULL;
+	char *text;
+	GList *matches = NULL;
+	GList *nicks = c->in_room;
+
+	/* if there's nothing there just return */
+	if (!start)
+		return;
+	
+	text = gtk_editable_get_chars(GTK_EDITABLE(c->entry), 0, pos);
+
+	/* if we're at the end of ": " we need to move back 2 spaces */
+	if (start >= 2 && text[start - 1] == ' ' && text[start - 2] == ':')
+		start -= 2;
+	
+	/* find the start of the word that we're tabbing */
+	while (start > 0 && text[start - 1] != ' ')
+		start--;
+
+	entered = text + start;
+	if (chat_options & OPT_CHAT_OLD_STYLE_TAB) {
+		if (strlen(entered) >= 2 && !strncmp(": ", entered + strlen(entered) - 2, 2))
+			entered[strlen(entered) - 2] = 0;
+	}
+		
+	if (!strlen(entered)) {
+		g_free(text);
+		return;
+	}
+
+	debug_printf("checking tab-completion for %s\n", entered);
+
+	while (nicks) {
+		char *nick = nicks->data;
+		/* this checks to see if the current nick could be a completion */
+		if (g_strncasecmp(nick, entered, strlen(entered))) {
+			if (nick[0] != '+' && nick[0] != '@') {
+				nicks = nicks->next;
+				continue;
+			}
+			if (g_strncasecmp(nick + 1, entered, strlen(entered))) {
+				if (nick[0] != '@' || nick[1] != '+') {
+					nicks = nicks->next;
+					continue;
+				}
+				if (g_strncasecmp(nick + 2, entered, strlen(entered))) {
+					nicks = nicks->next;
+					continue;
+				}
+				else
+					nick += 2;
+			} else
+				nick++;
+		}
+		/* if we're here, it's a possible completion */
+		debug_printf("possible completion: %s\n", nick);
+
+		/* if we're doing old-style, just fill in the completion */
+		if (chat_options & OPT_CHAT_OLD_STYLE_TAB) {
+		        gtk_editable_delete_text(GTK_EDITABLE(c->entry), start, pos);
+			if (strlen(nick) == strlen(entered)) {
+				nicks = nicks->next ? nicks->next : c->in_room;
+				nick = nicks->data;
+				if (*nick == '@')
+					nick++;
+				if (*nick == '+')
+					nick++;
+			}
+
+			if (start == 0) {
+				char *tmp = g_strdup_printf("%s: ", nick);
+				int t = start;
+				gtk_editable_insert_text(GTK_EDITABLE(c->entry), tmp, strlen(tmp), &start);
+				if (t == start) {
+					t = start + strlen(tmp);
+					gtk_editable_set_position(GTK_EDITABLE(c->entry), t);
+				}
+				g_free(tmp);
+			} else {
+				int t = start;
+				gtk_editable_insert_text(GTK_EDITABLE(c->entry), nick, strlen(nick), &start);
+				if (t == start) {
+					t = start + strlen(nick);
+					gtk_editable_set_position(GTK_EDITABLE(c->entry), t);
+				}
+			}
+			g_free(text);
+			return;
+		}
+
+		/* we're only here if we're doing new style */
+		if (most_matched == -1) {
+			/* this will only get called once, since from now on most_matched is >= 0 */
+			most_matched = strlen(nick);
+			partial = g_strdup(nick);
+		} else if (most_matched) {
+			while (g_strncasecmp(nick, partial, most_matched))
+				most_matched--;
+			partial[most_matched] = 0;
+		}
+		matches = g_list_append(matches, nick);
+
+		nicks = nicks->next;
+	}
+	/* we're only here if we're doing new style */
+	
+	/* if there weren't any matches, return */
+	if (!matches) {
+		/* if matches isn't set partials won't be either */
+		g_free(text);
+		return;
+	}
+	
+	gtk_editable_delete_text(GTK_EDITABLE(c->entry), start, pos);
+	if (!matches->next) {
+		/* there was only one match. fill it in. */
+		if (start == 0) {
+			char *tmp = g_strdup_printf("%s: ", (char *)matches->data);
+			int t = start;
+			gtk_editable_insert_text(GTK_EDITABLE(c->entry), tmp, strlen(tmp), &start);
+			if (t == start) {
+				t = start + strlen(tmp);
+				gtk_editable_set_position(GTK_EDITABLE(c->entry), t);
+			}
+			g_free(tmp);
+		} else {
+			gtk_editable_insert_text(GTK_EDITABLE(c->entry), matches->data, strlen(matches->data), &start);
+		}
+		matches = g_list_remove(matches, matches->data);
+	} else {
+		/* there were lots of matches, fill in as much as possible and display all of them */
+		char *addthis = g_malloc0(1);
+		int t = start;
+		while (matches) {
+			char *tmp = addthis;
+			addthis = g_strconcat(tmp, matches->data, " ", NULL);
+			g_free(tmp);
+			matches = g_list_remove(matches, matches->data);
+		}
+		write_to_conv(c, addthis, WFLAG_NOLOG, NULL, time(NULL), -1);
+		gtk_editable_insert_text(GTK_EDITABLE(c->entry), partial, strlen(partial), &start);
+		if (t == start) {
+			t = start + strlen(partial);
+			gtk_editable_set_position(GTK_EDITABLE(c->entry), t);
+		}
+		g_free(addthis);
+	}
+	
+	g_free(text);
+	g_free(partial);
+}
+
+gboolean meify(char *message, int len)
+{
+	/* read /me-ify : if the message (post-HTML) starts with /me, remove
+	 * the "/me " part of it (including that space) and return TRUE */
+	char *c = message;
+	int inside_HTML = 0;	/* i really don't like descriptive names */
+	if (!c)
+		return FALSE;	/* um... this would be very bad if this happens */
+	if (len == -1)
+		len = strlen(message);
+	while (*c) {
+		if (inside_HTML) {
+			if (*c == '>')
+				inside_HTML = 0;
+		} else {
+			if (*c == '<')
+				inside_HTML = 1;
+			else
+				break;
+		}
+		c++;		/* i really don't like c++ either */
+		len--;
+	}
+	/* k, so now we've gotten past all the HTML crap. */
+	if (!*c)
+		return FALSE;
+	if (!g_strncasecmp(c, "/me ", 4)) {
+		memmove(c, c + 4, len - 3);
+		return TRUE;
+	} else
+		return FALSE;
+}
+
+static gboolean find_nick(struct gaim_connection *gc, char *message)
+{
+	char *msg = g_strdup(message), *who, *p;
+	int n;
+	g_strdown(msg);
+
+	who = g_strdup(gc->username);
+	n = strlen(who);
+	g_strdown(who);
+
+	if ((p = strstr(msg, who)) != NULL) {
+		if (((p == msg) || !isalnum(*(p - 1))) && !isalnum(*(p + n))) {
+			g_free(who);
+			g_free(msg);
+			return TRUE;
+		}
+	}
+	g_free(who);
+
+	if (!g_strcasecmp(gc->username, gc->displayname)) {
+		g_free(msg);
+		return FALSE;
+	}
+
+	who = g_strdup(gc->displayname);
+	n = strlen(who);
+	g_strdown(who);
+
+	if ((p = strstr(msg, who)) != NULL) {
+		if (((p == msg) || !isalnum(*(p - 1))) && !isalnum(*(p + n))) {
+			g_free(who);
+			g_free(msg);
+			return TRUE;
+		}
+	}
+	g_free(who);
+	g_free(msg);
+	return FALSE;
+}
+
+void chat_write(struct conversation *b, char *who, int flag, char *message, time_t mtime)
+{
+	char *str;
+
+	if (!b->is_chat) {
+		debug_printf("chat_write: expecting chat, got IM\n");
+		return;
+	}
+
+	if (ignored(b, who))
+		return;
+
+	if (!(flag & WFLAG_WHISPER)) {
+		str = g_strdup(normalize (who));
+		if (!g_strcasecmp(str, normalize(b->gc->username))) {
+			if (b->makesound)
+				play_sound(SND_CHAT_YOU_SAY);
+			flag |= WFLAG_SEND;
+		} else if (!g_strcasecmp(str, normalize(b->gc->displayname))) {
+			if (b->makesound)
+				play_sound(SND_CHAT_YOU_SAY);
+			flag |= WFLAG_SEND;
+		} else {
+		       	flag |= WFLAG_RECV;
+			if (find_nick(b->gc, message))
+				flag |= WFLAG_NICK;
+		}
+		g_free(str);
+	}
+
+	if (flag & WFLAG_RECV && b->makesound) {
+		if (flag & WFLAG_NICK && (sound_options & OPT_SOUND_CHAT_NICK)) {
+			play_sound(SND_CHAT_NICK);
+		} else {
+			play_sound(SND_CHAT_SAY);
+		}
+	}
+		write_to_conv(b, message, flag, who, mtime, -1);
+}
+
+
+
+void whisper_callback(GtkWidget *widget, struct conversation *b)
+{
+	char buf[BUF_LEN * 4];
+	char buf2[BUF_LONG];
+	GList *selected;
+	char *who;
+
+	strncpy(buf, gtk_editable_get_chars(GTK_EDITABLE(b->entry), 0, -1), sizeof(buf) / 2);
+	if (!strlen(buf))
+		return;
+
+	selected = GTK_LIST(b->list)->selection;
+
+	if (!selected)
+		return;
+
+
+	who = GTK_LABEL(gtk_container_children(GTK_CONTAINER(selected->data))->data)->label;
+
+	if (!who)
+		return;
+
+	gtk_editable_delete_text(GTK_EDITABLE(b->entry), 0, -1);
+
+	serv_chat_whisper(b->gc, b->id, who, buf);
+
+	g_snprintf(buf2, sizeof(buf2), "%s->%s", b->gc->username, who);
+
+	chat_write(b, buf2, WFLAG_WHISPER, buf, time(NULL));
+
+	gtk_widget_grab_focus(GTK_WIDGET(b->entry));
+
+
+}
+
+static gint insertname(gconstpointer one, gconstpointer two)
+{
+	const char *a = (const char *)one;
+	const char *b = (const char *)two;
+
+	if (*a == '@') {
+		if (*b != '@')
+			return -1;
+		return (strcmp(a + 1, b + 1));
+	} else if (*a == '+') {
+		if (*b == '@')
+			return 1;
+		if (*b != '+')
+			return -1;
+		return (strcmp(a + 1, b + 1));
+	} else {
+		if (*b == '@' || *b == '+')
+			return 1;
+		return strcmp(a, b);
+	}
+}
+
+static void chat_press_im(GtkObject *obj, struct conversation *b)
+{
+	struct conversation *c;
+
+	c = find_conversation(gtk_object_get_user_data(obj));
+
+	if (c != NULL)
+		gdk_window_show(c->window->window);
+	else {
+		c = new_conversation(gtk_object_get_user_data(obj));
+		set_convo_gc(c, b->gc);
+	}
+}
+
+static void chat_press_ign(GtkWidget *obj, struct conversation *b)
+{
+	gtk_list_select_child(GTK_LIST(b->list), gtk_object_get_user_data(GTK_OBJECT(obj)));
+	ignore_callback(obj, b);
+}
+
+static void chat_press_info(GtkObject *obj, struct conversation *b)
+{
+	if (b->gc) {
+		/*
+		 * If there are special needs for getting info on users in
+		 * buddy chat "rooms"...
+		 */
+		if(b->gc->prpl->get_cb_info != NULL) {
+			b->gc->prpl->get_cb_info(b->gc, b->id, gtk_object_get_user_data(obj));
+		} else {
+			b->gc->prpl->get_info(b->gc, gtk_object_get_user_data(obj));
+		}
+	}
+}
+
+
+static void chat_press_away(GtkObject *obj, struct conversation *b)
+{
+	if (b->gc) {
+		/*
+		 * May want to expand this to work similarly to chat_press_info?
+		 */
+		if(b->gc->prpl->get_cb_away != NULL) {
+			b->gc->prpl->get_cb_away(b->gc, b->id, gtk_object_get_user_data(obj));
+		}
+	}
+}
+
+static gint right_click_chat(GtkObject *obj, GdkEventButton *event, struct conversation *b)
+{
+	if (event->button == 1 && event->type == GDK_2BUTTON_PRESS) {
+		struct conversation *c;
+		if ((c = find_conversation(gtk_object_get_user_data(obj))) == NULL)
+			c = new_conversation(gtk_object_get_user_data(obj));
+		set_convo_gc(c, b->gc);
+	} else if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {
+		GtkWidget *menu;
+		GtkWidget *button;
+
+		menu = gtk_menu_new();
+
+		button = gtk_menu_item_new_with_label(_("IM"));
+		gtk_signal_connect(GTK_OBJECT(button), "activate", GTK_SIGNAL_FUNC(chat_press_im), b);
+		gtk_object_set_user_data(GTK_OBJECT(button), gtk_object_get_user_data(obj));
+		gtk_menu_append(GTK_MENU(menu), button);
+		gtk_widget_show(button);
+
+		if (ignored(b, gtk_object_get_user_data(obj)))
+			button = gtk_menu_item_new_with_label(_("Un-Ignore"));
+		else
+			button = gtk_menu_item_new_with_label(_("Ignore"));
+		gtk_signal_connect(GTK_OBJECT(button), "activate", GTK_SIGNAL_FUNC(chat_press_ign), b);
+		gtk_object_set_user_data(GTK_OBJECT(button), obj);
+		gtk_menu_append(GTK_MENU(menu), button);
+		gtk_widget_show(button);
+
+		if (b->gc && b->gc->prpl->get_info) {
+			button = gtk_menu_item_new_with_label(_("Info"));
+			gtk_signal_connect(GTK_OBJECT(button), "activate",
+					   GTK_SIGNAL_FUNC(chat_press_info), b);
+			gtk_object_set_user_data(GTK_OBJECT(button), gtk_object_get_user_data(obj));
+			gtk_menu_append(GTK_MENU(menu), button);
+			gtk_widget_show(button);
+		}
+
+		if (b->gc && b->gc->prpl->get_cb_away) {
+			button = gtk_menu_item_new_with_label(_("Get Away Msg"));
+			gtk_signal_connect(GTK_OBJECT(button), "activate",
+					   GTK_SIGNAL_FUNC(chat_press_away), b);
+			gtk_object_set_user_data(GTK_OBJECT(button), gtk_object_get_user_data(obj));
+			gtk_menu_append(GTK_MENU(menu), button);
+			gtk_widget_show(button);
+		}
+
+		gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button, event->time);
+		return TRUE;
+	}
+	return TRUE;
+}
+
+/*
+ * Common code for adding a chat buddy to the list
+ */
+static void add_chat_buddy_common(struct conversation *b, char *name, int pos)
+{
+        char tmp[BUF_LONG];
+        GtkWidget *list_item;
+
+        if (ignored(b, name)) {
+                g_snprintf(tmp, sizeof(tmp), "X %s", name);
+                list_item = gtk_list_item_new_with_label(tmp);
+        } else
+                list_item = gtk_list_item_new_with_label(name);
+
+        gtk_object_set_user_data(GTK_OBJECT(list_item), name);
+        gtk_signal_connect(GTK_OBJECT(list_item), "button_press_event",
+                           GTK_SIGNAL_FUNC(right_click_chat), b);
+        gtk_list_insert_items(GTK_LIST(b->list), g_list_append(NULL, list_item), pos);
+        gtk_widget_show(list_item);
+}
+
+void add_chat_buddy(struct conversation *b, char *buddy)
+{
+	char *name = g_strdup(buddy);
+	char tmp[BUF_LONG];
+	int pos;
+
+	plugin_event(event_chat_buddy_join, b->gc, (void *)b->id, name, 0);
+	b->in_room = g_list_insert_sorted(b->in_room, name, insertname);
+	pos = g_list_index(b->in_room, name);
+
+	add_chat_buddy_common(b, name, pos);
+
+	g_snprintf(tmp, sizeof(tmp), _("%d %s in room"), g_list_length(b->in_room),
+		   g_list_length(b->in_room) == 1 ? "person" : "people");
+	gtk_label_set_text(GTK_LABEL(b->count), tmp);
+
+	if (b->makesound)
+		play_sound(SND_CHAT_JOIN);
+
+	if (chat_options & OPT_CHAT_LOGON) {
+		g_snprintf(tmp, sizeof(tmp), _("%s entered the room."), name);
+		write_to_conv(b, tmp, WFLAG_SYSTEM, NULL, time(NULL), -1);
+	}
+}
+
+
+void rename_chat_buddy(struct conversation *b, char *old, char *new)
+{
+	GList *names = b->in_room;
+	GList *items = GTK_LIST(b->list)->children;
+
+	char *name = g_strdup(new);
+	char *ign;
+	int pos;
+
+	char tmp[BUF_LONG];
+
+	while (names) {
+		if (!g_strcasecmp((char *)names->data, old)) {
+			char *tmp2 = names->data;
+			b->in_room = g_list_remove(b->in_room, names->data);
+			while (items) {
+				if (tmp2 == gtk_object_get_user_data(items->data)) {
+					gtk_list_remove_items(GTK_LIST(b->list),
+							      g_list_append(NULL, items->data));
+					break;
+				}
+				items = items->next;
+			}
+			g_free(tmp2);
+			break;
+		}
+		names = names->next;
+	}
+
+	if (!names) {
+		g_free(name);
+		return;
+	}
+
+	b->in_room = g_list_insert_sorted(b->in_room, name, insertname);
+	pos = g_list_index(b->in_room, name);
+
+	ign = ignored(b, old);
+
+	if (ign) {
+		g_free(ign);
+		b->ignored = g_list_remove(b->ignored, ign);
+
+		/* we haven't added them yet. if we find them, don't add them again */
+		if (!ignored(b, new))
+			b->ignored = g_list_append(b->ignored, g_strdup(name));
+
+	} else {
+		if ((ign = ignored(b, new)) != NULL) {
+			/* if they weren't ignored and change to someone who is ignored,
+			 * assume it's someone else. that may seem a little backwards but
+			 * it's better when it *is* actually someone else. Sorry Sean. */
+			g_free(ign);
+			b->ignored = g_list_remove(b->ignored, ign);
+		}
+	}
+
+	add_chat_buddy_common(b, name, pos);
+
+	if (chat_options & OPT_CHAT_LOGON) {
+		g_snprintf(tmp, sizeof(tmp), _("%s is now known as %s"), old, new);
+		write_to_conv(b, tmp, WFLAG_SYSTEM, NULL, time(NULL), -1);
+	}
+}
+
+
+void remove_chat_buddy(struct conversation *b, char *buddy, char *reason)
+{
+	GList *names = b->in_room;
+	GList *items = GTK_LIST(b->list)->children;
+
+	char tmp[BUF_LONG];
+
+	plugin_event(event_chat_buddy_leave, b->gc, (void *)b->id, buddy, 0);
+
+	while (names) {
+		if (!g_strcasecmp((char *)names->data, buddy)) {
+			char *tmp = names->data;
+			b->in_room = g_list_remove(b->in_room, names->data);
+			while (items) {
+				if (tmp == gtk_object_get_user_data(items->data)) {
+					gtk_list_remove_items(GTK_LIST(b->list),
+							      g_list_append(NULL, items->data));
+					break;
+				}
+				items = items->next;
+			}
+			g_free(tmp);
+			break;
+		}
+		names = names->next;
+	}
+
+	if (!names)
+		return;
+
+	/* don't remove them from ignored in case they re-enter */
+
+	g_snprintf(tmp, sizeof(tmp), _("%d %s in room"), g_list_length(b->in_room),
+		   g_list_length(b->in_room) == 1 ? "person" : "people");
+	gtk_label_set_text(GTK_LABEL(b->count), tmp);
+
+	if (b->makesound)
+		play_sound(SND_CHAT_LEAVE);
+
+	if (chat_options & OPT_CHAT_LOGON) {
+		if (reason && *reason)
+			g_snprintf(tmp, sizeof(tmp), _("%s left the room (%s)."), buddy, reason);
+		else
+			g_snprintf(tmp, sizeof(tmp), _("%s left the room."), buddy);
+		write_to_conv(b, tmp, WFLAG_SYSTEM, NULL, time(NULL), -1);
+	}
+}
+
+
+void im_callback(GtkWidget *w, struct conversation *b)
+{
+	char *name;
+	GList *i;
+	struct conversation *c;
+
+	i = GTK_LIST(b->list)->selection;
+	if (i) {
+		name = (char *)gtk_object_get_user_data(GTK_OBJECT(i->data));
+	} else {
+		return;
+	}
+
+	if (*name == '@')
+		name++;
+	if (*name == '+')
+		name++;
+
+	c = find_conversation(name);
+
+	if (c != NULL) {
+		gdk_window_raise(c->window->window);
+	} else {
+		c = new_conversation(name);
+	}
+
+	set_convo_gc(c, b->gc);
+}
+
+void ignore_callback(GtkWidget *w, struct conversation *b)
+{
+	char *name;
+	GList *i;
+	char *ign;
+	int pos;
+
+	i = GTK_LIST(b->list)->selection;
+	if (i) {
+		name = (char *)gtk_object_get_user_data(GTK_OBJECT(i->data));
+	} else {
+		return;
+	}
+
+	pos = gtk_list_child_position(GTK_LIST(b->list), i->data);
+
+	ign = ignored(b, name);
+
+	if (ign) {
+		g_free(ign);
+		b->ignored = g_list_remove(b->ignored, ign);
+	} else {
+		b->ignored = g_list_append(b->ignored, g_strdup(name));
+	}
+
+	gtk_widget_destroy(i->data);
+	add_chat_buddy_common(b, name, pos);
+}
+
+void show_new_buddy_chat(struct conversation *b)
+{
+	GtkWidget *win;
+	GtkWidget *cont;
+	GtkWidget *text;
+	GtkWidget *send;
+	GtkWidget *list;
+	GtkWidget *invite_btn;
+	GtkWidget *whisper;
+	GtkWidget *close;
+	GtkWidget *chatentry;
+	GtkWidget *lbox;
+	GtkWidget *bbox;
+	GtkWidget *bbox2;
+	GtkWidget *im, *ignore, *info;
+	GtkWidget *sw;
+	GtkWidget *sw2;
+	GtkWidget *vbox;
+	GtkWidget *vpaned;
+	GtkWidget *hpaned;
+	GtkWidget *toolbar;
+	char buf[BUF_LONG];
+
+	int dispstyle = set_dispstyle(1);
+
+	if (chat_options & OPT_CHAT_ONE_WINDOW) {
+		if (!all_chats) {
+			win = all_chats = b->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+			if ((convo_options & OPT_CONVO_COMBINE) && (im_options & OPT_IM_ONE_WINDOW))
+				all_convos = all_chats;
+			gtk_window_set_wmclass(GTK_WINDOW(win), "buddy_chat", "Gaim");
+			gtk_window_set_policy(GTK_WINDOW(win), TRUE, TRUE, FALSE);
+			gtk_container_border_width(GTK_CONTAINER(win), 0);
+			gtk_widget_realize(win);
+			aol_icon(win->window);
+			gtk_window_set_title(GTK_WINDOW(win), _("Gaim - Group Chats"));
+			gtk_signal_connect(GTK_OBJECT(win), "delete_event",
+					   GTK_SIGNAL_FUNC(delete_all_convo), NULL);
+
+			chat_notebook = gtk_notebook_new();
+			if ((convo_options & OPT_CONVO_COMBINE) && (im_options & OPT_IM_ONE_WINDOW))
+				convo_notebook = chat_notebook;
+			if (chat_options & OPT_CHAT_SIDE_TAB) {
+				if (chat_options & OPT_CHAT_BR_TAB) {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook),
+								 GTK_POS_RIGHT);
+				} else {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook),
+								 GTK_POS_LEFT);
+				}
+			} else {
+				if (chat_options & OPT_CHAT_BR_TAB) {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook),
+								 GTK_POS_BOTTOM);
+				} else {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook),
+								 GTK_POS_TOP);
+				}
+			}
+			gtk_notebook_set_scrollable(GTK_NOTEBOOK(chat_notebook), TRUE);
+			gtk_notebook_popup_enable(GTK_NOTEBOOK(chat_notebook));
+			gtk_container_add(GTK_CONTAINER(win), chat_notebook);
+			gtk_signal_connect(GTK_OBJECT(chat_notebook), "switch-page",
+					   GTK_SIGNAL_FUNC(convo_switch), NULL);
+			gtk_widget_show(chat_notebook);
+		} else
+			win = b->window = all_chats;
+
+		cont = gtk_vbox_new(FALSE, 5);
+		gtk_container_set_border_width(GTK_CONTAINER(cont), 5);
+		gtk_notebook_append_page(GTK_NOTEBOOK(chat_notebook), cont, gtk_label_new(b->name));
+		gtk_widget_show(cont);
+	} else {
+		win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+		b->window = win;
+		gtk_object_set_user_data(GTK_OBJECT(win), b);
+		gtk_window_set_wmclass(GTK_WINDOW(win), "buddy_chat", "Gaim");
+		gtk_window_set_policy(GTK_WINDOW(win), TRUE, TRUE, TRUE);
+		gtk_container_border_width(GTK_CONTAINER(win), 10);
+		gtk_widget_realize(win);
+		aol_icon(win->window);
+		g_snprintf(buf, sizeof(buf), "Gaim - %s (chat)", b->name);
+		gtk_window_set_title(GTK_WINDOW(win), buf);
+		gtk_signal_connect(GTK_OBJECT(win), "destroy", GTK_SIGNAL_FUNC(close_callback), b);
+
+		cont = gtk_vbox_new(FALSE, 5);
+		gtk_container_add(GTK_CONTAINER(win), cont);
+		gtk_widget_show(cont);
+	}
+
+	if (b->gc->prpl->options & OPT_PROTO_CHAT_TOPIC) {
+		GtkWidget *hbox;
+		GtkWidget *label;
+
+		hbox = gtk_hbox_new(FALSE, 0);
+		gtk_box_pack_start(GTK_BOX(cont), hbox, FALSE, FALSE, 5);
+		gtk_widget_show(hbox);
+
+		label = gtk_label_new(_("Topic:"));
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+		gtk_widget_show(label);
+
+		b->topic_text = gtk_entry_new();
+		gtk_entry_set_editable(GTK_ENTRY(b->topic_text), FALSE);
+		gtk_box_pack_start(GTK_BOX(hbox), b->topic_text, TRUE, TRUE, 5);
+		gtk_widget_show(b->topic_text);
+	}
+
+	vpaned = gtk_vpaned_new();
+	gtk_paned_set_gutter_size(GTK_PANED(vpaned), 15);
+	gtk_container_add(GTK_CONTAINER(cont), vpaned);
+	gtk_widget_show(vpaned);
+
+	hpaned = gtk_hpaned_new();
+	gtk_paned_set_gutter_size(GTK_PANED(hpaned), 15);
+	gtk_paned_pack1(GTK_PANED(vpaned), hpaned, TRUE, FALSE);
+	gtk_widget_show(hpaned);
+
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	b->sw = sw;
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
+	gtk_paned_pack1(GTK_PANED(hpaned), sw, TRUE, TRUE);
+	gtk_widget_set_usize(sw, buddy_chat_size.width, buddy_chat_size.height);
+	gtk_widget_show(sw);
+
+	text = gtk_imhtml_new(NULL, NULL);
+	b->text = text;
+	gtk_container_add(GTK_CONTAINER(sw), text);
+	GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
+	GTK_LAYOUT(text)->vadjustment->step_increment = 10.0;
+	if (convo_options & OPT_CONVO_SHOW_TIME)
+		gtk_imhtml_show_comments(GTK_IMHTML(text), TRUE);
+	gaim_setup_imhtml(text);
+	gtk_widget_show(text);
+
+	lbox = gtk_vbox_new(FALSE, 5);
+	gtk_paned_pack2(GTK_PANED(hpaned), lbox, TRUE, TRUE);
+	gtk_widget_show(lbox);
+
+	b->count = gtk_label_new(_("0 people in room"));
+	gtk_box_pack_start(GTK_BOX(lbox), b->count, FALSE, FALSE, 0);
+	gtk_widget_show(b->count);
+
+	sw2 = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(lbox), sw2, TRUE, TRUE, 0);
+	gtk_widget_show(sw2);
+
+	list = gtk_list_new();
+	b->list = list;
+	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(sw2), list);
+	gtk_widget_set_usize(list, 150, -1);
+	gtk_widget_show(list);
+
+	bbox2 = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(lbox), bbox2, FALSE, FALSE, 0);
+	gtk_widget_show(bbox2);
+
+	im = picture_button2(win, _("IM"), tmp_send_xpm, FALSE);
+	gtk_box_pack_start(GTK_BOX(bbox2), im, dispstyle, dispstyle, 0);
+	gtk_signal_connect(GTK_OBJECT(im), "clicked", GTK_SIGNAL_FUNC(im_callback), b);
+
+	ignore = picture_button2(win, _("Ignore"), close_xpm, FALSE);
+	gtk_box_pack_start(GTK_BOX(bbox2), ignore, dispstyle, dispstyle, 0);
+	gtk_signal_connect(GTK_OBJECT(ignore), "clicked", GTK_SIGNAL_FUNC(ignore_callback), b);
+
+	info = picture_button2(win, _("Info"), tb_search_xpm, FALSE);
+	gtk_box_pack_start(GTK_BOX(bbox2), info, dispstyle, dispstyle, 0);
+	gtk_signal_connect(GTK_OBJECT(info), "clicked", GTK_SIGNAL_FUNC(info_callback), b);
+	b->info = info;
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_paned_pack2(GTK_PANED(vpaned), vbox, TRUE, FALSE);
+	gtk_widget_show(vbox);
+
+	chatentry = gtk_text_new(NULL, NULL);
+	b->entry = chatentry;
+	if (!(chat_options & OPT_CHAT_ONE_WINDOW))
+		gtk_window_set_focus(GTK_WINDOW(b->window), b->entry);
+
+	toolbar = build_conv_toolbar(b);
+	gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 0);
+
+	gtk_object_set_user_data(GTK_OBJECT(chatentry), b);
+	gtk_text_set_editable(GTK_TEXT(chatentry), TRUE);
+	gtk_text_set_word_wrap(GTK_TEXT(chatentry), TRUE);
+	gtk_signal_connect(GTK_OBJECT(chatentry), "activate", GTK_SIGNAL_FUNC(send_callback), b);
+	gtk_signal_connect(GTK_OBJECT(chatentry), "key_press_event", GTK_SIGNAL_FUNC(keypress_callback),
+			   b);
+	gtk_signal_connect(GTK_OBJECT(chatentry), "key_press_event", GTK_SIGNAL_FUNC(entry_key_pressed),
+			   chatentry);
+	if (convo_options & OPT_CONVO_CHECK_SPELLING)
+		gtkspell_attach(GTK_TEXT(chatentry));
+	gtk_box_pack_start(GTK_BOX(vbox), chatentry, TRUE, TRUE, 0);
+	gtk_widget_set_usize(chatentry, buddy_chat_size.width, MAX(buddy_chat_size.entry_height, 25));
+	gtk_window_set_focus(GTK_WINDOW(win), chatentry);
+	gtk_widget_show(chatentry);
+
+	bbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);
+	gtk_widget_show(bbox);
+
+	close = picture_button2(win, _("Close"), cancel_xpm, dispstyle);
+	b->close = close;
+	gtk_object_set_user_data(GTK_OBJECT(close), b);
+	gtk_signal_connect(GTK_OBJECT(close), "clicked", GTK_SIGNAL_FUNC(close_callback), b);
+	gtk_box_pack_end(GTK_BOX(bbox), close, dispstyle, dispstyle, 0);
+
+	invite_btn = picture_button2(win, _("Invite"), join_xpm, dispstyle);
+	b->invite = invite_btn;
+	gtk_signal_connect(GTK_OBJECT(invite_btn), "clicked", GTK_SIGNAL_FUNC(invite_callback), b);
+	gtk_box_pack_end(GTK_BOX(bbox), invite_btn, dispstyle, dispstyle, 0);
+
+	whisper = picture_button2(win, _("Whisper"), tb_forward_xpm, dispstyle);
+	b->whisper = whisper;
+	gtk_signal_connect(GTK_OBJECT(whisper), "clicked", GTK_SIGNAL_FUNC(whisper_callback), b);
+	gtk_box_pack_end(GTK_BOX(bbox), whisper, dispstyle, dispstyle, 0);
+
+	send = picture_button2(win, _("Send"), tmp_send_xpm, dispstyle);
+	b->send = send;
+	gtk_signal_connect(GTK_OBJECT(send), "clicked", GTK_SIGNAL_FUNC(send_callback), b);
+	gtk_box_pack_end(GTK_BOX(bbox), send, dispstyle, dispstyle, 0);
+
+	b->font_dialog = NULL;
+	b->fg_color_dialog = NULL;
+	b->bg_color_dialog = NULL;
+	b->smiley_dialog = NULL;
+	b->link_dialog = NULL;
+	b->log_dialog = NULL;
+	sprintf(b->fontface, "%s", fontface);
+	b->hasfont = 0;
+	b->bgcol = bgcolor;
+	b->hasbg = 0;
+	b->fgcol = fgcolor;
+	b->hasfg = 0;
+
+	update_buttons_by_protocol(b);
+
+	gtk_widget_show(win);
+}
+
+void chat_set_topic(struct conversation *b, char *who, char *topic)
+{
+	gtk_entry_set_text(GTK_ENTRY(b->topic_text), topic);
+	if (b->topic)
+		g_free(b->topic);
+	b->topic = g_strdup(topic);
+}
+
+
+
+void delete_chat(struct conversation *b)
+{
+	while (b->in_room) {
+		g_free(b->in_room->data);
+		b->in_room = g_list_remove(b->in_room, b->in_room->data);
+	}
+	while (b->ignored) {
+		g_free(b->ignored->data);
+		b->ignored = g_list_remove(b->ignored, b->ignored->data);
+	}
+	g_string_free(b->history, TRUE);
+	if (b->topic)
+		g_free(b->topic);
+	g_free(b);
+}
+
+static GtkWidget *change_text(GtkWidget *win, char *text, GtkWidget *button, char **xpm, int chat)
+{
+	int dispstyle = set_dispstyle(chat);
+	GtkWidget *parent = button->parent;
+	gtk_widget_destroy(button);
+	button = picture_button2(win, text, xpm, dispstyle);
+	if (chat == 1)
+		gtk_box_pack_start(GTK_BOX(parent), button, dispstyle, dispstyle, 5);
+	else
+		gtk_box_pack_end(GTK_BOX(parent), button, dispstyle, dispstyle, 0);
+	gtk_widget_show(button);
+	return button;
+}
+
+void update_chat_button_pix()
+{
+	GSList *C = connections;
+	struct gaim_connection *g;
+
+	while (C) {
+		GSList *bcs;
+		struct conversation *c;
+		int opt = 1;
+		g = (struct gaim_connection *)C->data;
+		bcs = g->buddy_chats;
+
+		while (bcs) {
+			c = (struct conversation *)bcs->data;
+			c->send = change_text(c->window, _("Send"), c->send, tmp_send_xpm, opt);
+			c->whisper =
+			    change_text(c->window, _("Whisper"), c->whisper, tb_forward_xpm, opt);
+			c->invite = change_text(c->window, _("Invite"), c->invite, join_xpm, opt);
+			c->close = change_text(c->window, _("Close"), c->close, cancel_xpm, opt);
+			gtk_object_set_user_data(GTK_OBJECT(c->close), c);
+			gtk_signal_connect(GTK_OBJECT(c->close), "clicked",
+					   GTK_SIGNAL_FUNC(close_callback), c);
+			gtk_signal_connect(GTK_OBJECT(c->send), "clicked",
+					   GTK_SIGNAL_FUNC(send_callback), c);
+			gtk_signal_connect(GTK_OBJECT(c->invite), "clicked",
+					   GTK_SIGNAL_FUNC(invite_callback), c);
+			gtk_signal_connect(GTK_OBJECT(c->whisper), "clicked",
+					   GTK_SIGNAL_FUNC(whisper_callback), c);
+
+			update_buttons_by_protocol(c);
+
+			bcs = bcs->next;
+		}
+		C = C->next;
+	}
+}
+
+void update_im_button_pix()
+{
+	GList *bcs = conversations;
+	struct conversation *c;
+	GtkWidget *parent;
+	int opt = 0;
+	int dispstyle = set_dispstyle(0);
+
+	while (bcs) {
+		c = (struct conversation *)bcs->data;
+		parent = c->close->parent;
+		c->close = change_text(c->window, _("Close"), c->close, cancel_xpm, opt);
+		gtk_box_reorder_child(GTK_BOX(parent), c->close, 0);
+		gtk_box_set_child_packing(GTK_BOX(parent), c->sep1, dispstyle, dispstyle, 0,
+					  GTK_PACK_END);
+		if (find_buddy(c->gc, c->name) == NULL)
+			 c->add = change_text(c->window, _("Add"), c->add, gnome_add_xpm, opt);
+		else
+			c->add = change_text(c->window, _("Remove"), c->add, gnome_remove_xpm, opt);
+		gtk_box_reorder_child(GTK_BOX(parent), c->add, 2);
+		c->block = change_text(c->window, _("Block"), c->block, block_xpm, opt);
+		gtk_box_reorder_child(GTK_BOX(parent), c->block, 3);
+		c->warn = change_text(c->window, _("Warn"), c->warn, warn_xpm, opt);
+		gtk_box_reorder_child(GTK_BOX(parent), c->warn, 4);
+		c->info = change_text(c->window, _("Info"), c->info, tb_search_xpm, opt);
+		gtk_box_reorder_child(GTK_BOX(parent), c->info, 5);
+		c->send = change_text(c->window, _("Send"), c->send, tmp_send_xpm, opt);
+		gtk_box_set_child_packing(GTK_BOX(parent), c->sep2, dispstyle, dispstyle, 0,
+					  GTK_PACK_END);
+		gtk_box_reorder_child(GTK_BOX(parent), c->send, 7);
+		gtk_object_set_user_data(GTK_OBJECT(c->close), c);
+		gtk_signal_connect(GTK_OBJECT(c->close), "clicked", GTK_SIGNAL_FUNC(close_callback), c);
+		gtk_signal_connect(GTK_OBJECT(c->send), "clicked", GTK_SIGNAL_FUNC(send_callback), c);
+		gtk_signal_connect(GTK_OBJECT(c->add), "clicked", GTK_SIGNAL_FUNC(add_callback), c);
+		gtk_signal_connect(GTK_OBJECT(c->info), "clicked", GTK_SIGNAL_FUNC(info_callback), c);
+		gtk_signal_connect(GTK_OBJECT(c->warn), "clicked", GTK_SIGNAL_FUNC(warn_callback), c);
+		gtk_signal_connect(GTK_OBJECT(c->block), "clicked", GTK_SIGNAL_FUNC(block_callback), c);
+		bcs = bcs->next;
+	}
+}
+
+void chat_tabize()
+{
+	int pos = 0;
+	char tmp[BUF_LONG];
+	/* evil, evil i tell you! evil! */
+	if (chat_options & OPT_CHAT_ONE_WINDOW) {
+		GList *x = chats;
+		if ((convo_options & OPT_CONVO_COMBINE) && (im_options & OPT_IM_ONE_WINDOW)) {
+			all_chats = all_convos;
+			chat_notebook = convo_notebook;
+		}
+		while (x) {
+			struct conversation *c = x->data;
+			GtkWidget *imhtml, *win;
+			GList *r = c->in_room;
+
+			imhtml = c->text;
+			win = c->window;
+			show_new_buddy_chat(c);
+			gtk_widget_destroy(c->text);
+			gtk_widget_reparent(imhtml, c->sw);
+			c->text = imhtml;
+			gtk_signal_disconnect_by_func(GTK_OBJECT(win),
+						      GTK_SIGNAL_FUNC(close_callback), c);
+			gtk_widget_destroy(win);
+
+			if (c->topic)
+				gtk_entry_set_text(GTK_ENTRY(c->topic_text), c->topic);
+
+			g_snprintf(tmp, sizeof(tmp), _("%d %s in room"), g_list_length(c->in_room),
+				   g_list_length(c->in_room) == 1 ? "person" : "people");
+			gtk_label_set_text(GTK_LABEL(c->count), tmp);
+
+			while (r) {
+				char *name = r->data;
+
+				add_chat_buddy_common(c, name, pos);
+
+				r = r->next;
+				pos++;
+			}
+
+			x = x->next;
+		}
+	} else {
+		GList *x, *m;
+		x = m = chats;
+		chats = NULL;
+		while (x) {
+			struct conversation *c = x->data;
+			GtkWidget *imhtml;
+			GList *r = c->in_room;
+
+			imhtml = c->text;
+			show_new_buddy_chat(c);
+			gtk_widget_destroy(c->text);
+			gtk_widget_reparent(imhtml, c->sw);
+			c->text = imhtml;
+
+			if (c->topic)
+				gtk_entry_set_text(GTK_ENTRY(c->topic_text), c->topic);
+
+			g_snprintf(tmp, sizeof(tmp), _("%d %s in room"), g_list_length(c->in_room),
+				   g_list_length(c->in_room) == 1 ? "person" : "people");
+			gtk_label_set_text(GTK_LABEL(c->count), tmp);
+
+			while (r) {
+				char *name = r->data;
+
+				add_chat_buddy_common(c, name, pos);
+
+				r = r->next;
+				pos++;
+			}
+
+			x = x->next;
+		}
+		chats = m;
+		if ((convo_options & OPT_CONVO_COMBINE) &&
+		    (im_options & OPT_IM_ONE_WINDOW) && conversations) {
+			while (m) {
+				gtk_notebook_remove_page(GTK_NOTEBOOK(chat_notebook),
+							 g_list_length(conversations));
+				m = m->next;
+			}
+		} else if (all_chats)
+			gtk_widget_destroy(all_chats);
+		all_chats = NULL;
+		chat_notebook = NULL;
+	}
+}
diff -Nru gaim-0.58/src/conversation.c gaim-0.58-t/src/conversation.c
--- gaim-0.58/src/conversation.c	Sat May  4 21:16:45 2002
+++ gaim-0.58-t/src/conversation.c	Wed Jun 12 20:09:47 2002
@@ -258,10 +258,14 @@
 void delete_conversation(struct conversation *c)
 {
 	conversations = g_list_remove(conversations, c);
-	if (c->fg_color_dialog)
-		gtk_widget_destroy(c->fg_color_dialog);
-	if (c->bg_color_dialog)
-		gtk_widget_destroy(c->bg_color_dialog);
+	if (c->out_fg_color_dialog)
+		gtk_widget_destroy(c->out_fg_color_dialog);
+	if (c->out_bg_color_dialog)
+		gtk_widget_destroy(c->out_bg_color_dialog);
+	if (c->def_fg_color_dialog)
+		gtk_widget_destroy(c->def_fg_color_dialog);
+	if (c->def_bg_color_dialog)
+		gtk_widget_destroy(c->def_bg_color_dialog);
 	if (c->font_dialog)
 		gtk_widget_destroy(c->font_dialog);
 	if (c->smiley_dialog)
@@ -350,26 +354,41 @@
 	}
 }
 
-/*
 void update_transparency()
 {
 	GList *cnv = conversations;
 	struct conversation *c;
 
-        This func should be uncalled!
-
-	while(cnv) {
+	while (cnv) {
 		c = (struct conversation *)cnv->data;
 
-		if (c->text)
-			gtk_html_set_transparent(GTK_HTML(c->text),
-        						  (transparent) ? TRUE : FALSE);
+		if (c->text) {
+			gtk_imhtml_set_background(GTK_IMHTML(c->text), NULL,
+				((trans_options & OPT_TRANS_CONV) == OPT_TRANS_CONV) ? 1 : 0,
+				1);
+			gtk_imhtml_refresh(GTK_IMHTML(c->text), 1);
+		}
 
 		cnv = cnv->next;
 	}
 }
-*/
 
+void update_tints()
+{
+	GList *cnv = conversations;
+	struct conversation *c;
+
+	if ((trans_options & OPT_TRANS_CONV) == OPT_TRANS_CONV) {
+		while (cnv) {
+			c = (struct conversation *)cnv->data;
+
+			if (c->text)
+				gtk_imhtml_refresh(GTK_IMHTML(c->text), 1);
+
+			cnv = cnv->next;
+		}
+	}
+}
 
 /*------------------------------------------------------------------------*/
 /*  Callbacks                                                             */
@@ -573,12 +592,18 @@
 		}
 	}
 
-	if (c->fg_color_dialog)
-		gtk_widget_destroy(c->fg_color_dialog);
-	c->fg_color_dialog = NULL;
-	if (c->bg_color_dialog)
-		gtk_widget_destroy(c->bg_color_dialog);
-	c->bg_color_dialog = NULL;
+	if (c->out_fg_color_dialog)
+		gtk_widget_destroy(c->out_fg_color_dialog);
+	c->out_fg_color_dialog = NULL;
+	if (c->out_bg_color_dialog)
+		gtk_widget_destroy(c->out_bg_color_dialog);
+	c->out_bg_color_dialog = NULL;
+	if (c->def_fg_color_dialog)
+		gtk_widget_destroy(c->def_fg_color_dialog);
+	c->def_fg_color_dialog = NULL;
+	if (c->def_bg_color_dialog)
+		gtk_widget_destroy(c->def_bg_color_dialog);
+	c->def_bg_color_dialog = NULL;
 	if (c->font_dialog)
 		gtk_widget_destroy(c->font_dialog);
 	c->font_dialog = NULL;
@@ -1096,7 +1121,6 @@
 	if (!c->gc)
 		return;
 
-
 	buf2 = gtk_editable_get_chars(GTK_EDITABLE(c->entry), 0, -1);
 	limit = 32 * 1024;	/* you shouldn't be sending more than 32k in your messages. that's a book. */
 	buf = g_malloc(limit);
@@ -1149,15 +1173,15 @@
 			strcpy(buf, buf2);
 		}
 
-		if ((font_options & OPT_FONT_FGCOL) || c->hasfg) {
-			g_snprintf(buf2, limit, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", c->fgcol.red,
-				   c->fgcol.green, c->fgcol.blue, buf);
+		if ((font_options & OPT_FONT_OUT_FGCOL) || c->has_out_fg) {
+			g_snprintf(buf2, limit, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", c->out_fgcol.red,
+				   c->out_fgcol.green, c->out_fgcol.blue, buf);
 			strcpy(buf, buf2);
 		}
-
-		if ((font_options & OPT_FONT_BGCOL) || c->hasbg) {
+		
+		if ((font_options & OPT_FONT_OUT_BGCOL) || c->has_out_bg) {
 			g_snprintf(buf2, limit, "<BODY BGCOLOR=\"#%02X%02X%02X\">%s</BODY>",
-				   c->bgcol.red, c->bgcol.green, c->bgcol.blue, buf);
+				   c->out_bgcol.red, c->out_bgcol.green, c->out_bgcol.blue, buf);
 			strcpy(buf, buf2);
 		}
 	}
@@ -1558,9 +1582,9 @@
 	if (state_lock)
 		return;
 	if (GTK_TOGGLE_BUTTON(color)->active)
-		show_fgcolor_dialog(c, color);
-	else if (c->fg_color_dialog)
-		cancel_fgcolor(color, c);
+		show_out_fgcolor_dialog(c, color);
+	else if (c->out_fg_color_dialog)
+		cancel_out_fgcolor(color, c);
 	else
 		advance_past(c->entry, "<FONT COLOR>", "</FONT>");
 }
@@ -1570,9 +1594,9 @@
 	if (state_lock)
 		return;
 	if (GTK_TOGGLE_BUTTON(color)->active)
-		show_bgcolor_dialog(c, color);
-	else if (c->bg_color_dialog)
-		cancel_bgcolor(color, c);
+		show_out_bgcolor_dialog(c, color);
+	else if (c->out_bg_color_dialog)
+		cancel_out_bgcolor(color, c);
 	else
 		advance_past(c->entry, "<BODY BGCOLOR>", "</BODY>");
 }
@@ -1748,6 +1772,7 @@
 	int gtk_font_options = 0;
 	GString *logstr;
 	char buf2[BUF_LONG];
+	char whatbuf[BUF_LONG];
 	char mdate[64];
 	int unhighlight = 0;
 	
@@ -1801,13 +1826,21 @@
 	if (!(logging_options & OPT_LOG_STRIP_HTML))
 		gtk_font_options = gtk_font_options ^ GTK_IMHTML_RETURN_LOG;
 
+	if ((font_options & OPT_FONT_DEF_FGCOL) || c->has_def_fg)
+		g_snprintf(whatbuf, BUF_LONG, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>",
+				   c->def_fgcol.red, c->def_fgcol.green, c->def_fgcol.blue,
+				   what);
+	else
+		strncpy(whatbuf, what, BUF_LONG);
+	
 	if (flags & WFLAG_SYSTEM) {
 		if (convo_options & OPT_CONVO_SHOW_TIME)
 			g_snprintf(buf, BUF_LONG, "<FONT SIZE=\"2\">(%s) </FONT><B>%s</B>", mdate, what);
 		else
 			g_snprintf(buf, BUF_LONG, "<B>%s</B>", what);
+
 		g_snprintf(buf2, sizeof(buf2), "<FONT SIZE=\"2\"><!--(%s) --></FONT><B>%s</B><BR>",
-			   mdate, what);
+			   mdate, whatbuf);
 
 		gtk_imhtml_append_text(GTK_IMHTML(c->text), buf2, -1, 0);
 
@@ -1900,7 +1933,7 @@
 
 		gtk_imhtml_append_text(GTK_IMHTML(c->text), buf2, -1, 0);
 
-		logstr = gtk_imhtml_append_text(GTK_IMHTML(c->text), what, length, gtk_font_options);
+		logstr = gtk_imhtml_append_text(GTK_IMHTML(c->text), whatbuf, length, gtk_font_options);
 
 		gtk_imhtml_append_text(GTK_IMHTML(c->text), "<BR>", -1, 0);
 
@@ -2686,18 +2719,24 @@
 	int dispstyle = set_dispstyle(0);
 
 	c->font_dialog = NULL;
-	c->fg_color_dialog = NULL;
-	c->bg_color_dialog = NULL;
+	c->out_fg_color_dialog = NULL;
+	c->out_bg_color_dialog = NULL;
+	c->def_fg_color_dialog = NULL;
+	c->def_bg_color_dialog = NULL;
 	c->smiley_dialog = NULL;
 	c->link_dialog = NULL;
 	c->log_dialog = NULL;
 	sprintf(c->fontxfld, "%s", fontxfld);
 	sprintf(c->fontface, "%s", fontface);
 	c->hasfont = 0;
-	c->bgcol = bgcolor;
-	c->hasbg = 0;
-	c->fgcol = fgcolor;
-	c->hasfg = 0;
+	c->out_bgcol = out_bgcolor;
+	c->has_out_bg = 0;
+	c->out_fgcol = out_fgcolor;
+	c->has_out_fg = 0;
+	c->def_bgcol = def_bgcolor;
+	c->has_def_bg = 0;
+	c->def_fgcol = def_fgcolor;
+	c->has_def_fg = 0;
 
 	if (im_options & OPT_IM_ONE_WINDOW) {
 		if (!all_convos) {
@@ -2779,6 +2818,17 @@
 	gtk_widget_show(sw);
 
 	text = gtk_imhtml_new(NULL, NULL);
+
+	if ((trans_options & OPT_TRANS_CONV) == OPT_TRANS_CONV)
+		gtk_imhtml_set_background(GTK_IMHTML(text), NULL, 1, 1);
+
+	gtk_signal_connect_object(GTK_OBJECT(win), "configure_event",
+							  GTK_SIGNAL_FUNC(win_move), GTK_OBJECT(text));
+#if 0
+	gtk_signal_connect(GTK_OBJECT(win), "configure_event",
+			   GTK_SIGNAL_FUNC(win_move), text);
+#endif
+
 	c->text = text;
 	gtk_container_add(GTK_CONTAINER(sw), text);
 	GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
@@ -3238,13 +3288,17 @@
 		b = c->data;
 		c = c->next;
 		if (fg) {
-			if (b->hasfg)
-				continue;
-			b->fgcol = fgcolor;
+			if (!b->has_out_fg)
+				b->out_fgcol = out_fgcolor;
+
+			if (!b->has_def_fg)
+				b->def_fgcol = def_fgcolor;
 		} else {
-			if (b->hasbg)
-				continue;
-			b->bgcol = bgcolor;
+			if (!b->has_out_bg)
+				b->out_bgcol = out_bgcolor;
+
+			if (!b->has_def_bg)
+				b->def_bgcol = def_bgcolor;
 		}
 	}
 }
diff -Nru gaim-0.58/src/conversation.c~ gaim-0.58-t/src/conversation.c~
--- gaim-0.58/src/conversation.c~	Wed Dec 31 19:00:00 1969
+++ gaim-0.58-t/src/conversation.c~	Sat May  4 21:16:45 2002
@@ -0,0 +1,3671 @@
+/*
+ * gaim
+ *
+ * Copyright (C) 1998-1999, Mark Spencer <markster@marko.net>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <string.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <ctype.h>
+#include <gdk/gdkx.h>
+#include <X11/Xlib.h>
+#include <gtk/gtk.h>
+#include "gtkimhtml.h"
+#include <gdk/gdkkeysyms.h>
+#include "convo.h"
+#include "gtkspell.h"
+#include "prpl.h"
+
+#include "pixmaps/bold.xpm"
+#include "pixmaps/italic.xpm"
+#include "pixmaps/underline.xpm"
+#include "pixmaps/strike.xpm"
+#include "pixmaps/small.xpm"
+#include "pixmaps/normal.xpm"
+#include "pixmaps/big.xpm"
+#include "pixmaps/fontface.xpm"
+#include "pixmaps/fgcolor.xpm"
+#include "pixmaps/bgcolor.xpm"
+#include "pixmaps/link.xpm"
+#include "pixmaps/smile_icon.xpm"
+#include "pixmaps/wood.xpm"
+#include "pixmaps/save_small.xpm"
+#include "pixmaps/speaker.xpm"
+#include "pixmaps/image_icon.xpm"
+
+#include "pixmaps/luke03.xpm"
+#include "pixmaps/oneeye.xpm"
+#include "pixmaps/crazy4.xpm"
+#include "pixmaps/mrt.xpm"
+#include "pixmaps/download.xpm"
+#include "pixmaps/farted.xpm"
+
+static gchar *ispell_cmd[] = { "ispell", "-a", NULL };
+static gchar *aspell_cmd[] = { "aspell", "--sug-mode=fast","-a", NULL };
+
+int state_lock = 0;
+
+GdkPixmap *dark_icon_pm = NULL;
+GdkBitmap *dark_icon_bm = NULL;
+
+GtkWidget *all_convos = NULL;
+GtkWidget *convo_notebook = NULL;
+
+char fontface[128] = { 0 };
+char fontxfld[256] = { 0 };
+int fontsize = 3;
+extern GdkColor bgcolor;
+extern GdkColor fgcolor;
+
+void check_everything(GtkWidget *entry);
+gboolean keypress_callback(GtkWidget *entry, GdkEventKey * event, struct conversation *c);
+
+static void update_icon(struct conversation *);
+static void remove_icon(struct conversation *);
+
+static void update_checkbox(struct conversation *);
+static void remove_checkbox(struct conversation *);
+
+static void update_smilies(struct conversation *c);
+
+
+/*------------------------------------------------------------------------*/
+/*  Helpers                                                               */
+/*------------------------------------------------------------------------*/
+
+
+void gaim_setup_imhtml_smileys(GtkWidget *imhtml)
+{
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), "C:)", luke03_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), "C:-)", luke03_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), "O-)", oneeye_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), ">:)", crazy4_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), ">:-)", crazy4_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), ":-o)))", mrt_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), ":-O)))", mrt_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), "8-|)", download_xpm);
+	gtk_imhtml_associate_smiley(GTK_IMHTML(imhtml), ":-]", farted_xpm);
+}
+
+void gaim_setup_imhtml(GtkWidget *imhtml)
+{
+	g_return_if_fail(imhtml != NULL);
+	g_return_if_fail(GTK_IS_IMHTML(imhtml));
+	if (!(convo_options & OPT_CONVO_SHOW_SMILEY))
+		gtk_imhtml_show_smileys(GTK_IMHTML(imhtml), FALSE);
+
+	gtk_signal_connect(GTK_OBJECT(imhtml), "url_clicked", GTK_SIGNAL_FUNC(open_url), NULL);
+	gaim_setup_imhtml_smileys(imhtml);	
+}
+
+void quiet_set(GtkWidget *tb, int state)
+{
+	state_lock = 1;
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(tb), state);
+	state_lock = 0;
+}
+
+
+void set_state_lock(int i)
+{
+	state_lock = i;
+}
+
+void toggle_sensitive(GtkWidget *widget, GtkWidget *to_toggle)
+{
+	gboolean sensitivity = GTK_WIDGET_IS_SENSITIVE(GTK_WIDGET(to_toggle));
+
+	if (sensitivity == TRUE)
+		gtk_widget_set_sensitive(GTK_WIDGET(to_toggle), FALSE);
+	else
+		gtk_widget_set_sensitive(GTK_WIDGET(to_toggle), TRUE);
+
+	return;
+}
+
+void set_convo_name(struct conversation *c, const char *nname)
+{
+
+	g_snprintf(c->name, sizeof(c->name), "%s", nname);
+
+	return;
+}
+
+struct conversation *new_conversation(char *name)
+{
+	struct conversation *c;
+
+	c = find_conversation(name);
+
+	if (c != NULL)
+		return c;
+
+	c = (struct conversation *)g_new0(struct conversation, 1);
+	g_snprintf(c->name, sizeof(c->name), "%s", name);
+
+	if ((logging_options & OPT_LOG_ALL) || find_log_info(c->name)) {
+		FILE *fd;
+
+		fd = open_log_file(c->name);
+		if (fd) {
+			if (!(logging_options & OPT_LOG_STRIP_HTML))
+				fprintf(fd,
+					"<HR><BR><H3 Align=Center> ---- New Conversation @ %s ----</H3><BR>\n",
+					full_date());
+			else
+				fprintf(fd, " ---- New Conversation @ %s ----\n", full_date());
+			fclose(fd);
+		} else
+			/* do we want to do something here? */ ;
+	}
+
+	if (connections)
+		c->gc = (struct gaim_connection *)connections->data;
+	c->history = g_string_new("");
+	c->send_history = g_list_append(NULL, NULL);
+	conversations = g_list_append(conversations, c);
+	show_conv(c);
+	update_icon(c);
+	update_checkbox(c);
+	update_smilies(c);
+	plugin_event(event_new_conversation, name, 0, 0, 0);
+	return c;
+}
+
+
+struct conversation *find_conversation(char *name)
+{
+	char *cuser = g_malloc(1024);
+	struct conversation *c;
+	GList *cnv = conversations;
+
+	strcpy(cuser, normalize(name));
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+		if (!g_strcasecmp(cuser, normalize(c->name))) {
+			g_free(cuser);
+			return c;
+		}
+		cnv = cnv->next;
+	}
+	g_free(cuser);
+	return NULL;
+}
+
+/* ---------------------------------------------------
+ * Function to remove a log file entry
+ * ---------------------------------------------------
+ */
+
+void rm_log(struct log_conversation *a)
+{
+	struct conversation *cnv = find_conversation(a->name);
+
+	log_conversations = g_list_remove(log_conversations, a);
+
+	save_prefs();
+
+	if (cnv && !(im_options & OPT_IM_ONE_WINDOW))
+		set_convo_title(cnv);
+}
+
+struct log_conversation *find_log_info(char *name)
+{
+	char *pname = g_malloc(1024);
+	GList *lc = log_conversations;
+	struct log_conversation *l;
+
+
+	strcpy(pname, normalize(name));
+
+	while (lc) {
+		l = (struct log_conversation *)lc->data;
+		if (!g_strcasecmp(pname, normalize(l->name))) {
+			g_free(pname);
+			return l;
+		}
+		lc = lc->next;
+	}
+	g_free(pname);
+	return NULL;
+}
+
+void delete_conversation(struct conversation *c)
+{
+	conversations = g_list_remove(conversations, c);
+	if (c->fg_color_dialog)
+		gtk_widget_destroy(c->fg_color_dialog);
+	if (c->bg_color_dialog)
+		gtk_widget_destroy(c->bg_color_dialog);
+	if (c->font_dialog)
+		gtk_widget_destroy(c->font_dialog);
+	if (c->smiley_dialog)
+		gtk_widget_destroy(c->smiley_dialog);
+	if (c->link_dialog)
+		gtk_widget_destroy(c->link_dialog);
+	if (c->log_dialog)
+		gtk_widget_destroy(c->log_dialog);
+#if USE_PIXBUF
+	if (c->save_icon)
+		gtk_widget_destroy(c->save_icon);
+#endif
+	c->send_history = g_list_first(c->send_history);
+	while (c->send_history) {
+		if (c->send_history->data)
+			g_free(c->send_history->data);
+		c->send_history = c->send_history->next;
+	}
+	g_list_free(c->send_history);
+	if (c->typing_timeout)
+		gtk_timeout_remove(c->typing_timeout);
+	g_string_free(c->history, TRUE);
+	g_free(c);
+}
+
+void update_log_convs()
+{
+	GSList *C = connections;
+	struct gaim_connection *g;
+	GSList *bcs;
+	GList *cnv = conversations;
+	struct conversation *c;
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+
+		if (c->log_button)
+			gtk_widget_set_sensitive(c->log_button,
+						 ((logging_options & OPT_LOG_ALL)) ? FALSE : TRUE);
+
+		cnv = cnv->next;
+	}
+
+	while (C) {
+		g = (struct gaim_connection *)C->data;
+		bcs = g->buddy_chats;
+		while (bcs) {
+			c = (struct conversation *)bcs->data;
+
+			if (c->log_button)
+				gtk_widget_set_sensitive(c->log_button,
+							 ((logging_options & OPT_LOG_ALL)) ? FALSE :
+							 TRUE);
+
+			bcs = bcs->next;
+		}
+		C = C->next;
+	}
+}
+
+void update_font_buttons()
+{
+	GList *cnv = conversations;
+	struct conversation *c;
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+
+		if (c->bold)
+			gtk_widget_set_sensitive(c->bold,
+						 ((font_options & OPT_FONT_BOLD)) ? FALSE : TRUE);
+
+		if (c->italic)
+			gtk_widget_set_sensitive(c->italic,
+						 ((font_options & OPT_FONT_ITALIC)) ? FALSE : TRUE);
+
+		if (c->underline)
+			gtk_widget_set_sensitive(c->underline,
+						 ((font_options & OPT_FONT_UNDERLINE)) ? FALSE : TRUE);
+
+		if (c->strike)
+			gtk_widget_set_sensitive(c->strike,
+						 ((font_options & OPT_FONT_STRIKE)) ? FALSE : TRUE);
+
+		cnv = cnv->next;
+	}
+}
+
+/*
+void update_transparency()
+{
+	GList *cnv = conversations;
+	struct conversation *c;
+
+        This func should be uncalled!
+
+	while(cnv) {
+		c = (struct conversation *)cnv->data;
+
+		if (c->text)
+			gtk_html_set_transparent(GTK_HTML(c->text),
+        						  (transparent) ? TRUE : FALSE);
+
+		cnv = cnv->next;
+	}
+}
+*/
+
+
+/*------------------------------------------------------------------------*/
+/*  Callbacks                                                             */
+/*------------------------------------------------------------------------*/
+
+void toggle_loggle(GtkWidget *loggle, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (find_log_info(c->name))
+		 rm_log(find_log_info(c->name));
+	else if (GTK_TOGGLE_BUTTON(loggle)->active)
+		show_log_dialog(c);
+	else
+		cancel_log(NULL, c);
+}
+
+static void do_save_convo(GtkObject *obj, GtkWidget *wid)
+{
+	struct conversation *c = gtk_object_get_user_data(obj);
+	char *filename = gtk_file_selection_get_filename(GTK_FILE_SELECTION(wid));
+	FILE *f;
+	if (file_is_dir(filename, wid))
+		return;
+	if ((!c->is_chat && g_list_find(conversations, c)) ||
+	    (c->is_chat && g_slist_find(connections, c->gc) && g_slist_find(c->gc->buddy_chats, c)))
+		filename = g_strdup(filename);
+	else
+		filename = NULL;
+	gtk_widget_destroy(wid);
+	if (!filename)
+		return;
+	f = fopen(filename, "w+");
+	g_free(filename);
+	if (!f)
+		return;
+	fprintf(f, "%s", c->history->str);
+	fclose(f);
+}
+
+void save_convo(GtkWidget *save, struct conversation *c)
+{
+	char buf[BUF_LONG];
+	GtkWidget *window = gtk_file_selection_new(_("Gaim - Save Conversation"));
+	g_snprintf(buf, sizeof(buf), "%s/%s.log", g_get_home_dir(), normalize(c->name));
+	gtk_file_selection_set_filename(GTK_FILE_SELECTION(window), buf);
+	gtk_object_set_user_data(GTK_OBJECT(GTK_FILE_SELECTION(window)->ok_button), c);
+	gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(window)->ok_button),
+			   "clicked", GTK_SIGNAL_FUNC(do_save_convo), window);
+	gtk_signal_connect_object(GTK_OBJECT(GTK_FILE_SELECTION(window)->cancel_button),
+				  "clicked", GTK_SIGNAL_FUNC(gtk_widget_destroy), (gpointer)window);
+	gtk_widget_show(window);
+}
+
+static void do_insert_image(GtkObject *obj, GtkWidget *wid)
+{
+	struct conversation *c = gtk_object_get_user_data(obj);
+	char *name = gtk_file_selection_get_filename(GTK_FILE_SELECTION(wid));
+	char *filename;
+	int pos;
+	char buf[512];
+	struct stat st;
+	int id = g_slist_length(c->images) + 1;
+	
+	if (file_is_dir(name, wid))
+		return;
+	if ((!c->is_chat && g_list_find(conversations, c)))
+		name = g_strdup(name);
+	else
+		name = NULL;
+	gtk_widget_destroy(wid);
+	if (!name)
+		return;
+
+	if (stat(name, &st) != 0) {
+		debug_printf("Could not stat %s\n", name);
+		return;
+	}
+	
+	filename = name;
+	while (strchr(filename, '/')) 
+		filename = strchr(filename, '/') + 1;
+		
+	g_snprintf(buf, sizeof(buf),
+		   "<IMG SRC=\"file://%s\" ID=\"%d\" DATASIZE=\"%d\">",
+		   filename, id, (int)st.st_size);
+	
+	c->images = g_slist_append(c->images, g_strdup(name));
+
+	if (GTK_OLD_EDITABLE(c->entry)->has_selection) {
+		int finish = GTK_OLD_EDITABLE(c->entry)->selection_end_pos;
+		gtk_editable_insert_text(GTK_EDITABLE(c->entry),
+					 buf, strlen(buf), &finish);
+	} else {
+		pos = GTK_OLD_EDITABLE(c->entry)->current_pos;
+		gtk_editable_insert_text(GTK_EDITABLE(c->entry),
+					 buf, strlen(buf), &pos);
+	}
+	g_free(name);
+}
+
+void insert_image(GtkWidget *save, struct conversation *c)
+{
+	char buf[BUF_LONG];
+	GtkWidget *window = gtk_file_selection_new(_("Gaim - Insert Image"));
+	g_snprintf(buf, sizeof(buf), "%s/", g_get_home_dir());
+	gtk_file_selection_set_filename(GTK_FILE_SELECTION(window), buf);
+	gtk_object_set_user_data(GTK_OBJECT(GTK_FILE_SELECTION(window)->ok_button), c);
+	gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(window)->ok_button),
+			   "clicked", GTK_SIGNAL_FUNC(do_insert_image), window);
+	gtk_signal_connect_object(GTK_OBJECT(GTK_FILE_SELECTION(window)->cancel_button),
+				  "clicked", GTK_SIGNAL_FUNC(gtk_widget_destroy), (gpointer)window);
+	gtk_widget_show(window);
+}
+
+
+void insert_smiley(GtkWidget *smiley, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(smiley)->active)
+		show_smiley_dialog(c, smiley);
+	else if (c->smiley_dialog)
+		close_smiley_dialog(smiley, c);
+
+	return;
+}
+
+int close_callback(GtkWidget *widget, struct conversation *c)
+{
+	if (c->is_chat && (widget == c->close) && !(chat_options & OPT_CHAT_ONE_WINDOW)) {
+		GtkWidget *tmp = c->window;
+		debug_printf("chat clicked close button\n");
+		c->window = NULL;
+		gtk_widget_destroy(tmp);
+		return FALSE;
+	}
+
+	debug_printf("conversation close callback\n");
+
+	if (convo_options & OPT_CONVO_CHECK_SPELLING)
+		gtkspell_detach(GTK_TEXT(c->entry));
+
+	if (!c->is_chat) {
+		GSList *cn = connections;
+		while (cn) {
+			struct gaim_connection *gc = cn->data;
+			cn = cn->next;
+			if (gc->prpl->convo_closed)
+				gc->prpl->convo_closed(gc, c->name);
+		}
+		remove_icon(c);
+		remove_checkbox(c);
+		if (im_options & OPT_IM_ONE_WINDOW) {
+			if ((g_list_length(conversations) > 1) ||
+					((convo_options & OPT_CONVO_COMBINE) &&
+					 (chat_options & OPT_CHAT_ONE_WINDOW) && chats)) {
+				gtk_notebook_remove_page(GTK_NOTEBOOK(convo_notebook),
+							 g_list_index(conversations, c));
+			} else {
+				if (c->window)
+					gtk_widget_destroy(c->window);
+				c->window = NULL;
+				all_convos = NULL;
+				convo_notebook = NULL;
+				if (convo_options & OPT_CONVO_COMBINE) {
+					all_chats = NULL;
+					chat_notebook = NULL;
+				}
+			}
+		} else {
+			if (c->window)
+				gtk_widget_destroy(c->window);
+			c->window = NULL;
+		}
+	} else {
+		if (chat_options & OPT_CHAT_ONE_WINDOW) {
+			if ((convo_options & OPT_CONVO_COMBINE) && (im_options & OPT_IM_ONE_WINDOW)
+					&& (conversations || chats->next)) {
+				gtk_notebook_remove_page(GTK_NOTEBOOK(chat_notebook),
+							 g_list_index(chats, c) +
+								g_list_length(conversations));
+			} else if (g_list_length(chats) > 1) {
+				gtk_notebook_remove_page(GTK_NOTEBOOK(chat_notebook),
+							 g_list_index(chats, c));
+			} else {
+				if (c->window)
+					gtk_widget_destroy(c->window);
+				c->window = NULL;
+				all_chats = NULL;
+				chat_notebook = NULL;
+				if (convo_options & OPT_CONVO_COMBINE) {
+					all_convos = NULL;
+					convo_notebook = NULL;
+				}
+			}
+		} else {
+			if (c->window)
+				gtk_widget_destroy(c->window);
+			c->window = NULL;
+		}
+	}
+
+	if (c->fg_color_dialog)
+		gtk_widget_destroy(c->fg_color_dialog);
+	c->fg_color_dialog = NULL;
+	if (c->bg_color_dialog)
+		gtk_widget_destroy(c->bg_color_dialog);
+	c->bg_color_dialog = NULL;
+	if (c->font_dialog)
+		gtk_widget_destroy(c->font_dialog);
+	c->font_dialog = NULL;
+	if (c->smiley_dialog)
+		gtk_widget_destroy(c->smiley_dialog);
+	c->smiley_dialog = NULL;
+	if (c->link_dialog)
+		gtk_widget_destroy(c->link_dialog);
+	c->link_dialog = NULL;
+	if (c->log_dialog)
+		gtk_widget_destroy(c->log_dialog);
+	c->log_dialog = NULL;
+
+	if (c->is_chat) {
+		chats = g_list_remove(chats, c);
+		if (c->gc)
+			serv_chat_leave(c->gc, c->id);
+		else
+			delete_chat(c);
+	} else {
+		delete_conversation(c);
+	}
+
+	return TRUE;
+}
+
+void set_font_face(char *newfont, struct conversation *c)
+{
+	char *pre_fontface;
+	int i, j = 0, k = 0;
+
+
+	sprintf(c->fontxfld, "%s", newfont && *newfont ? newfont : DEFAULT_FONT_XFLD);
+	for (i = 0; i < strlen(c->fontxfld); i++) {
+		if (c->fontxfld[i] == '-') {
+			if (++j > 2)
+				break;
+		} else if (j == 2)
+			c->fontface[k++] = c->fontxfld[i];
+	}
+	c->fontface[k] = '\0';
+	c->hasfont = 1;
+
+	pre_fontface = g_strconcat("<FONT FACE=\"", c->fontface, "\">", NULL);
+	surround(c->entry, pre_fontface, "</FONT>");
+	gtk_widget_grab_focus(c->entry);
+	g_free(pre_fontface);
+}
+
+gint delete_all_convo(GtkWidget *w, GdkEventAny *e, gpointer d)
+{
+	if (w == all_convos) {
+		while (conversations) {
+			struct conversation *c = conversations->data;
+			close_callback(c->close, c);
+		}
+	}
+	if (w == all_chats) {
+		while (chats) {
+			struct conversation *c = chats->data;
+			close_callback(c->close, c);
+		}
+	}
+	return FALSE;
+}
+
+static gint delete_event_convo(GtkWidget *w, GdkEventAny *e, struct conversation *c)
+{
+	delete_conversation(c);
+	return FALSE;
+}
+
+void add_callback(GtkWidget *widget, struct conversation *c)
+{
+	struct buddy *b = find_buddy(c->gc, c->name);
+	if (b) {
+		show_confirm_del(c->gc, c->name);
+	} else if (c->gc)
+		show_add_buddy(c->gc, c->name, NULL, NULL);
+
+	gtk_widget_grab_focus(c->entry);
+}
+
+
+void block_callback(GtkWidget *widget, struct conversation *c)
+{
+	if (c->gc)
+		show_add_perm(c->gc, c->name, FALSE);
+	gtk_widget_grab_focus(c->entry);
+}
+
+void warn_callback(GtkWidget *widget, struct conversation *c)
+{
+	show_warn_dialog(c->gc, c->name);
+	gtk_widget_grab_focus(c->entry);
+}
+
+void info_callback(GtkWidget *w, struct conversation *c)
+{
+	if (c->is_chat) {
+		char *name;
+		GList *i;
+
+		i = GTK_LIST(c->list)->selection;
+		if (i) {
+			name = (char *)gtk_object_get_user_data(GTK_OBJECT(i->data));
+		} else {
+			return;
+		}
+
+		serv_get_info(c->gc, name);
+	} else {
+		serv_get_info(c->gc, c->name);
+		gtk_widget_grab_focus(c->entry);
+	}
+}
+
+static void move_next_tab(GtkNotebook *notebook, gboolean chat)
+{
+	int currpage = gtk_notebook_get_current_page(notebook);
+	int convlen;
+	GList *cnv;
+	struct conversation *d = NULL;
+
+	if ((convo_options & OPT_CONVO_COMBINE) &&
+	    (im_options & OPT_IM_ONE_WINDOW) &&
+	    (chat_options & OPT_CHAT_ONE_WINDOW))
+		convlen = g_list_length(conversations);
+	else
+		convlen = 0;
+
+	if (chat) {
+		/* if chat, find next unread chat */
+		cnv = g_list_nth(chats, currpage - convlen);
+		while (cnv) {
+			d = cnv->data;
+			if (d->unseen > 0)
+				break;
+			cnv = cnv->next;
+			d = NULL;
+		}
+		if (d) {
+			gtk_notebook_set_page(notebook, convlen + g_list_index(chats, d));
+			return;
+		}
+	} else {
+		/* else find next unread convo */
+		cnv = g_list_nth(conversations, currpage);
+		while (cnv) {
+			d = cnv->data;
+			if (d->unseen > 0)
+				break;
+			cnv = cnv->next;
+			d = NULL;
+		}
+		if (d) {
+			gtk_notebook_set_page(notebook, g_list_index(conversations, d));
+			return;
+		}
+	}
+
+	if (convo_options & OPT_CONVO_COMBINE) {
+		if (chat && (im_options & OPT_IM_ONE_WINDOW)) {
+			/* if chat find next unread convo */
+			cnv = conversations;
+			while (cnv) {
+				d = cnv->data;
+				if (d->unseen > 0)
+					break;
+				cnv = cnv->next;
+				d = NULL;
+			}
+			if (d) {
+				gtk_notebook_set_page(notebook, g_list_index(conversations, d));
+				return;
+			}
+		} else if (!chat && (chat_options & OPT_CHAT_ONE_WINDOW)) {
+			/* else find next unread chat */
+			cnv = chats;
+			while (cnv) {
+				d = cnv->data;
+				if (d->unseen > 0)
+					break;
+				cnv = cnv->next;
+				d = NULL;
+			}
+			if (d) {
+				gtk_notebook_set_page(notebook, convlen + g_list_index(chats, d));
+				return;
+			}
+		}
+	}
+
+	if (chat) {
+		/* if chat find first unread chat */
+		cnv = chats;
+		while (cnv) {
+			d = cnv->data;
+			if (d->unseen > 0)
+				break;
+			cnv = cnv->next;
+			d = NULL;
+		}
+		if (d) {
+			gtk_notebook_set_page(notebook, convlen + g_list_index(chats, d));
+			return;
+		}
+	} else {
+		/* else find first unread convo */
+		cnv = conversations;
+		while (cnv) {
+			d = cnv->data;
+			if (d->unseen > 0)
+				break;
+			cnv = cnv->next;
+			d = NULL;
+		}
+		if (d) {
+			gtk_notebook_set_page(notebook, g_list_index(conversations, d));
+			return;
+		}
+	}
+
+	/* go to next page */
+	if (currpage + 1 == g_list_length(notebook->children))
+		gtk_notebook_set_page(notebook, 0);
+	else
+		gtk_notebook_next_page(notebook);
+}
+
+gboolean keypress_callback(GtkWidget *entry, GdkEventKey * event, struct conversation *c)
+{
+	int pos;
+	if (event->keyval == GDK_Escape) {
+		if (convo_options & OPT_CONVO_ESC_CAN_CLOSE) {
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			close_callback(c->close, c);
+			c = NULL;
+		}
+	} else if (event->keyval == GDK_Page_Up) {
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+		gtk_imhtml_page_up(GTK_IMHTML(c->text));
+	} else if (event->keyval == GDK_Page_Down) {
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+		gtk_imhtml_page_down(GTK_IMHTML(c->text));
+	} else if ((event->keyval == GDK_F2) && (convo_options & OPT_CONVO_F2_TOGGLES)) {
+		gtk_imhtml_show_comments(GTK_IMHTML(c->text), !GTK_IMHTML(c->text)->comments);
+	} else if ((event->keyval == GDK_Return) || (event->keyval == GDK_KP_Enter)) {
+		if ((event->state & GDK_CONTROL_MASK) && (convo_options & OPT_CONVO_CTL_ENTER)) {
+			gtk_signal_emit_by_name(GTK_OBJECT(entry), "activate", c);
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			return TRUE;
+		} else if (!(event->state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) && (convo_options & OPT_CONVO_ENTER_SENDS)) {
+			gtk_signal_emit_by_name(GTK_OBJECT(entry), "activate", c);
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			return TRUE;
+		} else {
+			int oldpos;
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			oldpos = pos = gtk_editable_get_position(GTK_EDITABLE(entry));
+			gtk_editable_insert_text(GTK_EDITABLE(entry), "\n", 1, &pos);
+			if (oldpos == pos)
+				gtk_editable_set_position(GTK_EDITABLE(entry), pos + 1);
+			return TRUE;
+		}
+	} else if ((event->state & GDK_CONTROL_MASK) && (event->keyval == 'm')) {
+		int oldpos;
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+		oldpos = pos = gtk_editable_get_position(GTK_EDITABLE(entry));
+		gtk_editable_insert_text(GTK_EDITABLE(entry), "\n", 1, &pos);
+		if (oldpos == pos)
+			gtk_editable_set_position(GTK_EDITABLE(entry), pos + 1);
+	} else if (event->state & GDK_CONTROL_MASK) {
+		int pos = 0;
+		switch (event->keyval) {
+		case GDK_Up:
+			if (!c->send_history)
+				break;
+			if (!c->send_history->prev) {
+				if (c->send_history->data)
+					g_free(c->send_history->data);
+				c->send_history->data = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+			} 
+			if (c->send_history->next && c->send_history->next->data) {
+				c->send_history = c->send_history->next;
+				gtk_editable_delete_text (GTK_EDITABLE(entry),0,-1);
+				gtk_editable_insert_text(GTK_EDITABLE(entry), 
+							 c->send_history->data, 
+							 strlen(c->send_history->data),
+							 &pos);
+			}
+			
+			break;
+		case GDK_Down:
+		  if (!c->send_history) 
+				break;
+			if (c->send_history->prev) {
+			  c->send_history = c->send_history->prev;
+				if (c->send_history->data) {
+					gtk_editable_delete_text (GTK_EDITABLE(entry),0,-1);
+					gtk_editable_insert_text (GTK_EDITABLE(entry), c->send_history->data, 
+								  strlen(c->send_history->data), &pos);
+				
+				}
+			}
+			break;
+		}
+		if (convo_options & OPT_CONVO_CTL_CHARS) {
+			switch (event->keyval) {
+			case 'i':
+			case 'I':
+				quiet_set(c->italic,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->italic)));
+				do_italic(c->italic, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case 'u':	/* ctl-u is GDK_Clear, which clears the line */
+			case 'U':
+				quiet_set(c->underline,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON
+									(c->underline)));
+				do_underline(c->underline, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case 'b':	/* ctl-b is GDK_Left, which moves backwards */
+			case 'B':
+				quiet_set(c->bold,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->bold)));
+				do_bold(c->bold, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case 's':
+			case 'S':
+				quiet_set(c->strike,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->strike)));
+				do_strike(c->strike, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			
+			case '-':
+				do_small(NULL, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case '=':
+			case '+':
+				do_big(NULL, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;	
+			case '0':
+				do_normal(NULL, c->entry);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case 'f':
+			case 'F':
+				quiet_set(c->font,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->font)));
+				toggle_font(c->font, c);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			case 'c':
+			case 'C':
+				quiet_set(c->fgcolorbtn,
+					  !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->fgcolorbtn)));
+				toggle_fg_color(c->fgcolorbtn, c);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				break;
+			}
+		}
+		if (convo_options & OPT_CONVO_CTL_SMILEYS) {
+			char buf[7];
+			buf[0] = '\0';
+			switch (event->keyval) {
+			case '1':
+				sprintf(buf, ":-)");
+				break;
+			case '2':
+				sprintf(buf, ":-(");
+				break;
+			case '3':
+				sprintf(buf, ";-)");
+				break;
+			case '4':
+				sprintf(buf, ":-P");
+				break;
+			case '5':
+				sprintf(buf, "=-O");
+				break;
+			case '6':
+				sprintf(buf, ":-*");
+				break;
+			case '7':
+				sprintf(buf, ">:o");
+				break;
+			case '8':
+				sprintf(buf, "8-)");
+				break;
+			case '!':
+				sprintf(buf, ":-$");
+				break;
+			case '@':
+				sprintf(buf, ":-!");
+				break;
+			case '#':
+				sprintf(buf, ":-[");
+				break;
+			case '$':
+				sprintf(buf, "O:-)");
+				break;
+			case '%':
+				sprintf(buf, ":-/");
+				break;
+			case '^':
+				sprintf(buf, ":'(");
+				break;
+			case '&':
+				sprintf(buf, ":-X");
+				break;
+			case '*':
+				sprintf(buf, ":-D");
+				break;
+			}
+			if (buf[0]) {
+				if (GTK_OLD_EDITABLE(c->entry)->has_selection) {
+					int finish = GTK_OLD_EDITABLE(c->entry)->selection_end_pos;
+					gtk_editable_insert_text(GTK_EDITABLE(c->entry),
+								 buf, strlen(buf), &finish);
+				} else {
+					pos = GTK_OLD_EDITABLE(c->entry)->current_pos;
+					gtk_editable_insert_text(GTK_EDITABLE(c->entry),
+								 buf, strlen(buf), &pos);
+				}
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			}
+		}
+		if (event->keyval == 'l') {
+			gtk_imhtml_clear(GTK_IMHTML(c->text));
+			g_string_free(c->history, TRUE);
+			c->history = g_string_new("");
+		} else if ((event->keyval == 'w') && (convo_options & OPT_CONVO_CTL_W_CLOSES)) {
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			close_callback(c->close, c);
+			c = NULL;
+			return TRUE;
+		} else if (event->keyval == 'n') {
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			show_im_dialog();
+		} else if (event->keyval == 'z') {
+			gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			XIconifyWindow(GDK_DISPLAY(),
+				       GDK_WINDOW_XWINDOW(c->window->window),
+				       ((_XPrivDisplay)GDK_DISPLAY())->default_screen);		     
+		}
+		
+
+		if ((!c->is_chat && (im_options & OPT_IM_ONE_WINDOW)) ||
+		    (c->is_chat && (chat_options & OPT_CHAT_ONE_WINDOW))) {
+			GtkWidget *notebook = (c->is_chat ? chat_notebook : convo_notebook);
+			if (event->keyval == '[') {
+				gtk_notebook_prev_page(GTK_NOTEBOOK(notebook));
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			} else if (event->keyval == ']') {
+				gtk_notebook_next_page(GTK_NOTEBOOK(notebook));
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+			} else if (event->keyval == GDK_Tab) {
+				move_next_tab(GTK_NOTEBOOK(notebook), c->is_chat);
+				gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+				return TRUE;
+			}
+		}
+	} else if ((event->keyval == GDK_Tab) && c->is_chat && (chat_options & OPT_CHAT_TAB_COMPLETE)) {
+	        tab_complete(c);
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+		return TRUE;
+	} else if (((!c->is_chat && (im_options & OPT_IM_ONE_WINDOW)) ||
+		    (c->is_chat && (chat_options & OPT_CHAT_ONE_WINDOW))) &&
+		   (event->state & GDK_MOD1_MASK) && (event->keyval > '0') && (event->keyval <= '9')) {
+		GtkWidget *notebook = (c->is_chat ? chat_notebook : convo_notebook);
+		gtk_notebook_set_page(GTK_NOTEBOOK(notebook), event->keyval - '1');
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(entry), "key_press_event");
+	}
+
+	if (c && (!(misc_options & OPT_MISC_STEALTH_TYPING)) && !c->is_chat) {
+		char *txt = gtk_editable_get_chars(GTK_EDITABLE(c->entry), 0, -1);
+		if ((strlen(txt) == 0  && event->keyval < 256 && isprint(event->keyval)) ||
+		    (c->type_again != 0 && time(NULL) > c->type_again)) {
+			int timeout = serv_send_typing(c->gc, c->name, TRUE);
+			if (timeout)
+				c->type_again = time(NULL) + timeout;
+			else
+				c->type_again = 0;
+		}
+		else if (strlen(txt) == 1) {
+			if ((GTK_OLD_EDITABLE(c->entry)->current_pos == 1 && event->keyval == GDK_BackSpace) ||
+			    (GTK_OLD_EDITABLE(c->entry)->current_pos == 0 && event->keyval == GDK_Delete))
+				serv_send_typing(c->gc, c->name, FALSE);
+		} else if (GTK_OLD_EDITABLE(c->entry)->selection_start_pos == 0) {
+			if (GTK_OLD_EDITABLE(c->entry)->selection_end_pos == strlen(txt) &&
+			    (event->keyval == GDK_BackSpace || event->keyval == GDK_Delete))
+				serv_send_typing(c->gc, c->name, FALSE);
+		}
+		g_free(txt);
+	}
+	return FALSE;
+}
+
+
+void send_callback(GtkWidget *widget, struct conversation *c)
+{
+	char *buf, *buf2;
+	int limit;
+	gulong length=0;
+	int err = 0;
+	GList *first;
+
+	if (!c->gc)
+		return;
+
+
+	buf2 = gtk_editable_get_chars(GTK_EDITABLE(c->entry), 0, -1);
+	limit = 32 * 1024;	/* you shouldn't be sending more than 32k in your messages. that's a book. */
+	buf = g_malloc(limit);
+	g_snprintf(buf, limit, "%s", buf2);
+	g_free(buf2);
+	if (!strlen(buf)) {
+		g_free(buf);
+		return;
+	}
+
+	first = g_list_first(c->send_history);
+	if (first->data)
+		g_free(first->data);
+	first->data = g_strdup(buf);
+	c->send_history = g_list_prepend(first, NULL);
+	
+	buf2 = g_malloc(limit);
+
+	if (c->gc->flags & OPT_CONN_HTML) {
+		if (convo_options & OPT_CONVO_SEND_LINKS)
+			linkify_text(buf);
+
+		if (font_options & OPT_FONT_BOLD) {
+			g_snprintf(buf2, limit, "<B>%s</B>", buf);
+			strcpy(buf, buf2);
+		}
+
+		if (font_options & OPT_FONT_ITALIC) {
+			g_snprintf(buf2, limit, "<I>%s</I>", buf);
+			strcpy(buf, buf2);
+		}
+
+		if (font_options & OPT_FONT_UNDERLINE) {
+			g_snprintf(buf2, limit, "<U>%s</U>", buf);
+			strcpy(buf, buf2);
+		}
+
+		if (font_options & OPT_FONT_STRIKE) {
+			g_snprintf(buf2, limit, "<STRIKE>%s</STRIKE>", buf);
+			strcpy(buf, buf2);
+		}
+
+		if ((font_options & OPT_FONT_FACE) || c->hasfont) {
+			g_snprintf(buf2, limit, "<FONT FACE=\"%s\">%s</FONT>", c->fontface, buf);
+			strcpy(buf, buf2);
+		}
+
+		if (font_options & OPT_FONT_SIZE) {
+			g_snprintf(buf2, limit, "<FONT SIZE=\"%d\">%s</FONT>", fontsize, buf);
+			strcpy(buf, buf2);
+		}
+
+		if ((font_options & OPT_FONT_FGCOL) || c->hasfg) {
+			g_snprintf(buf2, limit, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", c->fgcol.red,
+				   c->fgcol.green, c->fgcol.blue, buf);
+			strcpy(buf, buf2);
+		}
+
+		if ((font_options & OPT_FONT_BGCOL) || c->hasbg) {
+			g_snprintf(buf2, limit, "<BODY BGCOLOR=\"#%02X%02X%02X\">%s</BODY>",
+				   c->bgcol.red, c->bgcol.green, c->bgcol.blue, buf);
+			strcpy(buf, buf2);
+		}
+	}
+
+	quiet_set(c->bold, FALSE);
+	quiet_set(c->strike, FALSE);
+	quiet_set(c->italic, FALSE);
+	quiet_set(c->underline, FALSE);
+	quiet_set(c->font, FALSE);
+	quiet_set(c->fgcolorbtn, FALSE);
+	quiet_set(c->bgcolorbtn, FALSE);
+	quiet_set(c->link, FALSE);
+	gtk_widget_grab_focus(c->entry);
+
+	{
+		char *buffy = g_strdup(buf);
+		enum gaim_event evnt = c->is_chat ? event_chat_send : event_im_send;
+		int plugin_return = plugin_event(evnt, c->gc,
+						 c->is_chat ? (void *)c->id : c->name,
+						 &buffy, 0);
+		if (!buffy) {
+			g_free(buf2);
+			g_free(buf);
+			return;
+		}
+		if (plugin_return) {
+			gtk_editable_delete_text(GTK_EDITABLE(c->entry), 0, -1);
+			g_free(buffy);
+			g_free(buf2);
+			g_free(buf);
+			return;
+		}
+		g_snprintf(buf, limit, "%s", buffy);
+		g_free(buffy);
+	}
+	
+	if (!c->is_chat) {
+		char *buffy;
+		gboolean binary = FALSE;
+
+		buffy = g_strdup(buf);
+		plugin_event(event_im_displayed_sent, c->gc, c->name, &buffy, 0);
+		if (buffy) {
+			int imflags = 0;
+			if (c->check && gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(c->check)))
+				imflags = IM_FLAG_CHECKBOX;
+			
+			if (c->images) {
+				int id = 0, offset = 0;
+				char *bigbuf = NULL;
+				GSList *tmplist = c->images;
+				id = 1;
+				
+				while (tmplist) {
+					FILE *imgfile;
+					char *filename;
+					struct stat st;
+					char imgtag[1024];
+	
+					if (stat(tmplist->data, &st) != 0) {
+						debug_printf("Could not stat %s\n", tmplist->data);
+						tmplist = tmplist->next;
+						continue;
+					}
+								
+					/* Here we check to make sure the user still wants to send the
+					 * image.  He may have deleted the <img> tag in which case we
+					 * don't want to send the binary data. */
+					filename = tmplist->data;
+					while (strchr(filename, '/')) 
+						filename = strchr(filename, '/') + 1;
+					g_snprintf(imgtag, sizeof(imgtag),
+						   "<IMG SRC=\"file://%s\" ID=\"%d\" DATASIZE=\"%d\">",
+						   filename, id, (int)st.st_size);
+				       	
+					if (strstr(buffy, imgtag) == 0) {
+						debug_printf("Not sending image: %s\n", tmplist->data);
+						tmplist = tmplist->next;
+						continue;
+					}
+					if (!binary) {
+						length = strlen(buffy) + strlen("<BINARY></BINARY>");
+						bigbuf = g_malloc(length + 1);
+						g_snprintf(bigbuf, strlen(buffy) + strlen("<BINARY> ") + 1,
+							   "%s<BINARY>", buffy);
+						offset = strlen(buffy) + strlen("<BINARY>");
+						binary = TRUE;
+					}
+					g_snprintf(imgtag, sizeof(imgtag),
+						   "<DATA ID=\"%d\" SIZE=\"%d\">",
+						   id, (int)st.st_size);
+					
+					length = length + strlen(imgtag) + st.st_size + strlen("</DATA>");;
+					bigbuf = g_realloc(bigbuf, length + 1);
+					if (!(imgfile = fopen(tmplist->data, "r"))) {
+						debug_printf("Could not open %s\n", tmplist->data);
+						tmplist = tmplist->next;
+						continue;
+					}
+					g_snprintf(bigbuf + offset, strlen(imgtag) + 1, "%s", imgtag);
+					offset = offset + strlen(imgtag);
+					offset = offset + fread(bigbuf + offset, 1, st.st_size, imgfile);
+					fclose(imgfile);
+					g_snprintf(bigbuf + offset, strlen("</DATA>") + 1, "</DATA>");
+					offset= offset + strlen("</DATA>");
+					id++;
+					tmplist = tmplist->next;
+				}
+				if (binary) {
+					g_snprintf(bigbuf + offset, strlen("</BINARY>") + 1, "</BINARY>"); 
+					err =serv_send_im(c->gc, c->name, bigbuf, length, imflags);
+				} else {
+					err = serv_send_im(c->gc, c->name, buffy, -1, imflags);
+				}					
+				if (err > 0) {
+					GSList *tempy = c->images;
+					while (tempy) {
+						g_free(tempy->data);
+						tempy = tempy->next;
+					}
+					g_slist_free(tempy);
+					c->images = NULL;
+					if (binary)
+						write_to_conv(c, bigbuf, WFLAG_SEND, NULL, time(NULL), length);
+					else
+						write_to_conv(c, buffy, WFLAG_SEND, NULL, time(NULL), -1);
+					if (c->makesound)
+						play_sound(SND_SEND);
+					if (im_options & OPT_IM_POPDOWN)
+						gtk_widget_hide(c->window);
+					
+					
+				}
+				if (binary)
+					g_free(bigbuf);
+			} else {
+				err =serv_send_im(c->gc, c->name, buffy, -1, imflags);
+				if (err > 0) { 
+					write_to_conv(c, buf, WFLAG_SEND, NULL, time(NULL), -1);
+					if (c->makesound)
+						play_sound(SND_SEND);
+					if (im_options & OPT_IM_POPDOWN)
+						gtk_widget_hide(c->window);
+				}
+			}
+			g_free(buffy);
+		}
+		
+	} else {
+		err = serv_chat_send(c->gc, c->id, buf);
+
+		/* no sound because we do that when we receive our message */
+	}
+
+	g_free(buf2);
+	g_free(buf);
+
+	if (err < 0) {
+		if (err == -E2BIG)
+			do_error_dialog(_("Unable to send message: too large"), _("Message Error"));
+		else if (err == -ENOTCONN)
+			debug_printf("Not yet connected\n");
+		else
+			do_error_dialog(_("Unable to send message: Unknown reason"), _("Message Error"));
+	} else {
+		gtk_editable_delete_text(GTK_EDITABLE(c->entry), 0, -1);
+
+		if ((err > 0) && (away_options & OPT_AWAY_BACK_ON_IM)) {
+			if (awaymessage != NULL) {
+				do_im_back();
+			} else if (c->gc->away) {
+				serv_set_away(c->gc, GAIM_AWAY_CUSTOM, NULL);
+			}
+		}
+	}
+}
+
+int entry_key_pressed(GtkWidget *w, GtkWidget *entry)
+{
+	check_everything(w);
+	return FALSE;
+}
+
+/*------------------------------------------------------------------------*/
+/*  HTML-type stuff                                                       */
+/*------------------------------------------------------------------------*/
+
+int count_tag(GtkWidget *entry, char *s1, char *s2)
+{
+	char *p1, *p2;
+	int res = 0;
+	char *tmp, *tmpo, h;
+	tmpo = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+	h = tmpo[GTK_OLD_EDITABLE(entry)->current_pos];
+	tmpo[GTK_OLD_EDITABLE(entry)->current_pos] = '\0';
+	tmp = tmpo;
+	do {
+		p1 = strstr(tmp, s1);
+		p2 = strstr(tmp, s2);
+		if (p1 && p2) {
+			if (p1 < p2) {
+				res = 1;
+				tmp = p1 + strlen(s1);
+			} else if (p2 < p1) {
+				res = 0;
+				tmp = p2 + strlen(s2);
+			}
+		} else {
+			if (p1) {
+				res = 1;
+				tmp = p1 + strlen(s1);
+			} else if (p2) {
+				res = 0;
+				tmp = p2 + strlen(s2);
+			}
+		}
+	} while (p1 || p2);
+	tmpo[GTK_OLD_EDITABLE(entry)->current_pos] = h;
+	g_free(tmpo);
+	return res;
+}
+
+
+int invert_tags(GtkWidget *entry, char *s1, char *s2, int really)
+{
+	int start = GTK_OLD_EDITABLE(entry)->selection_start_pos;
+	int finish = GTK_OLD_EDITABLE(entry)->selection_end_pos;
+	char *s;
+
+	s = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+	if (!g_strncasecmp(&s[start], s1, strlen(s1)) &&
+	    !g_strncasecmp(&s[finish - strlen(s2)], s2, strlen(s2))) {
+		if (really) {
+			gtk_editable_delete_text(GTK_EDITABLE(entry), start, start + strlen(s1));
+			gtk_editable_delete_text(GTK_EDITABLE(entry), finish - strlen(s2) - strlen(s1),
+						 finish - strlen(s1));
+		}
+		g_free(s);
+		return 1;
+	}
+	g_free(s);
+	return 0;
+}
+
+
+void remove_tags(GtkWidget *entry, char *tag)
+{
+	char *s, *t;
+	int start = GTK_OLD_EDITABLE(entry)->selection_start_pos;
+	int finish = GTK_OLD_EDITABLE(entry)->selection_end_pos;
+	int temp;
+	s = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+	t = s;
+
+	if (start > finish) {
+		temp = start;
+		start = finish;
+		finish = temp;
+	}
+
+	if (strstr(tag, "<FONT SIZE=")) {
+		while ((t = strstr(t, "<FONT SIZE="))) {
+			if (((t - s) < finish) && ((t - s) >= start)) {
+				gtk_editable_delete_text(GTK_EDITABLE(entry), (t - s),
+							 (t - s) + strlen(tag));
+				g_free(s);
+				s = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+				t = s;
+			} else
+				t++;
+		}
+	} else {
+		while ((t = strstr(t, tag))) {
+			if (((t - s) < finish) && ((t - s) >= start)) {
+				gtk_editable_delete_text(GTK_EDITABLE(entry), (t - s),
+							 (t - s) + strlen(tag));
+				g_free(s);
+				s = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+				t = s;
+			} else
+				t++;
+		}
+	}
+	g_free(s);
+}
+
+static char *html_logize(char *p)
+{
+
+	char *temp_p = p;
+	char *buffer_p;
+	char *buffer_start;
+	int num_cr = 0;
+	int char_len = 0;
+
+	while (*temp_p != '\0') {
+		char_len++;
+		if ((*temp_p == '\n') || ((*temp_p == '<') && (*(temp_p + 1) == '!')))
+			num_cr++;
+		++temp_p;
+	}
+
+	temp_p = p;
+	buffer_p = g_malloc(char_len + (4 * num_cr) + 1);
+	buffer_start = buffer_p;
+
+	while (*temp_p != '\0') {
+		if (*temp_p == '\n') {
+			*buffer_p++ = '<';
+			*buffer_p++ = 'B';
+			*buffer_p++ = 'R';
+			*buffer_p++ = '>';
+			*buffer_p++ = '\n';
+		} else if ((*temp_p == '<') && (*(temp_p + 1) == '!')) {
+			*buffer_p++ = '&';
+			*buffer_p++ = 'l';
+			*buffer_p++ = 't';
+			*buffer_p++ = ';';
+		} else
+			*buffer_p++ = *temp_p;
+		++temp_p;
+	}
+	*buffer_p = '\0';
+
+	return buffer_start;
+}
+
+void surround(GtkWidget *entry, char *pre, char *post)
+{
+	int temp, pos = GTK_OLD_EDITABLE(entry)->current_pos;
+	int dummy;
+	int start, finish;
+
+	if (convo_options & OPT_CONVO_CHECK_SPELLING) {
+		gtkspell_detach(GTK_TEXT(entry));
+	}
+
+	if (GTK_OLD_EDITABLE(entry)->has_selection) {
+		remove_tags(entry, pre);
+		remove_tags(entry, post);
+		start = GTK_OLD_EDITABLE(entry)->selection_start_pos;
+		finish = GTK_OLD_EDITABLE(entry)->selection_end_pos;
+		if (start > finish) {
+			dummy = finish;
+			finish = start;
+			start = dummy;
+		}
+		dummy = start;
+		gtk_editable_insert_text(GTK_EDITABLE(entry), pre, strlen(pre), &dummy);
+		dummy = finish + strlen(pre);
+		gtk_editable_insert_text(GTK_EDITABLE(entry), post, strlen(post), &dummy);
+		gtk_editable_select_region(GTK_EDITABLE(entry), start,
+					   finish + strlen(pre) + strlen(post));
+	} else {
+		temp = pos;
+		gtk_editable_insert_text(GTK_EDITABLE(entry), pre, strlen(pre), &pos);
+		if (temp == pos) {
+			dummy = pos + strlen(pre);
+			gtk_editable_insert_text(GTK_EDITABLE(entry), post, strlen(post), &dummy);
+			gtk_editable_set_position(GTK_EDITABLE(entry), dummy);
+		} else {
+			dummy = pos;
+			gtk_editable_insert_text(GTK_EDITABLE(entry), post, strlen(post), &dummy);
+			gtk_editable_set_position(GTK_EDITABLE(entry), pos);
+		}
+	}
+
+	if (convo_options & OPT_CONVO_CHECK_SPELLING) {
+		gtkspell_attach(GTK_TEXT(entry));
+	}
+
+	gtk_widget_grab_focus(entry);
+}
+
+void advance_past(GtkWidget *entry, char *pre, char *post)
+{
+	char *s, *s2;
+	int pos;
+	if (invert_tags(entry, pre, post, 1))
+		return;
+	s = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
+	pos = GTK_OLD_EDITABLE(entry)->current_pos;
+	debug_printf(_("Currently at %d, "), pos);
+	s2 = strstr(&s[pos], post);
+	if (s2) {
+		pos = s2 - s + strlen(post);
+	} else {
+		gtk_editable_insert_text(GTK_EDITABLE(entry), post, strlen(post), &pos);
+	}
+	g_free(s);
+	debug_printf(_("Setting position to %d\n"), pos);
+	gtk_editable_set_position(GTK_EDITABLE(entry), pos);
+	gtk_widget_grab_focus(entry);
+}
+
+void toggle_fg_color(GtkWidget *color, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(color)->active)
+		show_fgcolor_dialog(c, color);
+	else if (c->fg_color_dialog)
+		cancel_fgcolor(color, c);
+	else
+		advance_past(c->entry, "<FONT COLOR>", "</FONT>");
+}
+
+void toggle_bg_color(GtkWidget *color, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(color)->active)
+		show_bgcolor_dialog(c, color);
+	else if (c->bg_color_dialog)
+		cancel_bgcolor(color, c);
+	else
+		advance_past(c->entry, "<BODY BGCOLOR>", "</BODY>");
+}
+
+void toggle_font(GtkWidget *font, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(font)->active)
+		show_font_dialog(c, font);
+	else if (c->font_dialog)
+		cancel_font(font, c);
+	else
+		advance_past(c->entry, "<FONT FACE>", "</FONT>");
+}
+
+void toggle_link(GtkWidget *linky, struct conversation *c)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(linky)->active)
+		show_add_link(linky, c);
+	else if (c->link_dialog)
+		cancel_link(linky, c);
+	else
+		advance_past(c->entry, "<A HREF>", "</A>");
+}
+
+void do_strike(GtkWidget *strike, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+
+	if (GTK_TOGGLE_BUTTON(strike)->active)
+		surround(entry, "<STRIKE>", "</STRIKE>");
+	else
+		advance_past(entry, "<STRIKE>", "</STRIKE>");
+
+}
+
+void do_bold(GtkWidget *bold, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(bold)->active)
+		surround(entry, "<B>", "</B>");
+	else
+		advance_past(entry, "<B>", "</B>");
+}
+
+void do_underline(GtkWidget *underline, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(underline)->active)
+		surround(entry, "<U>", "</U>");
+	else
+		advance_past(entry, "<U>", "</U>");
+}
+
+void do_italic(GtkWidget *italic, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	if (GTK_TOGGLE_BUTTON(italic)->active)
+		surround(entry, "<I>", "</I>");
+	else
+		advance_past(entry, "<I>", "</I>");
+}
+
+/* html code to modify font sizes must all be the same length, */
+/* currently set to 15 chars */
+
+void do_small(GtkWidget *small, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	surround(entry, "<FONT SIZE=\"1\">", "</FONT>");
+}
+
+void do_normal(GtkWidget *normal, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	surround(entry, "<FONT SIZE=\"3\">", "</FONT>");
+}
+
+void do_big(GtkWidget *big, GtkWidget *entry)
+{
+	if (state_lock)
+		return;
+	surround(entry, "<FONT SIZE=\"5\">", "</FONT>");
+}
+
+void check_everything(GtkWidget *entry)
+{
+	struct conversation *c;
+
+	c = (struct conversation *)gtk_object_get_user_data(GTK_OBJECT(entry));
+	if (!c)
+		return;
+	if (invert_tags(entry, "<B>", "</B>", 0))
+		quiet_set(c->bold, TRUE);
+	else if (count_tag(entry, "<B>", "</B>"))
+		quiet_set(c->bold, TRUE);
+	else
+		quiet_set(c->bold, FALSE);
+	if (invert_tags(entry, "<I>", "</I>", 0))
+		quiet_set(c->italic, TRUE);
+	else if (count_tag(entry, "<I>", "</I>"))
+		quiet_set(c->italic, TRUE);
+	else
+		quiet_set(c->italic, FALSE);
+
+	if (invert_tags(entry, "<FONT COLOR", "</FONT>", 0))
+		quiet_set(c->fgcolorbtn, TRUE);
+	else if (count_tag(entry, "<FONT COLOR", "</FONT>"))
+		quiet_set(c->fgcolorbtn, TRUE);
+	else
+		quiet_set(c->fgcolorbtn, FALSE);
+
+	if (invert_tags(entry, "<BODY BGCOLOR", "</BODY>", 0))
+		quiet_set(c->bgcolorbtn, TRUE);
+	else if (count_tag(entry, "<BODY BGCOLOR", "</BODY>"))
+		quiet_set(c->bgcolorbtn, TRUE);
+	else
+		quiet_set(c->bgcolorbtn, FALSE);
+
+	if (invert_tags(entry, "<FONT FACE", "</FONT>", 0))
+		quiet_set(c->font, TRUE);
+	else if (count_tag(entry, "<FONT FACE", "</FONT>"))
+		quiet_set(c->font, TRUE);
+	else
+		quiet_set(c->font, FALSE);
+
+	if (invert_tags(entry, "<A HREF", "</A>", 0))
+		quiet_set(c->link, TRUE);
+	else if (count_tag(entry, "<A HREF", "</A>"))
+		quiet_set(c->link, TRUE);
+	else
+		quiet_set(c->link, FALSE);
+
+	if (invert_tags(entry, "<U>", "</U>", 0))
+		quiet_set(c->underline, TRUE);
+	else if (count_tag(entry, "<U>", "</U>"))
+		quiet_set(c->underline, TRUE);
+	else
+		quiet_set(c->underline, FALSE);
+
+	if (invert_tags(entry, "<STRIKE>", "</STRIKE>", 0))
+		quiet_set(c->strike, TRUE);
+	else if (count_tag(entry, "<STRIKE>", "</STRIKE>"))
+		quiet_set(c->strike, TRUE);
+	else
+		quiet_set(c->strike, FALSE);
+}
+
+
+/*------------------------------------------------------------------------*/
+/*  Takin care of the window..                                            */
+/*------------------------------------------------------------------------*/
+
+
+/* this is going to be interesting since the conversation could either be a
+ * normal IM conversation or a chat window. but hopefully it won't matter */
+void write_to_conv(struct conversation *c, char *what, int flags, char *who, time_t mtime, gint length)
+{
+	char buf[BUF_LONG];
+	char *str;
+	FILE *fd;
+	char colour[10];
+	struct buddy *b;
+	int gtk_font_options = 0;
+	GString *logstr;
+	char buf2[BUF_LONG];
+	char mdate[64];
+	int unhighlight = 0;
+	
+	if (c->is_chat && (!c->gc || !g_slist_find(c->gc->buddy_chats, c)))
+		return;
+
+	if (!c->is_chat && !g_list_find(conversations, c))
+		return;
+
+	gtk_widget_show(c->window);
+
+	if (!c->is_chat || !(c->gc->prpl->options & OPT_PROTO_UNIQUE_CHATNAME)) {
+		if (!who) {
+			if (flags & WFLAG_SEND) {
+				b = find_buddy(c->gc, c->gc->username);
+				if (b && strcmp(b->name, b->show))
+					 who = b->show;
+				else if (c->gc->user->alias[0])
+					who = c->gc->user->alias;
+				else if (c->gc->displayname[0])
+					who = c->gc->displayname;
+				else
+					who = c->gc->username;
+			} else {
+				b = find_buddy(c->gc, c->name);
+				if (b)
+					who = b->show;
+				else
+					who = c->name;
+			}
+		} else {
+			b = find_buddy(c->gc, who);
+			if (b)
+				who = b->show;
+		}
+	}
+
+	strftime(mdate, sizeof(mdate), "%H:%M:%S", localtime(&mtime));
+
+	gtk_font_options = gtk_font_options ^ GTK_IMHTML_NO_COMMENTS;
+
+	if (convo_options & OPT_CONVO_IGNORE_COLOUR)
+		gtk_font_options = gtk_font_options ^ GTK_IMHTML_NO_COLOURS;
+
+	if (convo_options & OPT_CONVO_IGNORE_FONTS)
+		gtk_font_options = gtk_font_options ^ GTK_IMHTML_NO_FONTS;
+
+	if (convo_options & OPT_CONVO_IGNORE_SIZES)
+		gtk_font_options = gtk_font_options ^ GTK_IMHTML_NO_SIZES;
+
+	if (!(logging_options & OPT_LOG_STRIP_HTML))
+		gtk_font_options = gtk_font_options ^ GTK_IMHTML_RETURN_LOG;
+
+	if (flags & WFLAG_SYSTEM) {
+		if (convo_options & OPT_CONVO_SHOW_TIME)
+			g_snprintf(buf, BUF_LONG, "<FONT SIZE=\"2\">(%s) </FONT><B>%s</B>", mdate, what);
+		else
+			g_snprintf(buf, BUF_LONG, "<B>%s</B>", what);
+		g_snprintf(buf2, sizeof(buf2), "<FONT SIZE=\"2\"><!--(%s) --></FONT><B>%s</B><BR>",
+			   mdate, what);
+
+		gtk_imhtml_append_text(GTK_IMHTML(c->text), buf2, -1, 0);
+
+		if (logging_options & OPT_LOG_STRIP_HTML) {
+			char *t1 = strip_html(buf);
+			c->history = g_string_append(c->history, t1);
+			c->history = g_string_append(c->history, "\n");
+			g_free(t1);
+		} else {
+			c->history = g_string_append(c->history, buf);
+			c->history = g_string_append(c->history, "<BR>\n");
+		}
+
+		if (!(flags & WFLAG_NOLOG) && ((logging_options & OPT_LOG_ALL) || find_log_info(c->name))) {
+			char *t1;
+			char nm[256];
+
+			if (logging_options & OPT_LOG_STRIP_HTML) {
+				t1 = strip_html(buf);
+			} else {
+				t1 = buf;
+			}
+			if (c->is_chat)
+				g_snprintf(nm, 256, "%s.chat", c->name);
+			else
+				g_snprintf(nm, 256, "%s", c->name);
+			fd = open_log_file(nm);
+			if (fd) {
+				if (logging_options & OPT_LOG_STRIP_HTML) {
+					fprintf(fd, "%s\n", t1);
+				} else {
+					fprintf(fd, "%s<BR>\n", t1);
+				}
+				fclose(fd);
+			}
+			if (logging_options & OPT_LOG_STRIP_HTML) {
+				g_free(t1);
+			}
+		}
+	} else if (flags & WFLAG_NOLOG) {
+		g_snprintf(buf, BUF_LONG, "<B><FONT COLOR=\"#777777\">%s</FONT></B><BR>", what);
+		gtk_imhtml_append_text(GTK_IMHTML(c->text), buf, -1, 0);
+	} else {
+		if (flags & WFLAG_WHISPER) {
+			/* if we're whispering, it's not an autoresponse */
+			if (meify(what, length)) {
+				str = g_malloc(1024);
+				g_snprintf(str, 1024, "***%s", who);
+				strcpy(colour, "#6C2585");
+			} else {
+				str = g_malloc(1024);
+				g_snprintf(str, 1024, "*%s*:", who);
+				strcpy(colour, "#00ff00");
+			}
+		} else {
+			if (meify(what, length)) {
+				str = g_malloc(1024);
+				if (flags & WFLAG_AUTO)
+					g_snprintf(str, 1024, "%s ***%s", AUTO_RESPONSE, who);
+				else
+					g_snprintf(str, 1024, "***%s", who);
+				if (flags & WFLAG_NICK)
+					strcpy(colour, "#af7f00");
+				else
+					strcpy(colour, "#062585");
+			} else {
+				str = g_malloc(1024);
+				if (flags & WFLAG_AUTO)
+					g_snprintf(str, 1024, "%s %s", who, AUTO_RESPONSE);
+				else
+					g_snprintf(str, 1024, "%s:", who);
+				if (flags & WFLAG_NICK)
+					strcpy(colour, "#af7f00");
+				else if (flags & WFLAG_RECV)
+					strcpy(colour, "#ff0000");
+				else if (flags & WFLAG_SEND)
+					strcpy(colour, "#0000ff");
+			}
+		}
+
+		if (convo_options & OPT_CONVO_SHOW_TIME)
+			g_snprintf(buf, BUF_LONG, "<FONT COLOR=\"%s\"><FONT SIZE=\"2\">(%s) </FONT>"
+				   "<B>%s</B></FONT> ", colour, mdate, str);
+		else
+			g_snprintf(buf, BUF_LONG, "<FONT COLOR=\"%s\"><B>%s</B></FONT> ", colour, str);
+		g_snprintf(buf2, BUF_LONG, "<FONT COLOR=\"%s\"><FONT SIZE=\"2\"><!--(%s) --></FONT>"
+			   "<B>%s</B></FONT> ", colour, mdate, str);
+
+		g_free(str);
+
+		gtk_imhtml_append_text(GTK_IMHTML(c->text), buf2, -1, 0);
+
+		logstr = gtk_imhtml_append_text(GTK_IMHTML(c->text), what, length, gtk_font_options);
+
+		gtk_imhtml_append_text(GTK_IMHTML(c->text), "<BR>", -1, 0);
+
+		/* XXX this needs to be updated for the new length argument */
+		if (logging_options & OPT_LOG_STRIP_HTML) {
+			char *t1, *t2;
+			t1 = strip_html(buf);
+			t2 = strip_html(what);
+			c->history = g_string_append(c->history, t1);
+			c->history = g_string_append(c->history, t2);
+			c->history = g_string_append(c->history, "\n");
+			g_free(t1);
+			g_free(t2);
+		} else {
+			char *t1, *t2;
+			t1 = html_logize(buf);
+			t2 = html_logize(what);
+			c->history = g_string_append(c->history, t1);
+			c->history = g_string_append(c->history, t2);
+			c->history = g_string_append(c->history, "\n");
+			c->history = g_string_append(c->history, logstr->str);
+			c->history = g_string_append(c->history, "<BR>\n");
+			g_free(t1);
+			g_free(t2);
+		}
+
+		/* XXX this needs to be updated for the new length argument */
+		if ((logging_options & OPT_LOG_ALL) || find_log_info(c->name)) {
+			char *t1, *t2;
+			char *nm = g_malloc(256);
+			if (c->is_chat)
+				g_snprintf(nm, 256, "%s.chat", c->name);
+			else
+				g_snprintf(nm, 256, "%s", c->name);
+
+			if (logging_options & OPT_LOG_STRIP_HTML) {
+				t1 = strip_html(buf);
+				t2 = strip_html(what);
+			} else {
+				t1 = html_logize(buf);
+				t2 = html_logize(what);
+			}
+			fd = open_log_file(nm);
+			if (fd) {
+				if (logging_options & OPT_LOG_STRIP_HTML) {
+					fprintf(fd, "%s%s\n", t1, t2);
+				} else {
+					fprintf(fd, "%s%s%s<BR>\n", t1, t2, logstr->str);
+					g_string_free(logstr, TRUE);
+				}
+				fclose(fd);
+			}
+			g_free(t1);
+			g_free(t2);
+			g_free(nm);
+		}
+	}
+
+	if ((c->is_chat && (chat_options & OPT_CHAT_POPUP)) ||
+	    (!c->is_chat && (im_options & OPT_IM_POPUP)))
+		gdk_window_show(c->window->window);
+	if (flags & WFLAG_RECV)
+		reset_typing(g_strdup(c->name));
+
+	/* tab highlighting */
+	if (c->is_chat && !(chat_options & OPT_CHAT_ONE_WINDOW)) /* if chat but not tabbed chat */
+		return;
+	if (!c->is_chat && !(im_options & OPT_IM_ONE_WINDOW)) /* if convo but not tabbed convo */
+		return;
+	if (!(flags & WFLAG_RECV) && !(flags & WFLAG_SYSTEM))
+		return;
+	if ((c->unseen == 2) || ((c->unseen == 1) && !(flags & WFLAG_NICK)))
+		return;
+
+	if (c->is_chat) {
+		int offs;
+		if ((convo_options & OPT_CONVO_COMBINE) && (im_options & OPT_IM_ONE_WINDOW))
+			offs = g_list_length(conversations);
+		else
+			offs = 0;
+		if (gtk_notebook_get_current_page(GTK_NOTEBOOK(chat_notebook)) ==
+				g_list_index(chats, c) + offs)
+			unhighlight = 1;
+	} else {
+		if (gtk_notebook_get_current_page(GTK_NOTEBOOK(convo_notebook)) ==
+				g_list_index(conversations, c))
+			unhighlight = 1;
+	}
+	if ((c->unseen != -1) && unhighlight) /* If there's no typing message
+						 and we're on the same tab, don't bother
+						 changing the color. */
+		return;
+
+	{
+		GtkNotebook *notebook = GTK_NOTEBOOK(c->is_chat ? chat_notebook : convo_notebook);
+		int offs = ((convo_options & OPT_CONVO_COMBINE) &&
+			    (im_options & OPT_IM_ONE_WINDOW) && c->is_chat) ?
+			g_list_length(conversations) : 0;
+		GList *ws = (c->is_chat ? chats : conversations);
+		GtkWidget *label = gtk_notebook_get_tab_label(notebook,
+							      gtk_notebook_get_nth_page(notebook,
+											offs + g_list_index(ws, c)));
+		GtkStyle *style;
+		style = gtk_style_new();
+		if (!GTK_WIDGET_REALIZED(label))
+			gtk_widget_realize(label);
+		gdk_font_unref(gtk_style_get_font(style));
+		gtk_style_set_font(style, gdk_font_ref(gtk_style_get_font(label->style)));
+		if (!unhighlight && flags & WFLAG_NICK) {
+			style->fg[0].red = 0x0000;
+			style->fg[0].green = 0x0000;
+			style->fg[0].blue = 0xcccc;
+			c->unseen = 2;
+		} else if (!unhighlight) {
+			style->fg[0].red = 0xcccc;
+			style->fg[0].green = 0x0000;
+			style->fg[0].blue = 0x0000;
+			c->unseen = 1;
+		} else {
+			c->unseen = 0;
+		}
+		gtk_widget_set_style(label, style);
+		gtk_style_unref(style);
+	}
+}
+
+void update_progress(struct conversation *c, float percent) {
+            
+       if (percent >= 1 && !(c->progress))
+	       return;
+
+       if (percent >= 1) {
+	       gtk_widget_destroy(c->progress);
+               c->progress = NULL;
+               return;
+       }
+       
+       if (!c->progress) {
+               GtkBox *box = GTK_BOX(c->text->parent->parent);
+               c->progress = gtk_progress_bar_new();
+               gtk_box_pack_end(box, c->progress, FALSE, FALSE, 0);
+               gtk_widget_set_usize (c->progress, 1, 8);
+               gtk_widget_show (c->progress);
+       }
+       
+       if (percent < 1)
+               gtk_progress_set_percentage(GTK_PROGRESS(c->progress), percent);
+}
+
+GtkWidget *build_conv_toolbar(struct conversation *c)
+{
+	GdkPixmap *strike_i, *small_i, *normal_i, *big_i, *bold_i, *italic_i, *underline_i, *speaker_i,
+	    *wood_i, *fgcolor_i, *bgcolor_i, *link_i, *font_i, *smiley_i, *save_i, *image_i;
+	GtkWidget *strike_p, *small_p, *normal_p, *big_p, *bold_p, *italic_p, *underline_p, *speaker_p,
+	    *wood_p, *fgcolor_p, *bgcolor_p, *link_p, *font_p, *smiley_p, *save_p, *image_p;
+	GtkWidget *strike, *small, *normal, *big, *bold, *italic, *underline, *speaker, *wood,
+	    *fgcolorbtn, *bgcolorbtn, *link, *font, *smiley, *save, *image;
+	GdkBitmap *mask;
+	GtkWidget *toolbar;
+	GtkWidget *win;
+	GtkWidget *entry;
+
+	toolbar = gtk_toolbar_new(GTK_ORIENTATION_HORIZONTAL, GTK_TOOLBAR_ICONS);
+	win = c->window;
+	entry = c->entry;
+
+	bold_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, bold_xpm);
+	bold_p = gtk_pixmap_new(bold_i, mask);
+	gtk_widget_show(bold_p);
+	gdk_bitmap_unref(mask);
+
+	italic_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, italic_xpm);
+	italic_p = gtk_pixmap_new(italic_i, mask);
+	gtk_widget_show(italic_p);
+	gdk_bitmap_unref(mask);
+
+	underline_i = gdk_pixmap_create_from_xpm_d(win->window, &mask,
+						   &win->style->white, underline_xpm);
+	underline_p = gtk_pixmap_new(underline_i, mask);
+	gtk_widget_show(underline_p);
+	gdk_bitmap_unref(mask);
+
+	strike_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, strike_xpm);
+	strike_p = gtk_pixmap_new(strike_i, mask);
+	gtk_widget_show(strike_p);
+	gdk_bitmap_unref(mask);
+
+	small_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, small_xpm);
+	small_p = gtk_pixmap_new(small_i, mask);
+	gtk_widget_show(small_p);
+	gdk_bitmap_unref(mask);
+
+	normal_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, normal_xpm);
+	normal_p = gtk_pixmap_new(normal_i, mask);
+	gtk_widget_show(normal_p);
+	gdk_bitmap_unref(mask);
+
+	big_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, big_xpm);
+	big_p = gtk_pixmap_new(big_i, mask);
+	gtk_widget_show(big_p);
+	gdk_bitmap_unref(mask);
+
+	font_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, fontface_xpm);
+	font_p = gtk_pixmap_new(font_i, mask);
+	gtk_widget_show(font_p);
+	gdk_bitmap_unref(mask);
+
+	fgcolor_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, fgcolor_xpm);
+	fgcolor_p = gtk_pixmap_new(fgcolor_i, mask);
+	gtk_widget_show(fgcolor_p);
+	gdk_bitmap_unref(mask);
+
+	bgcolor_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, bgcolor_xpm);
+	bgcolor_p = gtk_pixmap_new(bgcolor_i, mask);
+	gtk_widget_show(bgcolor_p);
+	gdk_bitmap_unref(mask);
+
+	link_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, link_xpm);
+	link_p = gtk_pixmap_new(link_i, mask);
+	gtk_widget_show(link_p);
+	gdk_bitmap_unref(mask);
+
+	smiley_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, smile_icon_xpm);
+	smiley_p = gtk_pixmap_new(smiley_i, mask);
+	gtk_widget_show(smiley_p);
+	gdk_bitmap_unref(mask);
+
+	image_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, image_icon_xpm);
+	image_p = gtk_pixmap_new(image_i, mask);
+	gtk_widget_show(image_p);
+	gdk_bitmap_unref(mask);
+
+	wood_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, wood_xpm);
+	wood_p = gtk_pixmap_new(wood_i, mask);
+	gtk_widget_show(wood_p);
+	gdk_bitmap_unref(mask);
+
+	save_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, save_small_xpm);
+	save_p = gtk_pixmap_new(save_i, mask);
+	gtk_widget_show(save_p);
+	gdk_bitmap_unref(mask);
+
+	speaker_i = gdk_pixmap_create_from_xpm_d(win->window, &mask, &win->style->white, speaker_xpm);
+	speaker_p = gtk_pixmap_new(speaker_i, mask);
+	gtk_widget_show(speaker_p);
+	gdk_bitmap_unref(mask);
+	c->makesound = 1;
+
+	bold = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					  GTK_TOOLBAR_CHILD_TOGGLEBUTTON, NULL,
+					  NULL, _("Bold Text"), _("Bold"), bold_p,
+					  GTK_SIGNAL_FUNC(do_bold), entry);
+	italic = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					    GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					    NULL, NULL, _("Italics Text"),
+					    _("Italics"), italic_p, GTK_SIGNAL_FUNC(do_italic), entry);
+	underline = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					       GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					       NULL, NULL, _("Underline Text"),
+					       _("Underline"), underline_p,
+					       GTK_SIGNAL_FUNC(do_underline), entry);
+	strike =
+	    gtk_toolbar_append_element(GTK_TOOLBAR(toolbar), GTK_TOOLBAR_CHILD_TOGGLEBUTTON, NULL,
+				       NULL, _("Strike through Text"), _("Strike"), strike_p,
+				       GTK_SIGNAL_FUNC(do_strike), entry);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	small = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					NULL, _("Decrease font size"), _("Small"),
+					small_p, GTK_SIGNAL_FUNC(do_small), entry);
+	normal = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					 NULL, _("Normal font size"), _("Normal"),
+					 normal_p, GTK_SIGNAL_FUNC(do_normal), entry);
+	big = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+				      NULL, _("Increase font size"), _("Big"),
+				      big_p, GTK_SIGNAL_FUNC(do_big), entry);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	font = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					  GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					  NULL, NULL, _("Select Font"),
+					  _("Font"), font_p, GTK_SIGNAL_FUNC(toggle_font), c);
+	fgcolorbtn = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+						GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+						NULL, NULL, _("Text Color"),
+						_("Color"), fgcolor_p, GTK_SIGNAL_FUNC(toggle_fg_color),
+						c);
+	bgcolorbtn =
+	    gtk_toolbar_append_element(GTK_TOOLBAR(toolbar), GTK_TOOLBAR_CHILD_TOGGLEBUTTON, NULL,
+				       NULL, _("Background Color"), _("Color"), bgcolor_p,
+				       GTK_SIGNAL_FUNC(toggle_bg_color), c);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	link = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					  GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					  NULL, NULL, _("Insert Link"),
+					  _("Link"), link_p, GTK_SIGNAL_FUNC(toggle_link), c);
+	smiley = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					    GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					    NULL, NULL, _("Insert smiley face"), _("Smiley"),
+					    smiley_p, GTK_SIGNAL_FUNC(insert_smiley), c);
+	image = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					    NULL, _("Insert IM Image"), _("Image"),
+					    image_p, GTK_SIGNAL_FUNC(insert_image), c);
+	
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	wood = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					  GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					  NULL, NULL, _("Enable logging"),
+					  _("Logging"), wood_p, GTK_SIGNAL_FUNC(toggle_loggle), c);
+	state_lock = 1;
+	if (find_log_info(c->name))
+		 gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(wood), TRUE);
+	else
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(wood), FALSE);
+	state_lock = 0;
+
+	save = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+				       NULL, _("Save Conversation"),
+				       _("Save"), save_p, GTK_SIGNAL_FUNC(save_convo), c);
+
+	speaker = gtk_toolbar_append_element(GTK_TOOLBAR(toolbar),
+					     GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
+					     NULL, NULL, _("Enable sounds"),
+					     _("Sound"), speaker_p, GTK_SIGNAL_FUNC(set_option),
+					     &c->makesound);
+	c->makesound = 0;
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(speaker), TRUE);
+
+	/* use a slicker look if the user wants to */
+	if (misc_options & OPT_MISC_COOL_LOOK) {
+		gtk_button_set_relief(GTK_BUTTON(bold), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(italic), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(underline), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(strike), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(small), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(normal), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(big), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(font), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(fgcolorbtn), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(bgcolorbtn), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(link), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(smiley), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(image), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(wood), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(save), GTK_RELIEF_NONE);
+		gtk_button_set_relief(GTK_BUTTON(speaker), GTK_RELIEF_NONE);
+	}
+
+	gtk_widget_show(toolbar);
+
+	gdk_pixmap_unref(bold_i);
+	gdk_pixmap_unref(italic_i);
+	gdk_pixmap_unref(underline_i);
+	gdk_pixmap_unref(strike_i);
+	gdk_pixmap_unref(small_i);
+	gdk_pixmap_unref(normal_i);
+	gdk_pixmap_unref(big_i);
+	gdk_pixmap_unref(font_i);
+	gdk_pixmap_unref(fgcolor_i);
+	gdk_pixmap_unref(bgcolor_i);
+	gdk_pixmap_unref(link_i);
+	gdk_pixmap_unref(smiley_i);
+	gdk_pixmap_unref(wood_i);
+	gdk_pixmap_unref(save_i);
+	gdk_pixmap_unref(speaker_i);
+	gdk_pixmap_unref(image_i);
+
+	c->bold = bold;
+	c->strike = strike;
+	c->italic = italic;
+	c->underline = underline;
+	c->log_button = wood;
+	c->fgcolorbtn = fgcolorbtn;
+	c->bgcolorbtn = bgcolorbtn;
+	c->link = link;
+	c->wood = wood;
+	c->font = font;
+	c->smiley = smiley;
+	c->imagebtn = image;
+
+	gtk_widget_set_sensitive(c->log_button, ((logging_options & OPT_LOG_ALL)) ? FALSE : TRUE);
+	gtk_widget_set_sensitive(c->bold, ((font_options & OPT_FONT_BOLD)) ? FALSE : TRUE);
+	gtk_widget_set_sensitive(c->italic, ((font_options & OPT_FONT_ITALIC)) ? FALSE : TRUE);
+	gtk_widget_set_sensitive(c->underline, ((font_options & OPT_FONT_UNDERLINE)) ? FALSE : TRUE);
+	gtk_widget_set_sensitive(c->strike, ((font_options & OPT_FONT_STRIKE)) ? FALSE : TRUE);
+
+	return toolbar;
+}
+
+static void convo_sel_send(GtkObject *m, struct gaim_connection *c)
+{
+	struct conversation *cnv = gtk_object_get_user_data(m);
+
+	if (cnv->gc == c)
+		return;
+
+	cnv->gc = c;
+
+	set_convo_title(cnv);
+
+	update_buttons_by_protocol(cnv);
+
+	update_icon(cnv);
+	update_checkbox(cnv);
+	update_smilies(cnv);
+	gaim_setup_imhtml_smileys(cnv->text);
+}
+
+int set_dispstyle(int chat)
+{
+	int dispstyle;
+
+	if (chat) {
+		switch (chat_options & (OPT_CHAT_BUTTON_TEXT | OPT_CHAT_BUTTON_XPM)) {
+		case OPT_CHAT_BUTTON_TEXT:
+			dispstyle = 1;
+			break;
+		case OPT_CHAT_BUTTON_XPM:
+			dispstyle = 0;
+			break;
+		default:	/* both or neither */
+			dispstyle = 2;
+			break;
+		}
+	} else {
+		switch (im_options & (OPT_IM_BUTTON_TEXT | OPT_IM_BUTTON_XPM)) {
+		case OPT_IM_BUTTON_TEXT:
+			dispstyle = 1;
+			break;
+		case OPT_IM_BUTTON_XPM:
+			dispstyle = 0;
+			break;
+		default:	/* both or neither */
+			dispstyle = 2;
+			break;
+		}
+	}
+	return dispstyle;
+}
+
+void update_convo_add_button(struct conversation *c)
+{
+	int dispstyle = set_dispstyle(0);
+	GtkWidget *parent = c->add->parent;
+	gboolean rebuild = FALSE;
+
+	if (find_buddy(c->gc, c->name)) {
+		if (!gtk_object_get_user_data(GTK_OBJECT(c->add))) {
+			gtk_widget_destroy(c->add);
+			c->add = picture_button2(c->window, _("Remove"), gnome_remove_xpm, dispstyle);
+			rebuild = TRUE;
+		}
+		if (c->gc) {
+			if (c->gc->prpl->remove_buddy == NULL)
+				gtk_widget_set_sensitive(c->add, FALSE);
+			else
+				gtk_widget_set_sensitive(c->add, TRUE);
+		} else
+			gtk_widget_set_sensitive(c->add, FALSE);
+		gtk_object_set_user_data(GTK_OBJECT(c->add), c);
+	} else {
+		if (gtk_object_get_user_data(GTK_OBJECT(c->add))) {
+			gtk_widget_destroy(c->add);
+			c->add = picture_button2(c->window, _("Add"), gnome_add_xpm, dispstyle);
+			rebuild = TRUE;
+		}
+		if (c->gc) {
+			if (c->gc->prpl->add_buddy == NULL)
+				gtk_widget_set_sensitive(c->add, FALSE);
+			else
+				gtk_widget_set_sensitive(c->add, TRUE);
+		} else
+			gtk_widget_set_sensitive(c->add, FALSE);
+	}
+
+	if (rebuild) {
+		gtk_signal_connect(GTK_OBJECT(c->add), "clicked", GTK_SIGNAL_FUNC(add_callback), c);
+		gtk_box_pack_end(GTK_BOX(parent), c->add, dispstyle, dispstyle, 0);
+		gtk_box_reorder_child(GTK_BOX(parent), c->add, 2);
+		gtk_widget_show(c->add);
+	}
+}
+
+static void create_convo_menu(struct conversation *cnv)
+{
+	GtkWidget *menu, *opt;
+	GSList *g = connections;
+	struct gaim_connection *c;
+	char buf[2048];
+
+	if (g_slist_length(g) < 2)
+		gtk_widget_hide(cnv->menu->parent);
+	else {
+		menu = gtk_menu_new();
+
+		while (g) {
+			c = (struct gaim_connection *)g->data;
+			g_snprintf(buf, sizeof buf, "%s (%s)", c->username, c->prpl->name());
+			opt = gtk_menu_item_new_with_label(buf);
+			gtk_object_set_user_data(GTK_OBJECT(opt), cnv);
+			gtk_signal_connect(GTK_OBJECT(opt), "activate",
+					   GTK_SIGNAL_FUNC(convo_sel_send), c);
+			gtk_widget_show(opt);
+			gtk_menu_append(GTK_MENU(menu), opt);
+			g = g->next;
+		}
+
+		gtk_option_menu_remove_menu(GTK_OPTION_MENU(cnv->menu));
+		gtk_option_menu_set_menu(GTK_OPTION_MENU(cnv->menu), menu);
+		gtk_option_menu_set_history(GTK_OPTION_MENU(cnv->menu), 0);
+
+		gtk_widget_show(cnv->menu);
+		gtk_widget_show(cnv->menu->parent);
+	}
+}
+
+void redo_convo_menus()
+{
+	GList *c = conversations;
+	struct conversation *C;
+
+	while (c) {
+		C = (struct conversation *)c->data;
+		c = c->next;
+
+		create_convo_menu(C);
+
+		if (g_slist_find(connections, C->gc))
+			set_convo_gc(C, C->gc);
+		else
+			set_convo_gc(C, connections ? connections->data : NULL);
+	}
+}
+
+void convo_menu_remove(struct gaim_connection *gc)
+{
+	GList *c = conversations;
+	struct conversation *C;
+
+	while (c) {
+		C = (struct conversation *)c->data;
+		c = c->next;
+
+		remove_icon(C);
+		remove_checkbox(C);
+	}
+}
+
+void set_convo_gc(struct conversation *c, struct gaim_connection *gc)
+{
+	if (gc)
+		gtk_option_menu_set_history(GTK_OPTION_MENU(c->menu), g_slist_index(connections, gc));
+
+	if (c->gc == gc)
+		return;
+
+	c->gc = gc;
+
+	set_convo_title(c);
+	update_buttons_by_protocol(c);
+
+	update_icon(c);
+	update_checkbox(c);
+	update_smilies(c);
+	gaim_setup_imhtml_smileys(c->text);
+}
+
+void update_buttons_by_protocol(struct conversation *c)
+{
+	if (!c->gc) {
+		if (c->info)
+			gtk_widget_set_sensitive(c->info, FALSE);
+		if (c->send)
+			gtk_widget_set_sensitive(c->send, FALSE);
+		if (c->warn)
+			gtk_widget_set_sensitive(c->warn, FALSE);
+		if (c->block)
+			gtk_widget_set_sensitive(c->block, FALSE);
+		if (c->add)
+			gtk_widget_set_sensitive(c->add, FALSE);
+		if (c->whisper)
+			gtk_widget_set_sensitive(c->whisper, FALSE);
+		if (c->invite)
+			gtk_widget_set_sensitive(c->invite, FALSE);
+		return;
+	}
+
+	if (c->gc->prpl->get_info == NULL && c->info)
+		gtk_widget_set_sensitive(c->info, FALSE);
+	else if (c->info)
+		gtk_widget_set_sensitive(c->info, TRUE);
+
+	if (c->is_chat) {
+		if (c->gc->prpl->chat_send == NULL && c->send)
+			gtk_widget_set_sensitive(c->send, FALSE);
+		else
+			gtk_widget_set_sensitive(c->send, TRUE);
+		gtk_widget_set_sensitive(c->imagebtn, FALSE);
+	} else {
+		if (c->gc->prpl->send_im == NULL && c->send)
+			gtk_widget_set_sensitive(c->send, FALSE);
+		else
+			gtk_widget_set_sensitive(c->send, TRUE);
+		if (c->gc->prpl->options & OPT_PROTO_IM_IMAGE)
+			gtk_widget_set_sensitive(c->imagebtn, TRUE);
+		else
+			gtk_widget_set_sensitive(c->imagebtn, FALSE);
+	}
+
+	if (c->gc->prpl->warn == NULL && c->warn)
+		gtk_widget_set_sensitive(c->warn, FALSE);
+	else if (c->warn)
+		gtk_widget_set_sensitive(c->warn, TRUE);
+
+	if (c->gc->prpl->add_permit == NULL && c->block)
+		gtk_widget_set_sensitive(c->block, FALSE);
+	else if (c->block)
+		gtk_widget_set_sensitive(c->block, TRUE);
+
+	if (c->add)
+		update_convo_add_button(c);
+
+	if (c->whisper) {
+		if (c->gc->prpl->chat_whisper == NULL)
+			gtk_widget_set_sensitive(c->whisper, FALSE);
+		else
+			gtk_widget_set_sensitive(c->whisper, TRUE);
+	}
+
+	if (c->invite) {
+		if (c->gc->prpl->chat_invite == NULL)
+			gtk_widget_set_sensitive(c->invite, FALSE);
+		else
+			gtk_widget_set_sensitive(c->invite, TRUE);
+	}
+}
+
+void convo_switch(GtkNotebook *notebook, GtkWidget *page, gint page_num, gpointer data)
+{
+	GtkWidget *label = gtk_notebook_get_tab_label(notebook,
+			gtk_notebook_get_nth_page(notebook, page_num));
+	GtkStyle *style;
+	struct conversation *c;
+	if ((convo_options & OPT_CONVO_COMBINE) &&
+	    (im_options & OPT_IM_ONE_WINDOW) &&
+	    (chat_options & OPT_CHAT_ONE_WINDOW)) {
+		int len = g_list_length(conversations);
+		if (page_num < len)
+			c = g_list_nth_data(conversations, page_num);
+		else
+			c = g_list_nth_data(chats, page_num - len);
+	} else if (GTK_WIDGET(notebook) == convo_notebook)
+		c = g_list_nth_data(conversations, page_num);
+	else
+		c = g_list_nth_data(chats, page_num);
+	if (c && c->window && c->entry)
+		gtk_window_set_focus(GTK_WINDOW(c->window), c->entry);
+	if (!GTK_WIDGET_REALIZED(label))
+		return;
+	if (c->unseen == -1) return;
+	style = gtk_style_new();
+	gdk_font_unref(gtk_style_get_font(style));
+	gtk_style_set_font(style, gdk_font_ref(gtk_style_get_font(label->style)));
+	gtk_widget_set_style(label, style);
+	gtk_style_unref(style);
+	if (c)
+		c->unseen = 0;
+}
+
+void show_typing(struct conversation *c) {
+	
+	if (c->is_chat) /* We shouldn't be getting typing notifications from chats. */
+		return;
+	if (im_options & OPT_IM_ONE_WINDOW) { /* We'll make the tab green */
+		GtkStyle *style;
+		GtkNotebook *notebook = GTK_NOTEBOOK(c->is_chat ? chat_notebook : convo_notebook);
+		int offs = ((convo_options & OPT_CONVO_COMBINE) &&
+			    (im_options & OPT_IM_ONE_WINDOW) && c->is_chat) ?
+			g_list_length(conversations) : 0;
+		GList *ws = (c->is_chat ? chats : conversations);
+		GtkWidget *label = gtk_notebook_get_tab_label(notebook,
+							      gtk_notebook_get_nth_page(notebook,
+											offs + g_list_index(ws, c)));
+		style = gtk_style_new();
+		if (!GTK_WIDGET_REALIZED(label))
+			gtk_widget_realize(label);
+		gdk_font_unref(gtk_style_get_font(style));
+		gtk_style_set_font(style, gdk_font_ref(gtk_style_get_font(label->style)));
+		style->fg[0].red = 0x0000;
+		style->fg[0].green = 0x9999;
+		style->fg[0].blue = 0x0000;
+		gtk_widget_set_style(label, style);
+			debug_printf("setting style\n");
+		gtk_style_unref(style);
+		c->unseen = -1;
+	} else {
+		GtkWindow *win = (GtkWindow *)c->window;
+		char *buf;
+		if (strstr(win->title, " [TYPING]"))
+			return;
+		buf = g_malloc(strlen(win->title) + strlen(" [TYPING]") + 1);
+		g_snprintf(buf, 
+			   strlen(win->title) + strlen(" [TYPING]") + 1, "%s [TYPING]", 
+			   win->title);
+		gtk_window_set_title(win, buf);
+		g_free(buf);
+	}
+	
+}
+
+/* This returns a boolean, so that it can timeout */
+gboolean reset_typing(char *name) {
+	struct conversation *c = find_conversation(name);
+	if (!c) {
+		g_free(name);
+		return FALSE;
+	}
+		/* Reset the title (if necessary) */
+	if (c->is_chat) {
+		g_free(name);
+		c->typing_timeout = 0;
+		return FALSE;
+	}
+	if (!(im_options & OPT_IM_ONE_WINDOW)) {
+		GtkWindow *win = (GtkWindow*)c->window;
+		char *new_title;
+		if (strstr(win->title, " [TYPING]")) {
+			new_title = g_malloc(strlen(win->title) - strlen("[TYPING]"));
+			g_snprintf(new_title, strlen(win->title) - strlen("[TYPING]"), win->title);
+			gtk_window_set_title(win, new_title);
+			g_free(new_title);
+			
+		}
+	} else if (c->unseen == -1) {
+		GtkNotebook *notebook = GTK_NOTEBOOK(convo_notebook);
+		int offs = ((convo_options & OPT_CONVO_COMBINE) &&
+			    (im_options & OPT_IM_ONE_WINDOW) && c->is_chat) ?
+			g_list_length(conversations) : 0;
+		GList *ws = (conversations);
+		GtkWidget *label = gtk_notebook_get_tab_label(notebook,
+							      gtk_notebook_get_nth_page(notebook,
+								      offs + g_list_index(ws, c)));
+		GtkStyle *style;
+		style = gtk_style_new();
+		if (!GTK_WIDGET_REALIZED(label))
+			gtk_widget_realize(label);
+		gdk_font_unref(gtk_style_get_font(style));
+		gtk_style_set_font(style, gdk_font_ref(gtk_style_get_font(label->style)));
+		c->unseen = 0;
+		gtk_widget_set_style(label, style);
+		gtk_style_unref(style);
+	}
+	g_free(name);
+	c->typing_timeout = 0;
+	return FALSE;
+}
+
+void show_conv(struct conversation *c)
+{
+	GtkWidget *win;
+	GtkWidget *cont;
+	GtkWidget *text;
+	GtkWidget *sw;
+	GtkWidget *send;
+	GtkWidget *info;
+	GtkWidget *warn;
+	GtkWidget *block;
+	GtkWidget *close;
+	GtkWidget *entry;
+	GtkWidget *bbox;
+	GtkWidget *vbox;
+	GtkWidget *vbox2;
+	GtkWidget *paned;
+	GtkWidget *add;
+	GtkWidget *toolbar;
+	GtkWidget *hbox;
+	GtkWidget *label;
+	int dispstyle = set_dispstyle(0);
+
+	c->font_dialog = NULL;
+	c->fg_color_dialog = NULL;
+	c->bg_color_dialog = NULL;
+	c->smiley_dialog = NULL;
+	c->link_dialog = NULL;
+	c->log_dialog = NULL;
+	sprintf(c->fontxfld, "%s", fontxfld);
+	sprintf(c->fontface, "%s", fontface);
+	c->hasfont = 0;
+	c->bgcol = bgcolor;
+	c->hasbg = 0;
+	c->fgcol = fgcolor;
+	c->hasfg = 0;
+
+	if (im_options & OPT_IM_ONE_WINDOW) {
+		if (!all_convos) {
+			win = all_convos = c->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+			if ((convo_options & OPT_CONVO_COMBINE) && (chat_options & OPT_CHAT_ONE_WINDOW))
+				all_chats = all_convos;
+			gtk_window_set_wmclass(GTK_WINDOW(win), "conversation", "Gaim");
+			gtk_window_set_policy(GTK_WINDOW(win), TRUE, TRUE, FALSE);
+			gtk_container_border_width(GTK_CONTAINER(win), 0);
+			gtk_widget_realize(win);
+			aol_icon(win->window);
+			gtk_window_set_title(GTK_WINDOW(win), _("Gaim - Conversations"));
+			gtk_signal_connect(GTK_OBJECT(win), "delete_event",
+					   GTK_SIGNAL_FUNC(delete_all_convo), NULL);
+
+			convo_notebook = gtk_notebook_new();
+			if ((convo_options & OPT_CONVO_COMBINE) && (chat_options & OPT_CHAT_ONE_WINDOW))
+				chat_notebook = convo_notebook;
+			if (im_options & OPT_IM_SIDE_TAB) {
+				if (im_options & OPT_IM_BR_TAB) {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook),
+								 GTK_POS_RIGHT);
+				} else {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook),
+								 GTK_POS_LEFT);
+				}
+			} else {
+				if (im_options & OPT_IM_BR_TAB) {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook),
+								 GTK_POS_BOTTOM);
+				} else {
+					gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook),
+								 GTK_POS_TOP);
+				}
+			}
+			gtk_notebook_set_scrollable(GTK_NOTEBOOK(convo_notebook), TRUE);
+			gtk_notebook_popup_enable(GTK_NOTEBOOK(convo_notebook));
+			gtk_container_add(GTK_CONTAINER(win), convo_notebook);
+			gtk_signal_connect(GTK_OBJECT(convo_notebook), "switch-page",
+					   GTK_SIGNAL_FUNC(convo_switch), NULL);
+			gtk_widget_show(convo_notebook);
+		} else
+			win = c->window = all_convos;
+
+		cont = gtk_vbox_new(FALSE, 5);
+		gtk_container_set_border_width(GTK_CONTAINER(cont), 5);
+		/* this doesn't matter since we're resetting the name once we're out of the if */
+		gtk_notebook_insert_page(GTK_NOTEBOOK(convo_notebook), cont, gtk_label_new(c->name),
+				g_list_index(conversations, c));
+		gtk_widget_show(cont);
+	} else {
+		cont = win = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+		c->window = win;
+		gtk_object_set_user_data(GTK_OBJECT(win), c);
+		gtk_window_set_wmclass(GTK_WINDOW(win), "conversation", "Gaim");
+		gtk_window_set_policy(GTK_WINDOW(win), TRUE, TRUE, TRUE);
+		gtk_container_border_width(GTK_CONTAINER(win), 10);
+		gtk_widget_realize(win);
+		aol_icon(win->window);
+		gtk_signal_connect(GTK_OBJECT(win), "delete_event",
+				   GTK_SIGNAL_FUNC(delete_event_convo), c);
+	}
+	set_convo_title(c);
+
+	paned = gtk_vpaned_new();
+	gtk_paned_set_gutter_size(GTK_PANED(paned), 15);
+	gtk_container_add(GTK_CONTAINER(cont), paned);
+	gtk_widget_show(paned);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_paned_pack1(GTK_PANED(paned), vbox, FALSE, TRUE);
+	gtk_widget_show(vbox);
+
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	c->sw = sw;
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
+	gtk_box_pack_start(GTK_BOX(vbox), sw, TRUE, TRUE, 0);
+	gtk_widget_set_usize(sw, conv_size.width, conv_size.height);
+	gtk_widget_show(sw);
+
+	text = gtk_imhtml_new(NULL, NULL);
+	c->text = text;
+	gtk_container_add(GTK_CONTAINER(sw), text);
+	GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
+	GTK_LAYOUT(text)->vadjustment->step_increment = 10.0;
+	if (convo_options & OPT_CONVO_SHOW_TIME)
+		gtk_imhtml_show_comments(GTK_IMHTML(text), TRUE);
+	gaim_setup_imhtml(text);
+	gtk_widget_show(text);
+
+	vbox2 = gtk_vbox_new(FALSE, 5);
+	gtk_paned_pack2(GTK_PANED(paned), vbox2, FALSE, FALSE);
+	gtk_widget_show(vbox2);
+
+	hbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox2), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Send message as: "));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	c->menu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(hbox), c->menu, FALSE, FALSE, 5);
+	gtk_widget_show(c->menu);
+
+	create_convo_menu(c);
+
+	c->lbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox2), c->lbox, FALSE, FALSE, 0);
+	gtk_widget_show(c->lbox);
+
+	entry = gtk_text_new(NULL, NULL);
+	c->entry = entry;
+	if (!(im_options & OPT_IM_ONE_WINDOW))
+		gtk_window_set_focus(GTK_WINDOW(c->window), c->entry);
+
+	toolbar = build_conv_toolbar(c);
+	gtk_box_pack_start(GTK_BOX(vbox2), toolbar, FALSE, FALSE, 0);
+
+	gtk_object_set_user_data(GTK_OBJECT(entry), c);
+	gtk_text_set_editable(GTK_TEXT(entry), TRUE);
+	gtk_text_set_word_wrap(GTK_TEXT(entry), TRUE);
+	gtk_widget_set_usize(entry, conv_size.width - 20, MAX(conv_size.entry_height, 25));
+
+	gtk_signal_connect(GTK_OBJECT(entry), "activate", GTK_SIGNAL_FUNC(send_callback), c);
+	gtk_signal_connect(GTK_OBJECT(entry), "key_press_event", GTK_SIGNAL_FUNC(keypress_callback), c);
+	gtk_signal_connect(GTK_OBJECT(entry), "key_press_event", GTK_SIGNAL_FUNC(entry_key_pressed),
+			   entry);
+	if (convo_options & OPT_CONVO_CHECK_SPELLING)
+		gtkspell_attach(GTK_TEXT(c->entry));
+	gtk_box_pack_start(GTK_BOX(vbox2), entry, TRUE, TRUE, 0);
+	gtk_widget_show(entry);
+
+	c->bbox = bbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox2), bbox, FALSE, FALSE, 0);
+	gtk_widget_show(bbox);
+
+	close = picture_button2(win, _("Close"), cancel_xpm, dispstyle);
+	c->close = close;
+	gtk_object_set_user_data(GTK_OBJECT(close), c);
+	gtk_signal_connect(GTK_OBJECT(close), "clicked", GTK_SIGNAL_FUNC(close_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), close, dispstyle, dispstyle, 0);
+	gtk_widget_show(close);
+
+	c->sep1 = gtk_vseparator_new();
+	gtk_box_pack_end(GTK_BOX(bbox), c->sep1, dispstyle, dispstyle, 0);
+	gtk_widget_show(c->sep1);
+
+	if (c->gc && find_buddy(c->gc, c->name) != NULL) {
+		add = picture_button2(win, _("Remove"), gnome_remove_xpm, dispstyle);
+		gtk_object_set_user_data(GTK_OBJECT(add), c);
+	} else
+		add = picture_button2(win, _("Add"), gnome_add_xpm, dispstyle);
+	c->add = add;
+	gtk_signal_connect(GTK_OBJECT(add), "clicked", GTK_SIGNAL_FUNC(add_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), add, dispstyle, dispstyle, 0);
+	gtk_widget_show(add);
+
+	block = picture_button2(win, _("Block"), block_xpm, dispstyle);
+	c->block = block;
+	gtk_signal_connect(GTK_OBJECT(block), "clicked", GTK_SIGNAL_FUNC(block_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), block, dispstyle, dispstyle, 0);
+	gtk_widget_show(block);
+
+	warn = picture_button2(win, _("Warn"), warn_xpm, dispstyle);
+	c->warn = warn;
+	gtk_signal_connect(GTK_OBJECT(warn), "clicked", GTK_SIGNAL_FUNC(warn_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), warn, dispstyle, dispstyle, 0);
+	gtk_widget_show(warn);
+
+	info = picture_button2(win, _("Info"), tb_search_xpm, dispstyle);
+	c->info = info;
+
+	gtk_signal_connect(GTK_OBJECT(info), "clicked", GTK_SIGNAL_FUNC(info_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), info, dispstyle, dispstyle, 0);
+	gtk_widget_show(info);
+
+	c->sep2 = gtk_vseparator_new();
+	gtk_box_pack_end(GTK_BOX(bbox), c->sep2, dispstyle, dispstyle, 0);
+	gtk_widget_show(c->sep2);
+
+	send = picture_button2(win, _("Send"), tmp_send_xpm, dispstyle);
+	c->send = send;
+	gtk_signal_connect(GTK_OBJECT(send), "clicked", GTK_SIGNAL_FUNC(send_callback), c);
+	gtk_box_pack_end(GTK_BOX(bbox), send, dispstyle, dispstyle, 0);
+	gtk_widget_show(send);
+
+	update_buttons_by_protocol(c);
+
+	gtk_widget_show(win);
+}
+
+
+void toggle_spellchk()
+{
+	GList *cnv = conversations;
+	GSList *cht;
+	struct conversation *c;
+	GSList *con = connections;
+	struct gaim_connection *gc;
+
+	if (convo_options & OPT_CONVO_CHECK_SPELLING){
+		/*If ispell fails to start, start aspell. This is the way that
+		  Gabber does it. -- lorien420@myrealbox.com */
+		if (gtkspell_start(NULL, ispell_cmd)<0){
+			debug_printf("gtkspell failed to start when using ispell\n");
+			if (gtkspell_start(NULL, aspell_cmd)<0){
+				debug_printf("gtkspell failed to start when using aspell\n");
+			} else
+				debug_printf("gtkspell started with aspell\n");
+		} else {
+			debug_printf("gtkspell started with ispell\n");
+		}
+	}
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+		if (convo_options & OPT_CONVO_CHECK_SPELLING)
+			gtkspell_attach(GTK_TEXT(c->entry));
+		else
+			gtkspell_detach(GTK_TEXT(c->entry));
+		cnv = cnv->next;
+	}
+
+	while (con) {
+		gc = (struct gaim_connection *)con->data;
+		cht = gc->buddy_chats;
+		while (cht) {
+			c = (struct conversation *)cht->data;
+			if (convo_options & OPT_CONVO_CHECK_SPELLING)
+				gtkspell_attach(GTK_TEXT(c->entry));
+			else
+				gtkspell_detach(GTK_TEXT(c->entry));
+			cht = cht->next;
+		}
+		con = con->next;
+	}
+
+	if (!(convo_options & OPT_CONVO_CHECK_SPELLING))
+		gtkspell_stop();
+}
+
+void toggle_timestamps()
+{
+	GList *cnv = conversations;
+	GSList *cht;
+	struct conversation *c;
+	GSList *con = connections;
+	struct gaim_connection *gc;
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+		if (convo_options & OPT_CONVO_SHOW_TIME)
+			gtk_imhtml_show_comments(GTK_IMHTML(c->text), TRUE);
+		else
+			gtk_imhtml_show_comments(GTK_IMHTML(c->text), FALSE);
+		cnv = cnv->next;
+	}
+
+	while (con) {
+		gc = (struct gaim_connection *)con->data;
+		cht = gc->buddy_chats;
+		while (cht) {
+			c = (struct conversation *)cht->data;
+			if (convo_options & OPT_CONVO_SHOW_TIME)
+				gtk_imhtml_show_comments(GTK_IMHTML(c->text), TRUE);
+			else
+				gtk_imhtml_show_comments(GTK_IMHTML(c->text), FALSE);
+			cht = cht->next;
+		}
+		con = con->next;
+	}
+}
+
+void toggle_smileys()
+{
+	GList *cnv = conversations;
+	GSList *cht;
+	struct conversation *c;
+	GSList *con = connections;
+	struct gaim_connection *gc;
+
+	while (cnv) {
+		c = (struct conversation *)cnv->data;
+		if (convo_options & OPT_CONVO_SHOW_SMILEY)
+			gtk_imhtml_show_smileys(GTK_IMHTML(c->text), TRUE);
+		else
+			gtk_imhtml_show_smileys(GTK_IMHTML(c->text), FALSE);
+		cnv = cnv->next;
+	}
+
+	while (con) {
+		gc = (struct gaim_connection *)con->data;
+		cht = gc->buddy_chats;
+		while (cht) {
+			c = (struct conversation *)cht->data;
+			if (convo_options & OPT_CONVO_SHOW_SMILEY)
+				gtk_imhtml_show_smileys(GTK_IMHTML(c->text), TRUE);
+			else
+				gtk_imhtml_show_smileys(GTK_IMHTML(c->text), FALSE);
+			cht = cht->next;
+		}
+		con = con->next;
+	}
+}
+
+void im_tabize()
+{
+	/* evil, evil i tell you! evil! */
+	if (im_options & OPT_IM_ONE_WINDOW) {
+		GList *x = conversations;
+		if ((convo_options & OPT_CONVO_COMBINE) && (chat_options & OPT_CHAT_ONE_WINDOW)) {
+			all_convos = all_chats;
+			convo_notebook = chat_notebook;
+		}
+		while (x) {
+			struct conversation *c = x->data;
+			GtkWidget *imhtml, *win;
+
+			imhtml = c->text;
+			win = c->window;
+			remove_icon(c);
+			remove_checkbox(c);
+			show_conv(c);
+			gtk_widget_destroy(c->text);
+			gtk_widget_reparent(imhtml, c->sw);
+			c->text = imhtml;
+			gtk_widget_destroy(win);
+			update_icon(c);
+			update_checkbox(c);
+			set_convo_title(c);
+
+			x = x->next;
+		}
+	} else {
+		GList *x, *m;
+		x = m = conversations;
+		conversations = NULL;
+		while (x) {
+			struct conversation *c = x->data;
+			GtkWidget *imhtml;
+
+			imhtml = c->text;
+			remove_icon(c);
+			remove_checkbox(c);
+			show_conv(c);
+			gtk_container_remove(GTK_CONTAINER(c->sw), c->text);
+			gtk_widget_reparent(imhtml, c->sw);
+			c->text = imhtml;
+			update_icon(c);
+			update_checkbox(c);
+			set_convo_title(c);
+
+			x = x->next;
+		}
+		conversations = m;
+		if ((convo_options & OPT_CONVO_COMBINE) && (chat_options & OPT_CHAT_ONE_WINDOW)) {
+			if (chats) {
+				struct conversation *c;
+				while (m) {
+					gtk_notebook_remove_page(GTK_NOTEBOOK(chat_notebook), 0);
+					m = m->next;
+				}
+				c = chats->data;
+				gtk_window_set_focus(GTK_WINDOW(c->window), c->entry);
+			} else {
+				if (all_convos)
+					gtk_widget_destroy(all_convos);
+				all_chats = NULL;
+				chat_notebook = NULL;
+			}
+		} else if (all_convos)
+			gtk_widget_destroy(all_convos);
+		all_convos = NULL;
+		convo_notebook = NULL;
+	}
+}
+
+void convo_tabize()
+{
+	GList *x, *m;
+	GtkWidget *tmp;
+
+	if (!chats && !conversations)
+		return;
+
+	if (convo_options & OPT_CONVO_COMBINE) {
+		if (!chats) {
+			all_chats = all_convos;
+			chat_notebook = convo_notebook;
+			return;
+		} else if (!conversations) {
+			all_convos = all_chats;
+			convo_notebook = chat_notebook;
+			return;
+		}
+	} else {
+		if (!chats) {
+			all_chats = NULL;
+			chat_notebook = NULL;
+			return;
+		} else if (!conversations) {
+			all_convos = NULL;
+			convo_notebook = NULL;
+			return;
+		}
+	}
+
+	tmp = all_convos;
+	if (convo_options & OPT_CONVO_COMBINE) {
+		all_convos = all_chats;
+		convo_notebook = chat_notebook;
+	} else {
+		all_convos = NULL;
+		convo_notebook = NULL;
+	}
+	x = m = conversations;
+	while (x) {
+		struct conversation *c = x->data;
+		GtkWidget *imhtml;
+
+		imhtml = c->text;
+		remove_icon(c);
+		remove_checkbox(c);
+		show_conv(c);
+		gtk_container_remove(GTK_CONTAINER(c->sw), c->text);
+		gtk_widget_reparent(imhtml, c->sw);
+		c->text = imhtml;
+		update_icon(c);
+		update_checkbox(c);
+
+		x = x->next;
+	}
+
+	conversations = m;
+	if (convo_options & OPT_CONVO_COMBINE) {
+		if (tmp)
+			gtk_widget_destroy(tmp);
+	} else {
+		while (m) {
+			gtk_notebook_remove_page(GTK_NOTEBOOK(chat_notebook), 0);
+			m = m->next;
+		}
+	}
+	m = conversations;
+	while (m) {
+		set_convo_title(m->data);
+		m = m->next;
+	}
+}
+
+void set_convo_title(struct conversation *c)
+{
+	struct buddy *b;
+	char *text;
+	int index;
+	GtkNotebook *nb;
+
+	if ((im_options & OPT_IM_ALIAS_TAB) && c->gc && ((b = find_buddy(c->gc, c->name)) != NULL))
+		text = b->show;
+	else
+		text = c->name;
+
+	if (im_options & OPT_IM_ONE_WINDOW) {
+		nb = GTK_NOTEBOOK(convo_notebook);
+		index = g_list_index(conversations, c);
+		gtk_notebook_set_tab_label_text(nb, gtk_notebook_get_nth_page(nb, index), text);
+	} else {
+		char buf[256];
+		if ((find_log_info(c->name)) || (logging_options & OPT_LOG_ALL))
+			g_snprintf(buf, sizeof(buf), LOG_CONVERSATION_TITLE, text);
+		else
+			g_snprintf(buf, sizeof(buf), CONVERSATION_TITLE, text);
+		gtk_window_set_title(GTK_WINDOW(c->window), buf);
+	}
+}
+
+void set_convo_titles()
+{
+	GList *c = conversations;
+	while (c) {
+		set_convo_title(c->data);
+		c = c->next;
+	}
+}
+
+void raise_convo_tab(struct conversation *c)
+{
+	gtk_notebook_set_page(GTK_NOTEBOOK(convo_notebook), g_list_index(conversations, c));
+	gdk_window_show(c->window->window);
+}
+
+void update_im_tabs()
+{
+	if (!convo_notebook || !all_convos)
+		return;
+	if (im_options & OPT_IM_SIDE_TAB) {
+		if (im_options & OPT_IM_BR_TAB) {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook), GTK_POS_RIGHT);
+		} else {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook), GTK_POS_LEFT);
+		}
+	} else {
+		if (im_options & OPT_IM_BR_TAB) {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook), GTK_POS_BOTTOM);
+		} else {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(convo_notebook), GTK_POS_TOP);
+		}
+	}
+}
+
+void update_chat_tabs()
+{
+	if (!chat_notebook || !all_chats)
+		return;
+	if (chat_options & OPT_CHAT_SIDE_TAB) {
+		if (chat_options & OPT_CHAT_BR_TAB) {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook), GTK_POS_RIGHT);
+		} else {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook), GTK_POS_LEFT);
+		}
+	} else {
+		if (chat_options & OPT_CHAT_BR_TAB) {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook), GTK_POS_BOTTOM);
+		} else {
+			gtk_notebook_set_tab_pos(GTK_NOTEBOOK(chat_notebook), GTK_POS_TOP);
+		}
+	}
+}
+
+void update_convo_color(gboolean fg)
+{
+	GList *c = conversations;
+	struct conversation *b;
+
+	while (c) {
+		b = c->data;
+		c = c->next;
+		if (fg) {
+			if (b->hasfg)
+				continue;
+			b->fgcol = fgcolor;
+		} else {
+			if (b->hasbg)
+				continue;
+			b->bgcol = bgcolor;
+		}
+	}
+}
+
+void update_convo_font()
+{
+	GList *c = conversations;
+	struct conversation *b;
+
+	while (c) {
+		b = c->data;
+		c = c->next;
+		if (b->hasfont)
+			continue;
+		sprintf(b->fontface, "%s", fontface);
+		sprintf(b->fontxfld, "%s", fontxfld);
+	}
+}
+
+#if USE_PIXBUF
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+#define SCALE(x) ((gdk_pixbuf_animation_get_width(x) <= 48 && gdk_pixbuf_animation_get_height(x) <= 48) \
+		 ? 48 : 50)
+
+static gboolean redraw_icon(gpointer data)
+{
+	struct conversation *c = data;
+
+	GList *frames;
+	GdkPixbufFrame *frame;
+	GdkPixbuf *buf;
+	GdkPixbuf *scale;
+	GdkPixmap *src;
+	GdkPixmap *pm;
+	GdkBitmap *bm;
+	GdkGC *gc;
+	gint delay;
+
+	if (!g_list_find(conversations, c)) {
+		debug_printf("I think this is a bug.\n");
+		return FALSE;
+	}
+
+	frames = gdk_pixbuf_animation_get_frames(c->anim);
+	frame = g_list_nth_data(frames, c->frame);
+	switch (gdk_pixbuf_frame_get_action(frame)) {
+	case GDK_PIXBUF_FRAME_RETAIN:
+		buf = gdk_pixbuf_frame_get_pixbuf(frame);
+		scale = gdk_pixbuf_scale_simple(buf,
+						MAX(gdk_pixbuf_get_width(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_width(c->anim), 1),
+						MAX(gdk_pixbuf_get_height(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_height(c->anim), 1),
+						GDK_INTERP_NEAREST);
+		gdk_pixbuf_render_pixmap_and_mask(scale, &src, &bm, 100);
+		gdk_pixbuf_unref(scale);
+		gtk_pixmap_get(GTK_PIXMAP(c->icon), &pm, NULL);
+		gc = gdk_gc_new(pm);
+		gdk_gc_set_clip_mask(gc, bm);
+
+		gdk_gc_set_clip_origin(gc, gdk_pixbuf_frame_get_x_offset(frame) *
+				       SCALE(c->anim)/gdk_pixbuf_animation_get_width(c->anim),  
+				       gdk_pixbuf_frame_get_y_offset(frame) *
+				       SCALE(c->anim)/gdk_pixbuf_animation_get_height(c->anim));   
+		gdk_draw_pixmap(pm, gc, src, 0, 0, gdk_pixbuf_frame_get_x_offset(frame)*
+				SCALE(c->anim)/gdk_pixbuf_animation_get_width(c->anim),
+				gdk_pixbuf_frame_get_y_offset(frame) * 
+				SCALE(c->anim)/gdk_pixbuf_animation_get_height(c->anim),-1,-1);
+		
+		gdk_pixmap_unref(src);
+		if (bm)
+			gdk_bitmap_unref(bm);
+		gtk_widget_queue_draw(c->icon);
+		gdk_gc_unref(gc);
+		break;
+	case GDK_PIXBUF_FRAME_DISPOSE:
+		buf = gdk_pixbuf_frame_get_pixbuf(frame);
+		scale = gdk_pixbuf_scale_simple(buf,
+						MAX(gdk_pixbuf_get_width(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_width(c->anim), 1),
+						MAX(gdk_pixbuf_get_height(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_height(c->anim), 1),
+						GDK_INTERP_NEAREST);
+		gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+		gdk_pixbuf_unref(scale);
+		gtk_pixmap_set(GTK_PIXMAP(c->icon), pm, bm);
+		gdk_pixmap_unref(pm);
+		if (bm)
+			gdk_bitmap_unref(bm);
+		break;
+	case GDK_PIXBUF_FRAME_REVERT:
+		frame = frames->data;
+		buf = gdk_pixbuf_frame_get_pixbuf(frame);
+		scale = gdk_pixbuf_scale_simple(buf,
+						MAX(gdk_pixbuf_get_width(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_width(c->anim), 1),
+						MAX(gdk_pixbuf_get_height(buf) * SCALE(c->anim) /
+						    gdk_pixbuf_animation_get_height(c->anim), 1),
+						GDK_INTERP_NEAREST);
+		gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+		gdk_pixbuf_unref(scale);
+		gtk_pixmap_set(GTK_PIXMAP(c->icon), pm, bm);
+		gdk_pixmap_unref(pm);
+		if (bm)
+			gdk_bitmap_unref(bm);
+		break;
+	}
+
+	c->frame = (c->frame + 1) % g_list_length(frames);
+	delay = MAX(gdk_pixbuf_frame_get_delay_time(frame), 13);
+	c->icon_timer = gtk_timeout_add(delay * 10, redraw_icon, c);
+
+	return FALSE;
+}
+
+static void stop_anim(GtkObject *obj, struct conversation *c)
+{
+	if (c->icon_timer)
+		gtk_timeout_remove(c->icon_timer);
+	c->icon_timer = 0;
+}
+
+static void start_anim(GtkObject *obj, struct conversation *c)
+{
+	GList *frames;
+	GdkPixbufFrame *frame;
+	int delay;
+
+	frames = gdk_pixbuf_animation_get_frames(c->anim);
+	frame = g_list_nth_data(frames, c->frame);
+	delay = MAX(gdk_pixbuf_frame_get_delay_time(frame), 13);
+	if (c->anim)
+	    c->icon_timer = gtk_timeout_add(delay * 10, redraw_icon, c);
+}
+
+static int des_save_icon(GtkObject *obj, GdkEvent *e, struct conversation *c)
+{
+	gtk_widget_destroy(c->save_icon);
+	c->save_icon = NULL;
+	return TRUE;
+}
+
+static void do_save_icon(GtkObject *obj, struct conversation *c)
+{
+	FILE *file;
+	char *f = gtk_file_selection_get_filename(GTK_FILE_SELECTION(c->save_icon));
+	if (file_is_dir(f, c->save_icon))
+		return;
+
+	file = fopen(f, "w");
+	if (file) {
+		int len;
+		void *data = get_icon_data(c->gc, normalize(c->name), &len);
+		if (data)
+			fwrite(data, 1, len, file);
+		fclose(file);
+	} else {
+		do_error_dialog("Can't open file for writing", "Error");
+	}
+
+	gtk_widget_destroy(c->save_icon);
+	c->save_icon = NULL;
+}
+
+static void cancel_save_icon(GtkObject *obj, struct conversation *c)
+{
+	gtk_widget_destroy(c->save_icon);
+	c->save_icon = NULL;
+}
+
+static void save_icon(GtkObject *obj, struct conversation *c)
+{
+	char buf[BUF_LEN];
+
+	if (c->save_icon) {
+		gdk_window_raise(c->save_icon->window);
+		return;
+	}
+
+	c->save_icon = gtk_file_selection_new(_("Gaim - Save Icon"));
+	gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(c->save_icon));
+	g_snprintf(buf, BUF_LEN - 1, "%s/%s.icon", g_get_home_dir(), c->name);
+	gtk_file_selection_set_filename(GTK_FILE_SELECTION(c->save_icon), buf);
+	gtk_signal_connect(GTK_OBJECT(c->save_icon), "delete_event",
+			   GTK_SIGNAL_FUNC(des_save_icon), c);
+	gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(c->save_icon)->ok_button), "clicked",
+			   GTK_SIGNAL_FUNC(do_save_icon), c);
+	gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(c->save_icon)->cancel_button), "clicked",
+			   GTK_SIGNAL_FUNC(cancel_save_icon), c);
+
+	gtk_widget_show(c->save_icon);
+}
+
+static gboolean icon_menu(GtkObject *obj, GdkEventButton *e, struct conversation *c)
+{
+	GtkWidget *menu;
+	GtkWidget *button;
+
+	if (e->button != 3)
+		return FALSE;
+	if (e->type != GDK_BUTTON_PRESS)
+		return FALSE;
+
+	menu = gtk_menu_new();
+
+	if (c->icon_timer) {
+		button = gtk_menu_item_new_with_label(_("Disable Animation"));
+		gtk_signal_connect(GTK_OBJECT(button), "activate", GTK_SIGNAL_FUNC(stop_anim), c);
+		gtk_menu_append(GTK_MENU(menu), button);
+		gtk_widget_show(button);
+	} else if (c->anim && (gdk_pixbuf_animation_get_num_frames(c->anim) > 1)) {
+		button = gtk_menu_item_new_with_label(_("Enable Animation"));
+		gtk_signal_connect(GTK_OBJECT(button), "activate", GTK_SIGNAL_FUNC(start_anim), c);
+		gtk_menu_append(GTK_MENU(menu), button);
+		gtk_widget_show(button);
+	}
+
+	button = gtk_menu_item_new_with_label(_("Hide Icon"));
+	gtk_signal_connect_object(GTK_OBJECT(button), "activate",
+				  GTK_SIGNAL_FUNC(remove_icon), (void *)c);
+	gtk_menu_append(GTK_MENU(menu), button);
+	gtk_widget_show(button);
+
+	button = gtk_menu_item_new_with_label(_("Save Icon As..."));
+	gtk_signal_connect(GTK_OBJECT(button), "activate", GTK_SIGNAL_FUNC(save_icon), c);
+	gtk_menu_append(GTK_MENU(menu), button);
+	gtk_widget_show(button);
+
+	gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, e->button, e->time);
+
+	return TRUE;
+}
+#endif
+
+void remove_icon(struct conversation *c)
+{
+#if USE_PIXBUF
+	if (c->icon)
+		gtk_container_remove(GTK_CONTAINER(c->bbox), c->icon->parent->parent);
+	c->icon = NULL;
+	if (c->anim)
+		gdk_pixbuf_animation_unref(c->anim);
+	c->anim = NULL;
+	if (c->icon_timer)
+		gtk_timeout_remove(c->icon_timer);
+	c->icon_timer = 0;
+	c->frame = 0;
+#endif
+}
+
+void update_smilies(struct conversation *c)
+{
+	GSList *smilies;
+
+	if (!c)
+		return;
+
+	if (!c->gc)
+		return;
+
+	if (c->gc->prpl->smiley_list) {
+		gtk_imhtml_remove_smileys(GTK_IMHTML(c->text));
+		smilies = c->gc->prpl->smiley_list();
+
+		while (smilies) {
+			struct _prpl_smiley *smile =
+				(struct _prpl_smiley *)smilies->data;
+
+			gtk_imhtml_associate_smiley(GTK_IMHTML(c->text), smile->key, smile->xpm);
+			smilies = g_slist_next(smilies);
+		}
+	} else {
+		gtk_imhtml_reset_smileys(GTK_IMHTML(c->text));
+	}
+}
+
+void update_icon(struct conversation *c)
+{
+#if USE_PIXBUF
+	char filename[256];
+	FILE *file;
+
+	void *data;
+	int len;
+
+	GList *frames;
+	GdkPixbuf *buf;
+
+	GtkWidget *event;
+	GtkWidget *frame;
+	GdkPixbuf *scale;
+	GdkPixmap *pm;
+	GdkBitmap *bm;
+	int sf = 0;
+
+	if (!c)
+		return;
+
+	remove_icon(c);
+
+	if (im_options & OPT_IM_HIDE_ICONS)
+		return;
+
+	if (!c->gc)
+		return;
+
+	data = get_icon_data(c->gc, normalize(c->name), &len);
+	if (!data)
+		return;
+
+	/* this is such an evil hack, i don't know why i'm even considering it.
+	 * we'll do it differently when gdk-pixbuf-loader isn't leaky anymore. */
+	g_snprintf(filename, sizeof(filename), "%s/gaimicon-%s.%d", g_get_tmp_dir(), c->name, getpid());
+	file = fopen(filename, "w");
+	if (!file)
+		return;
+	fwrite(data, 1, len, file);
+	fclose(file);
+
+	c->anim = gdk_pixbuf_animation_new_from_file(filename);
+	/* make sure we remove the file as soon as possible */
+	unlink(filename);
+
+	if (!c->anim)
+		return;
+
+	frames = gdk_pixbuf_animation_get_frames(c->anim);
+	buf = gdk_pixbuf_frame_get_pixbuf(frames->data);
+	sf = SCALE(c->anim);
+	scale = gdk_pixbuf_scale_simple(buf,
+					MAX(gdk_pixbuf_get_width(buf) * sf /
+					    gdk_pixbuf_animation_get_width(c->anim), 1),
+					MAX(gdk_pixbuf_get_height(buf) * sf /
+					    gdk_pixbuf_animation_get_height(c->anim), 1),
+					GDK_INTERP_NEAREST);
+
+	if (gdk_pixbuf_animation_get_num_frames(c->anim) > 1) {
+		int delay = MAX(gdk_pixbuf_frame_get_delay_time(frames->data), 13);
+		c->frame = 1;
+		c->icon_timer = gtk_timeout_add(delay * 10, redraw_icon, c);
+	}
+
+	gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+	gdk_pixbuf_unref(scale);
+
+	frame = gtk_frame_new(NULL);
+	gtk_frame_set_shadow_type(GTK_FRAME(frame), bm ? GTK_SHADOW_NONE : GTK_SHADOW_IN);
+	gtk_box_pack_start(GTK_BOX(c->bbox), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	event = gtk_event_box_new();
+	gtk_container_add(GTK_CONTAINER(frame), event);
+	gtk_signal_connect(GTK_OBJECT(event), "button-press-event", GTK_SIGNAL_FUNC(icon_menu), c);
+	gtk_widget_show(event);
+
+	c->icon = gtk_pixmap_new(pm, bm);
+	gtk_widget_set_usize(c->icon, sf, sf);
+	gtk_container_add(GTK_CONTAINER(event), c->icon);
+	gtk_widget_show(c->icon);
+	if(im_options & OPT_IM_NO_ANIMATION)
+		stop_anim(NULL, c);		
+	gdk_pixmap_unref(pm);
+	if (bm)
+		gdk_bitmap_unref(bm);
+#endif
+}
+
+void got_new_icon(struct gaim_connection *gc, char *who)
+{
+	struct conversation *c = find_conversation(who);
+	if (c && (c->gc == gc))
+		update_icon(c);
+}
+
+void set_hide_icons()
+{
+	GList *c = conversations;
+	while (c) {
+		update_icon(c->data);
+		c = c->next;
+	}
+}
+
+void set_anim()
+{
+#if USE_PIXBUF
+	GList *c = conversations;
+	if (im_options & OPT_IM_HIDE_ICONS)
+		return;
+	while (c) {
+		if(im_options & OPT_IM_NO_ANIMATION)
+			stop_anim(NULL, c->data);
+		else 
+			start_anim(NULL, c->data);
+		c = c->next;
+	}
+#endif
+}
+
+static void remove_checkbox(struct conversation *c)
+{
+	if (c->check)
+		gtk_container_remove(GTK_CONTAINER(c->lbox), c->check);
+	c->check = NULL;
+}
+
+static void update_checkbox(struct conversation *c)
+{
+	if (!c)
+		return;
+
+	remove_checkbox(c);
+
+	if (!c->gc)
+		return;
+
+	if (!c->gc->checkbox)
+		return;
+
+	c->check = gtk_check_button_new_with_label(c->gc->checkbox);
+	gtk_box_pack_start(GTK_BOX(c->lbox), c->check, FALSE, FALSE, 5);
+	gtk_widget_show(c->check);
+}
diff -Nru gaim-0.58/src/dialogs.c gaim-0.58-t/src/dialogs.c
--- gaim-0.58/src/dialogs.c	Sun May  5 16:19:40 2002
+++ gaim-0.58-t/src/dialogs.c	Wed Jun 12 20:09:47 2002
@@ -86,8 +86,10 @@
 
 int smiley_array[FACE_TOTAL];
 char *current_smiley;
-GdkColor bgcolor;
-GdkColor fgcolor;
+GdkColor out_bgcolor;
+GdkColor out_fgcolor;
+GdkColor def_bgcolor;
+GdkColor def_fgcolor;
 
 static GtkWidget *imdialog = NULL;	/*I only want ONE of these :) */
 static GList *dialogwindows = NULL;
@@ -285,12 +287,12 @@
 
 	if (GTK_IS_COLOR_SELECTION_DIALOG(w)) {
 		set_state_lock(1);
-		if (w == c->fg_color_dialog) {
+		if (w == c->out_fg_color_dialog) {
 			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(c->fgcolorbtn), FALSE);
-			c->fg_color_dialog = NULL;
+			c->out_fg_color_dialog = NULL;
 		} else {
 			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(c->bgcolorbtn), FALSE);
-			c->bg_color_dialog = NULL;
+			c->out_bg_color_dialog = NULL;
 		}
 		set_state_lock(0);
 	} else if (GTK_IS_FONT_SELECTION_DIALOG(w)) {
@@ -1946,6 +1948,17 @@
 		gtk_box_pack_start(GTK_BOX(bbox), sw, TRUE, TRUE, 0);
 
 		text = gtk_imhtml_new(NULL, NULL);
+
+		if ((trans_options & OPT_TRANS_INFO) == OPT_TRANS_INFO)
+			gtk_imhtml_set_background(GTK_IMHTML(text), NULL, 1, 1);
+
+		gtk_signal_connect_object(GTK_OBJECT(b->window), "configure_event",
+								  GTK_SIGNAL_FUNC(win_move), GTK_OBJECT(text));
+#if 0
+		gtk_signal_connect(GTK_OBJECT(b->window), "configure_event",
+				   GTK_SIGNAL_FUNC(win_move), text);
+#endif
+
 		b->text = text;
 		gtk_container_add(GTK_CONTAINER(sw), text);
 		GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
@@ -2576,31 +2589,45 @@
 static GtkWidget *fgcseld = NULL;
 static GtkWidget *bgcseld = NULL;
 
-void cancel_fgcolor(GtkWidget *widget, struct conversation *c)
+void cancel_out_fgcolor(GtkWidget *widget, struct conversation *c)
 {
 	if (c->fgcolorbtn && widget) {
 		set_state_lock(1);
 		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(c->fgcolorbtn), FALSE);
 		set_state_lock(0);
 	}
-	dialogwindows = g_list_remove(dialogwindows, c->fg_color_dialog);
-	gtk_widget_destroy(c->fg_color_dialog);
-	c->fg_color_dialog = NULL;
+	dialogwindows = g_list_remove(dialogwindows, c->out_fg_color_dialog);
+	gtk_widget_destroy(c->out_fg_color_dialog);
+	c->out_fg_color_dialog = NULL;
+}
+
+void cancel_def_fgcolor(GtkWidget *widget, struct conversation *c)
+{
+	dialogwindows = g_list_remove(dialogwindows, c->def_fg_color_dialog);
+	gtk_widget_destroy(c->def_fg_color_dialog);
+	c->def_fg_color_dialog = NULL;
 }
 
-void cancel_bgcolor(GtkWidget *widget, struct conversation *c)
+void cancel_out_bgcolor(GtkWidget *widget, struct conversation *c)
 {
 	if (c->bgcolorbtn && widget) {
 		set_state_lock(1);
 		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(c->bgcolorbtn), FALSE);
 		set_state_lock(0);
 	}
-	dialogwindows = g_list_remove(dialogwindows, c->bg_color_dialog);
-	gtk_widget_destroy(c->bg_color_dialog);
-	c->bg_color_dialog = NULL;
+	dialogwindows = g_list_remove(dialogwindows, c->out_bg_color_dialog);
+	gtk_widget_destroy(c->out_bg_color_dialog);
+	c->out_bg_color_dialog = NULL;
+}
+
+void cancel_def_bgcolor(GtkWidget *widget, struct conversation *c)
+{
+	dialogwindows = g_list_remove(dialogwindows, c->def_bg_color_dialog);
+	gtk_widget_destroy(c->def_bg_color_dialog);
+	c->def_bg_color_dialog = NULL;
 }
 
-void do_fgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
+void do_out_fgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
 {
 	gdouble color[3];
 	GdkColor text_color;
@@ -2618,17 +2645,73 @@
 	text_color.green = ((guint16)(color[1] * 65535)) >> 8;
 	text_color.blue = ((guint16)(color[2] * 65535)) >> 8;
 
-	c->fgcol = text_color;
-	c->hasfg = 1;
+	c->out_fgcol = text_color;
+	c->has_out_fg = 1;
 	g_snprintf(open_tag, 23, "<FONT COLOR=\"#%02X%02X%02X\">", text_color.red, text_color.green,
 		   text_color.blue);
 	surround(c->entry, open_tag, "</FONT>");
 	debug_printf("#%02X%02X%02X\n", text_color.red, text_color.green, text_color.blue);
 	g_free(open_tag);
-	cancel_fgcolor(NULL, c);
+	cancel_out_fgcolor(NULL, c);
+}
+
+void do_def_fgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
+{
+	gdouble color[3];
+	GdkColor text_color;
+	struct conversation *c;
+	char *open_tag;
+
+	open_tag = g_malloc(30);
+
+	gtk_color_selection_get_color(colorsel, color);
+
+	c = gtk_object_get_user_data(GTK_OBJECT(colorsel));
+	/* GTK_IS_EDITABLE(c->entry); huh? */
+
+	text_color.red = ((guint16)(color[0] * 65535)) >> 8;
+	text_color.green = ((guint16)(color[1] * 65535)) >> 8;
+	text_color.blue = ((guint16)(color[2] * 65535)) >> 8;
+
+	c->def_fgcol = text_color;
+	c->has_def_fg = 1;
+	g_snprintf(open_tag, 23, "<FONT COLOR=\"#%02X%02X%02X\">", text_color.red, text_color.green,
+		   text_color.blue);
+	surround(c->entry, open_tag, "</FONT>");
+	debug_printf("#%02X%02X%02X\n", text_color.red, text_color.green, text_color.blue);
+	g_free(open_tag);
+	cancel_def_fgcolor(NULL, c);
+}
+
+void do_out_bgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
+{
+	gdouble color[3];
+	GdkColor text_color;
+	struct conversation *c;
+	char *open_tag;
+
+	open_tag = g_malloc(30);
+
+	gtk_color_selection_get_color(colorsel, color);
+
+	c = gtk_object_get_user_data(GTK_OBJECT(colorsel));
+	/* GTK_IS_EDITABLE(c->entry); huh? */
+
+	text_color.red = ((guint16)(color[0] * 65535)) >> 8;
+	text_color.green = ((guint16)(color[1] * 65535)) >> 8;
+	text_color.blue = ((guint16)(color[2] * 65535)) >> 8;
+
+	c->out_bgcol = text_color;
+	c->has_out_bg = 1;
+	g_snprintf(open_tag, 25, "<BODY BGCOLOR=\"#%02X%02X%02X\">", text_color.red, text_color.green,
+		   text_color.blue);
+	surround(c->entry, open_tag, "</BODY>");
+	debug_printf("#%02X%02X%02X\n", text_color.red, text_color.green, text_color.blue);
+	g_free(open_tag);
+	cancel_out_bgcolor(NULL, c);
 }
 
-void do_bgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
+void do_def_bgcolor(GtkWidget *widget, GtkColorSelection *colorsel)
 {
 	gdouble color[3];
 	GdkColor text_color;
@@ -2646,14 +2729,14 @@
 	text_color.green = ((guint16)(color[1] * 65535)) >> 8;
 	text_color.blue = ((guint16)(color[2] * 65535)) >> 8;
 
-	c->bgcol = text_color;
-	c->hasbg = 1;
+	c->def_bgcol = text_color;
+	c->has_def_bg = 1;
 	g_snprintf(open_tag, 25, "<BODY BGCOLOR=\"#%02X%02X%02X\">", text_color.red, text_color.green,
 		   text_color.blue);
 	surround(c->entry, open_tag, "</BODY>");
 	debug_printf("#%02X%02X%02X\n", text_color.red, text_color.green, text_color.blue);
 	g_free(open_tag);
-	cancel_bgcolor(NULL, c);
+	cancel_def_bgcolor(NULL, c);
 }
 
 static void destroy_colorsel(GtkWidget *w, gpointer d)
@@ -2667,7 +2750,33 @@
 	}
 }
 
-static void apply_color_dlg(GtkWidget *w, gpointer d)
+static void apply_out_color_dlg(GtkWidget *w, gpointer d)
+{
+	gdouble color[3];
+	if ((int)d == 1) {
+		gtk_color_selection_get_color(GTK_COLOR_SELECTION
+					      (GTK_COLOR_SELECTION_DIALOG(fgcseld)->colorsel), color);
+		destroy_colorsel(NULL, (void *)1);
+
+		out_fgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
+		out_fgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
+		out_fgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
+		update_color(NULL, pref_out_fg_picture);
+		update_convo_color(TRUE);
+	} else {
+		gtk_color_selection_get_color(GTK_COLOR_SELECTION
+					      (GTK_COLOR_SELECTION_DIALOG(bgcseld)->colorsel), color);
+		destroy_colorsel(NULL, (void *)0);
+
+		out_bgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
+		out_bgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
+		out_bgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
+		update_color(NULL, pref_out_bg_picture);
+		update_convo_color(FALSE);
+	}
+}
+
+static void apply_def_color_dlg(GtkWidget *w, gpointer d)
 {
 	gdouble color[3];
 	if ((int)d == 1) {
@@ -2675,25 +2784,79 @@
 					      (GTK_COLOR_SELECTION_DIALOG(fgcseld)->colorsel), color);
 		destroy_colorsel(NULL, (void *)1);
 
-		fgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
-		fgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
-		fgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
-		update_color(NULL, pref_fg_picture);
+		def_fgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
+		def_fgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
+		def_fgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
+		update_color(NULL, pref_def_fg_picture);
 		update_convo_color(TRUE);
 	} else {
 		gtk_color_selection_get_color(GTK_COLOR_SELECTION
 					      (GTK_COLOR_SELECTION_DIALOG(bgcseld)->colorsel), color);
 		destroy_colorsel(NULL, (void *)0);
 
-		bgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
-		bgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
-		bgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
-		update_color(NULL, pref_bg_picture);
+		def_bgcolor.red = ((guint16)(color[0] * 65535)) >> 8;
+		def_bgcolor.green = ((guint16)(color[1] * 65535)) >> 8;
+		def_bgcolor.blue = ((guint16)(color[2] * 65535)) >> 8;
+		update_color(NULL, pref_def_bg_picture);
 		update_convo_color(FALSE);
 	}
 }
 
-void show_fgcolor_dialog(struct conversation *c, GtkWidget *color)
+void show_out_fgcolor_dialog(struct conversation *c, GtkWidget *color)
+{
+	GtkWidget *colorsel;
+	gdouble fgclr[3];
+
+	if (color == NULL) { /* we came from the prefs */
+		if (fgcseld)
+			return;
+		fgclr[0] = (gdouble)(c->out_fgcol.red) / 255;
+		fgclr[1] = (gdouble)(c->out_fgcol.green) / 255;
+		fgclr[2] = (gdouble)(c->out_fgcol.blue) / 255;
+
+		fgcseld = gtk_color_selection_dialog_new(_("Select Text Color"));
+		gtk_color_selection_set_color(GTK_COLOR_SELECTION
+					      (GTK_COLOR_SELECTION_DIALOG(fgcseld)->colorsel), fgclr);
+		gtk_signal_connect(GTK_OBJECT(fgcseld), "delete_event",
+				   GTK_SIGNAL_FUNC(destroy_colorsel), (void *)1);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(fgcseld)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(destroy_colorsel), (void *)1);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(fgcseld)->ok_button), "clicked",
+				   GTK_SIGNAL_FUNC(apply_out_color_dlg), (void *)1);
+		gtk_widget_realize(fgcseld);
+		aol_icon(fgcseld->window);
+		gtk_widget_show(fgcseld);
+		gdk_window_raise(fgcseld->window);
+		return;
+	}
+
+	if (!c->out_fg_color_dialog) {
+		fgclr[0] = (gdouble)(c->out_fgcol.red) / 255;
+		fgclr[1] = (gdouble)(c->out_fgcol.green) / 255;
+		fgclr[2] = (gdouble)(c->out_fgcol.blue) / 255;
+
+		c->out_fg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
+		colorsel = GTK_COLOR_SELECTION_DIALOG(c->out_fg_color_dialog)->colorsel;
+		gtk_color_selection_set_color(GTK_COLOR_SELECTION(colorsel), fgclr);
+		gtk_object_set_user_data(GTK_OBJECT(colorsel), c);
+
+		gtk_signal_connect(GTK_OBJECT(c->out_fg_color_dialog), "delete_event",
+				   GTK_SIGNAL_FUNC(delete_event_dialog), c);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->out_fg_color_dialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC(do_out_fgcolor), colorsel);
+		gtk_signal_connect(GTK_OBJECT
+				   (GTK_COLOR_SELECTION_DIALOG(c->out_fg_color_dialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(cancel_out_fgcolor), c);
+
+		gtk_widget_realize(c->out_fg_color_dialog);
+		aol_icon(c->out_fg_color_dialog->window);
+	}
+
+	gtk_widget_show(c->out_fg_color_dialog);
+	gdk_window_raise(c->out_fg_color_dialog->window);
+}
+
+void show_def_fgcolor_dialog(struct conversation *c, GtkWidget *color)
 {
 	GtkWidget *colorsel;
 	gdouble fgclr[3];
@@ -2701,9 +2864,9 @@
 	if (color == NULL) {	/* we came from the prefs */
 		if (fgcseld)
 			return;
-		fgclr[0] = (gdouble)(fgcolor.red) / 255;
-		fgclr[1] = (gdouble)(fgcolor.green) / 255;
-		fgclr[2] = (gdouble)(fgcolor.blue) / 255;
+		fgclr[0] = (gdouble)(def_fgcolor.red) / 255;
+		fgclr[1] = (gdouble)(def_fgcolor.green) / 255;
+		fgclr[2] = (gdouble)(def_fgcolor.blue) / 255;
 
 		fgcseld = gtk_color_selection_dialog_new(_("Select Text Color"));
 		gtk_color_selection_set_color(GTK_COLOR_SELECTION
@@ -2713,7 +2876,7 @@
 		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(fgcseld)->cancel_button),
 				   "clicked", GTK_SIGNAL_FUNC(destroy_colorsel), (void *)1);
 		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(fgcseld)->ok_button), "clicked",
-				   GTK_SIGNAL_FUNC(apply_color_dlg), (void *)1);
+				   GTK_SIGNAL_FUNC(apply_def_color_dlg), (void *)1);
 		gtk_widget_realize(fgcseld);
 		aol_icon(fgcseld->window);
 		gtk_widget_show(fgcseld);
@@ -2721,33 +2884,87 @@
 		return;
 	}
 
-	if (!c->fg_color_dialog) {
-		fgclr[0] = (gdouble)(c->fgcol.red) / 255;
-		fgclr[1] = (gdouble)(c->fgcol.green) / 255;
-		fgclr[2] = (gdouble)(c->fgcol.blue) / 255;
+	if (!c->def_fg_color_dialog) {
+		fgclr[0] = (gdouble)(c->out_fgcol.red) / 255;
+		fgclr[1] = (gdouble)(c->out_fgcol.green) / 255;
+		fgclr[2] = (gdouble)(c->out_fgcol.blue) / 255;
 
-		c->fg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
-		colorsel = GTK_COLOR_SELECTION_DIALOG(c->fg_color_dialog)->colorsel;
+		c->def_fg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
+		colorsel = GTK_COLOR_SELECTION_DIALOG(c->def_fg_color_dialog)->colorsel;
 		gtk_color_selection_set_color(GTK_COLOR_SELECTION(colorsel), fgclr);
 		gtk_object_set_user_data(GTK_OBJECT(colorsel), c);
 
-		gtk_signal_connect(GTK_OBJECT(c->fg_color_dialog), "delete_event",
+		gtk_signal_connect(GTK_OBJECT(c->def_fg_color_dialog), "delete_event",
+				   GTK_SIGNAL_FUNC(delete_event_dialog), c);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->def_fg_color_dialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC(do_def_fgcolor), colorsel);
+		gtk_signal_connect(GTK_OBJECT
+				   (GTK_COLOR_SELECTION_DIALOG(c->def_fg_color_dialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(cancel_def_fgcolor), c);
+
+		gtk_widget_realize(c->def_fg_color_dialog);
+		aol_icon(c->def_fg_color_dialog->window);
+	}
+
+	gtk_widget_show(c->def_fg_color_dialog);
+	gdk_window_raise(c->def_fg_color_dialog->window);
+}
+
+void show_out_bgcolor_dialog(struct conversation *c, GtkWidget *color)
+{
+	GtkWidget *colorsel;
+	gdouble bgclr[3];
+
+	if (color == NULL) {	/* we came from the prefs */
+		if (bgcseld)
+			return;
+		bgclr[0] = (gdouble)(out_bgcolor.red) / 255;
+		bgclr[1] = (gdouble)(out_bgcolor.green) / 255;
+		bgclr[2] = (gdouble)(out_bgcolor.blue) / 255;
+
+		bgcseld = gtk_color_selection_dialog_new(_("Select Background Color"));
+		gtk_color_selection_set_color(GTK_COLOR_SELECTION
+					      (GTK_COLOR_SELECTION_DIALOG(bgcseld)->colorsel), bgclr);
+		gtk_signal_connect(GTK_OBJECT(bgcseld), "delete_event",
+				   GTK_SIGNAL_FUNC(destroy_colorsel), NULL);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(bgcseld)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(destroy_colorsel), NULL);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(bgcseld)->ok_button), "clicked",
+				   GTK_SIGNAL_FUNC(apply_out_color_dlg), (void *)2);
+		gtk_widget_realize(bgcseld);
+		aol_icon(bgcseld->window);
+		gtk_widget_show(bgcseld);
+		gdk_window_raise(bgcseld->window);
+		return;
+	}
+
+	if (!c->out_bg_color_dialog) {
+		bgclr[0] = (gdouble)(c->out_bgcol.red) / 255;
+		bgclr[1] = (gdouble)(c->out_bgcol.green) / 255;
+		bgclr[2] = (gdouble)(c->out_bgcol.blue) / 255;
+
+		c->out_bg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
+		colorsel = GTK_COLOR_SELECTION_DIALOG(c->out_bg_color_dialog)->colorsel;
+		gtk_color_selection_set_color(GTK_COLOR_SELECTION(colorsel), bgclr);
+		gtk_object_set_user_data(GTK_OBJECT(colorsel), c);
+
+		gtk_signal_connect(GTK_OBJECT(c->out_bg_color_dialog), "delete_event",
 				   GTK_SIGNAL_FUNC(delete_event_dialog), c);
-		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->fg_color_dialog)->ok_button),
-				   "clicked", GTK_SIGNAL_FUNC(do_fgcolor), colorsel);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->out_bg_color_dialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC(do_out_bgcolor), colorsel);
 		gtk_signal_connect(GTK_OBJECT
-				   (GTK_COLOR_SELECTION_DIALOG(c->fg_color_dialog)->cancel_button),
-				   "clicked", GTK_SIGNAL_FUNC(cancel_fgcolor), c);
+				   (GTK_COLOR_SELECTION_DIALOG(c->out_bg_color_dialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(cancel_out_bgcolor), c);
 
-		gtk_widget_realize(c->fg_color_dialog);
-		aol_icon(c->fg_color_dialog->window);
+		gtk_widget_realize(c->out_bg_color_dialog);
+		aol_icon(c->out_bg_color_dialog->window);
 	}
 
-	gtk_widget_show(c->fg_color_dialog);
-	gdk_window_raise(c->fg_color_dialog->window);
+	gtk_widget_show(c->out_bg_color_dialog);
+	gdk_window_raise(c->out_bg_color_dialog->window);
 }
 
-void show_bgcolor_dialog(struct conversation *c, GtkWidget *color)
+void show_def_bgcolor_dialog(struct conversation *c, GtkWidget *color)
 {
 	GtkWidget *colorsel;
 	gdouble bgclr[3];
@@ -2755,9 +2972,9 @@
 	if (color == NULL) {	/* we came from the prefs */
 		if (bgcseld)
 			return;
-		bgclr[0] = (gdouble)(bgcolor.red) / 255;
-		bgclr[1] = (gdouble)(bgcolor.green) / 255;
-		bgclr[2] = (gdouble)(bgcolor.blue) / 255;
+		bgclr[0] = (gdouble)(def_bgcolor.red) / 255;
+		bgclr[1] = (gdouble)(def_bgcolor.green) / 255;
+		bgclr[2] = (gdouble)(def_bgcolor.blue) / 255;
 
 		bgcseld = gtk_color_selection_dialog_new(_("Select Background Color"));
 		gtk_color_selection_set_color(GTK_COLOR_SELECTION
@@ -2767,7 +2984,7 @@
 		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(bgcseld)->cancel_button),
 				   "clicked", GTK_SIGNAL_FUNC(destroy_colorsel), NULL);
 		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(bgcseld)->ok_button), "clicked",
-				   GTK_SIGNAL_FUNC(apply_color_dlg), (void *)2);
+				   GTK_SIGNAL_FUNC(apply_def_color_dlg), (void *)2);
 		gtk_widget_realize(bgcseld);
 		aol_icon(bgcseld->window);
 		gtk_widget_show(bgcseld);
@@ -2775,30 +2992,30 @@
 		return;
 	}
 
-	if (!c->bg_color_dialog) {
-		bgclr[0] = (gdouble)(c->bgcol.red) / 255;
-		bgclr[1] = (gdouble)(c->bgcol.green) / 255;
-		bgclr[2] = (gdouble)(c->bgcol.blue) / 255;
+	if (!c->def_bg_color_dialog) {
+		bgclr[0] = (gdouble)(c->def_bgcol.red) / 255;
+		bgclr[1] = (gdouble)(c->def_bgcol.green) / 255;
+		bgclr[2] = (gdouble)(c->def_bgcol.blue) / 255;
 
-		c->bg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
-		colorsel = GTK_COLOR_SELECTION_DIALOG(c->bg_color_dialog)->colorsel;
+		c->def_bg_color_dialog = gtk_color_selection_dialog_new(_("Select Text Color"));
+		colorsel = GTK_COLOR_SELECTION_DIALOG(c->def_bg_color_dialog)->colorsel;
 		gtk_color_selection_set_color(GTK_COLOR_SELECTION(colorsel), bgclr);
 		gtk_object_set_user_data(GTK_OBJECT(colorsel), c);
 
-		gtk_signal_connect(GTK_OBJECT(c->bg_color_dialog), "delete_event",
+		gtk_signal_connect(GTK_OBJECT(c->def_bg_color_dialog), "delete_event",
 				   GTK_SIGNAL_FUNC(delete_event_dialog), c);
-		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->bg_color_dialog)->ok_button),
-				   "clicked", GTK_SIGNAL_FUNC(do_bgcolor), colorsel);
+		gtk_signal_connect(GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(c->def_bg_color_dialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC(do_def_bgcolor), colorsel);
 		gtk_signal_connect(GTK_OBJECT
-				   (GTK_COLOR_SELECTION_DIALOG(c->bg_color_dialog)->cancel_button),
-				   "clicked", GTK_SIGNAL_FUNC(cancel_bgcolor), c);
+				   (GTK_COLOR_SELECTION_DIALOG(c->def_bg_color_dialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(cancel_def_bgcolor), c);
 
-		gtk_widget_realize(c->bg_color_dialog);
-		aol_icon(c->bg_color_dialog->window);
+		gtk_widget_realize(c->def_bg_color_dialog);
+		aol_icon(c->def_bg_color_dialog->window);
 	}
 
-	gtk_widget_show(c->bg_color_dialog);
-	gdk_window_raise(c->bg_color_dialog->window);
+	gtk_widget_show(c->def_bg_color_dialog);
+	gdk_window_raise(c->def_bg_color_dialog->window);
 }
 
 /*------------------------------------------------------------------------*/
@@ -3794,6 +4011,7 @@
 	aol_icon(window->window);
 
 	layout = gtk_imhtml_new(NULL, NULL);
+	gtk_imhtml_set_background(GTK_IMHTML(layout), NULL, 1, 1);
 	bbox = gtk_hbox_new(FALSE, 0);
 
 	box = gtk_vbox_new(FALSE, 5);
@@ -4792,6 +5010,20 @@
 	gtk_widget_show(b->window);
 }
 
+/* void win_move(GtkWidget *w, GdkEventConfigure *e, gpointer data) */
+void win_move(GtkIMHtml *imhtml)
+{
+	if (imhtml == NULL)
+		return;
+
+	if (imhtml->transparent)
+		gtk_widget_queue_draw(GTK_WIDGET(imhtml));
+
+#if 0
+	if (imhtml->transparent)
+		gtk_imhtml_refresh(imhtml, 1);
+#endif
+}
 
 /*------------------------------------*/
 /* V-Card dialog specific support     */
diff -Nru gaim-0.58/src/gaim.h gaim-0.58-t/src/gaim.h
--- gaim-0.58/src/gaim.h	Tue May  7 19:12:14 2002
+++ gaim-0.58-t/src/gaim.h	Wed Jun 12 20:09:47 2002
@@ -260,9 +260,17 @@
 #define OPT_FONT_UNDERLINE		0x00000008
 #define OPT_FONT_STRIKE			0x00000010
 #define OPT_FONT_FACE			0x00000020
-#define OPT_FONT_FGCOL			0x00000040
-#define OPT_FONT_BGCOL			0x00000080
+#define OPT_FONT_OUT_FGCOL		0x00000040
+#define OPT_FONT_OUT_BGCOL		0x00000080
 #define OPT_FONT_SIZE			0x00000100
+#define OPT_FONT_DEF_FGCOL      0x00000200
+#define OPT_FONT_DEF_BGCOL      0x00000400
+
+extern guint trans_options;
+#define OPT_TRANS_CONV          0x00000001
+#define OPT_TRANS_CHAT          0x00000002
+#define OPT_TRANS_AWAY          0x00000004
+#define OPT_TRANS_INFO          0x00000008
 
 extern guint sound_options;
 #define OPT_SOUND_LOGIN			0x00000001
diff -Nru gaim-0.58/src/gaimrc.c gaim-0.58-t/src/gaimrc.c
--- gaim-0.58/src/gaimrc.c	Sat May  4 04:21:31 2002
+++ gaim-0.58-t/src/gaimrc.c	Wed Jun 12 20:09:47 2002
@@ -47,6 +47,7 @@
 guint im_options;
 guint chat_options;
 guint font_options;
+guint trans_options;
 guint sound_options;
 guint away_options;
 guint away_resend;
@@ -741,6 +742,8 @@
 			chat_options = atoi(p->value[0]);
 		} else if (!strcmp(p->option, "font_options")) {
 			font_options = atoi(p->value[0]);
+		} else if (!strcmp(p->option, "trans_options")) {
+			trans_options = atoi(p->value[0]);
 		} else if (!strcmp(p->option, "sound_options")) {
 			sound_options = atoi(p->value[0]);
 		} else if (!strcmp(p->option, "away_options")) {
@@ -753,13 +756,25 @@
 		} else if (!strcmp(p->option, "font_size")) {
 			fontsize = atoi(p->value[0]);
 		} else if (!strcmp(p->option, "foreground")) {
-			fgcolor.red = atoi(p->value[0]);
-			fgcolor.green = atoi(p->value[1]);
-			fgcolor.blue = atoi(p->value[2]);
+			out_fgcolor.red = atoi(p->value[0]);
+			out_fgcolor.green = atoi(p->value[1]);
+			out_fgcolor.blue = atoi(p->value[2]);
 		} else if (!strcmp(p->option, "background")) {
-			bgcolor.red = atoi(p->value[0]);
-			bgcolor.green = atoi(p->value[1]);
-			bgcolor.blue = atoi(p->value[2]);
+			out_bgcolor.red = atoi(p->value[0]);
+			out_bgcolor.green = atoi(p->value[1]);
+			out_bgcolor.blue = atoi(p->value[2]);
+		} else if (!strcmp(p->option, "default_foreground")) {
+			def_fgcolor.red = atoi(p->value[0]);
+			def_fgcolor.green = atoi(p->value[1]);
+			def_fgcolor.blue = atoi(p->value[2]);
+		} else if (!strcmp(p->option, "default_background")) {
+			def_bgcolor.red = atoi(p->value[0]);
+			def_bgcolor.green = atoi(p->value[1]);
+			def_bgcolor.blue = atoi(p->value[2]);
+		} else if (!strcmp(p->option, "trans_tint")) {
+			trans_tint.red = atoi(p->value[0]);
+			trans_tint.green = atoi(p->value[1]);
+			trans_tint.blue = atoi(p->value[2]);
 		} else if (!strcmp(p->option, "report_idle")) {
 			report_idle = atoi(p->value[0]);
 		} else if (!strcmp(p->option, "web_browser")) {
@@ -839,14 +854,23 @@
 	fprintf(f, "\tim_options { %u }\n", im_options);
 	fprintf(f, "\tchat_options { %u }\n", chat_options);
 	fprintf(f, "\tfont_options { %u }\n", font_options);
+	fprintf(f, "\ttrans_options { %u }\n", trans_options);
 	fprintf(f, "\tsound_options { %u }\n", sound_options);
 	fprintf(f, "\taway_options { %u } { %u }\n", away_options, away_resend);
 
 	fprintf(f, "\tfont_xfld { %s }\n", fontxfld);
 	fprintf(f, "\tfont_face { %s }\n", fontface);
 	fprintf(f, "\tfont_size { %d }\n", fontsize);
-	fprintf(f, "\tforeground { %d } { %d } { %d }\n", fgcolor.red, fgcolor.green, fgcolor.blue);
-	fprintf(f, "\tbackground { %d } { %d } { %d }\n", bgcolor.red, bgcolor.green, bgcolor.blue);
+	fprintf(f, "\tforeground { %d } { %d } { %d }\n",
+			out_fgcolor.red, out_fgcolor.green, out_fgcolor.blue);
+	fprintf(f, "\tbackground { %d } { %d } { %d }\n",
+			out_bgcolor.red, out_bgcolor.green, out_bgcolor.blue);
+	fprintf(f, "\tdefault_foreground { %d } { %d } { %d }\n",
+			def_fgcolor.red, def_fgcolor.green, def_fgcolor.blue);
+	fprintf(f, "\tdefault_background { %d } { %d } { %d }\n",
+			def_bgcolor.red, def_bgcolor.green, def_bgcolor.blue);
+	fprintf(f, "\ttrans_tint { %d } { %d } { %d }\n",
+			trans_tint.red, trans_tint.green, trans_tint.blue);
 	fprintf(f, "\treport_idle { %d }\n", report_idle);
 	fprintf(f, "\tweb_browser { %d }\n", web_browser);
 	fprintf(f, "\tweb_command { %s }\n", web_command);
@@ -1022,6 +1046,12 @@
 		OPT_CHAT_TAB_COMPLETE;
 
 	font_options = 0;
+	
+	trans_options = 0;
+
+	trans_tint.red   = 195;
+	trans_tint.green = 195;
+	trans_tint.blue  = 195;
 
 	away_options =
 		OPT_AWAY_BACK_ON_IM;
diff -Nru gaim-0.58/src/gtkimhtml.c gaim-0.58-t/src/gtkimhtml.c
--- gaim-0.58/src/gtkimhtml.c	Sat May  4 21:06:15 2002
+++ gaim-0.58-t/src/gtkimhtml.c	Wed Jun 12 20:09:47 2002
@@ -24,6 +24,7 @@
 #endif
 #include "gtkimhtml.h"
 #include <X11/Xlib.h>
+#include <X11/Xatom.h>
 #include <stdlib.h>
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
@@ -35,6 +36,9 @@
 #include <langinfo.h>
 #include <locale.h>
 #endif
+#ifdef USE_PIXBUF
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#endif
 
 #if USE_PIXBUF
 #include <gdk-pixbuf/gdk-pixbuf.h>
@@ -68,7 +72,6 @@
 #include "pixmaps/yell.xpm"
 
 #define MAX_FONT_SIZE 7
-
 #define POINT_SIZE(x) (_point_sizes [MIN ((x), MAX_FONT_SIZE) - 1])
 static gint _point_sizes [] = { 80, 100, 120, 140, 200, 300, 400 };
 
@@ -91,8 +94,13 @@
 #define TYPE_BR       4
 #define TYPE_COMMENT  5
 
+/* Temporary */
+#define USE_XLIB 1
+
 #define DRAW_IMG(x) (((x)->type == TYPE_IMG) || (imhtml->smileys && ((x)->type == TYPE_SMILEY)))
 
+GdkColor trans_tint;
+
 typedef struct _GtkIMHtmlBit GtkIMHtmlBit;
 typedef struct _FontDetail   FontDetail;
 
@@ -246,6 +254,251 @@
 	}
 }
 
+#if USE_PIXBUF
+static GdkPixmap *
+shade_pixmap (GtkIMHtml *imhtml, Pixmap p, int x, int y, int w, int h)
+{
+	GdkPixmap *pp, *tmp, *shaded_pixmap;
+	GdkPixbuf *pixbuf;
+	GdkColormap *cmap;
+	GdkGC *tgc;
+	unsigned char *buf, *pbuf;
+	int width, height, depth;
+	int rowstride;
+	int pbwidth, pbheight;
+	int i, j;
+	int offset;
+	int r, g, b, a;
+
+	pp = gdk_pixmap_foreign_new (p);
+	cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml));
+	gdk_window_get_geometry (pp, NULL, NULL, &width, &height, &depth);
+
+	if (width < x + w || height < y + h || x < 0 || y < 0) {
+		tgc = gdk_gc_new (pp);
+		tmp = gdk_pixmap_new (pp, w, h, depth);
+		gdk_gc_set_tile (tgc, pp);
+		gdk_gc_set_fill (tgc, GDK_TILED);
+		gdk_gc_set_ts_origin (tgc, -x, -y);
+		gdk_draw_rectangle (tmp, tgc, TRUE, 0, 0, w, h);
+		gdk_gc_destroy (tgc);
+
+		pixbuf = gdk_pixbuf_get_from_drawable (NULL, tmp, cmap,
+		                                       0, 0, 0, 0, w, h);
+		gdk_pixmap_unref (tmp);
+	}
+	else {
+		pixbuf = gdk_pixbuf_get_from_drawable (NULL, pp, cmap,
+		                                       x, y, 0, 0, w, h);
+	}
+
+	gdk_xid_table_remove (GDK_WINDOW_XWINDOW (pp));
+	g_dataset_destroy (pp);
+	g_free (pp);
+
+	if (!pixbuf)
+		return NULL;
+
+	buf = gdk_pixbuf_get_pixels (pixbuf);
+	rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+	pbwidth = gdk_pixbuf_get_width (pixbuf);
+	pbheight = gdk_pixbuf_get_height (pixbuf);
+	
+	a = 128;
+	r = trans_tint.red;
+	g = trans_tint.green;
+	b = trans_tint.blue;
+
+	if (gdk_pixbuf_get_has_alpha (pixbuf))
+		offset = 4;
+	else
+		offset = 3;
+
+	for (i = 0; i < pbheight; i++) {
+		pbuf = buf;
+		
+		for (j = 0; j < pbwidth; j++) {
+			pbuf[0] = ((pbuf[0] * r) >> 8);
+			pbuf[1] = ((pbuf[1] * g) >> 8);
+			pbuf[2] = ((pbuf[2] * b) >> 8);
+
+			pbuf += offset;
+		}
+
+		buf += rowstride;
+	}
+
+	if (imhtml->recycle) {
+		shaded_pixmap = imhtml->bg_pixmap;
+		gdk_pixbuf_render_to_drawable (pixbuf, shaded_pixmap, imhtml->bgc,
+									   0, 0, 0, 0, w, h,
+									   GDK_RGB_DITHER_NORMAL, 0, 0);
+	}
+	else {
+		gdk_pixbuf_render_pixmap_and_mask (pixbuf, &shaded_pixmap, NULL, 0);
+	}
+
+	gdk_pixbuf_unref (pixbuf);
+
+	return shaded_pixmap;
+}
+#endif
+
+static Window desktop_window = None;
+
+static Window
+get_desktop_window (Window win)
+{
+	Atom prop, prop2, type;
+	int format;
+	unsigned long length, after;
+	unsigned char *data;
+	unsigned int nchildren;
+	Window w, root, *children, parent;
+
+	prop = XInternAtom (GDK_DISPLAY (), "_XROOTPMAP_ID", True);
+	prop2 = XInternAtom (GDK_DISPLAY (), "_XROOTCOLOR_PIXEL", True);
+
+	if (prop == None && prop2 == None)
+		return None;
+
+	for (w = win; w; w = parent) {
+		if ((XQueryTree (GDK_DISPLAY (), w, &root, &parent, &children,
+						 &nchildren)) == False) {
+			return None;
+		}
+
+		if (nchildren)
+			XFree (children);
+
+		if (prop != None) {
+			XGetWindowProperty (GDK_DISPLAY (), w, prop, 0L, 1L, False,
+								AnyPropertyType, &type, &format, &length,
+								&after, &data);
+		}
+		else {
+			XGetWindowProperty (GDK_DISPLAY (), w, prop2, 0L, 1L, False,
+								AnyPropertyType, &type, &format, &length,
+								&after, &data);
+		}
+
+		if (data)
+			XFree (data);
+
+		if (type != None) {
+			return (desktop_window = w);
+		}
+	}
+
+	return (desktop_window = None);
+}
+
+static Pixmap
+get_pixmap_prop (Window win)
+{
+	Atom type;
+	int format;
+	unsigned long length, after;
+	unsigned char *data;
+	Pixmap pix = None;
+	static Atom prop = None;
+
+	if (desktop_window == None)
+		desktop_window = get_desktop_window (win);
+	if (desktop_window == None)
+		desktop_window = GDK_ROOT_WINDOW ();
+
+	if (prop == None)
+		prop = XInternAtom (GDK_DISPLAY (), "_XROOTPMAP_ID", True);
+	if (prop == None)
+		return None;
+
+	XGetWindowProperty (GDK_DISPLAY(), desktop_window, prop, 0L, 1L, False,
+						AnyPropertyType, &type, &format, &length, &after,
+						&data);
+
+	if (data) {
+		if (type == XA_PIXMAP)
+			pix = *((Pixmap *) data);
+
+		XFree (data);
+	}
+
+	return pix;
+}
+
+static void
+gtk_imhtml_free_trans (GtkIMHtml *imhtml)
+{
+	if (imhtml->bg_pixmap) {
+		if (imhtml->shaded) {
+			gdk_pixmap_unref (imhtml->bg_pixmap);
+		}
+		else {
+			gdk_xid_table_remove (GDK_WINDOW_XWINDOW (imhtml->bg_pixmap));
+			g_dataset_destroy (imhtml->bg_pixmap);
+			g_free (imhtml->bg_pixmap);
+		}
+
+		imhtml->bg_pixmap = NULL;
+	}
+}
+
+static void
+gtk_imhtml_load_trans (GtkIMHtml *imhtml)
+{
+	Pixmap root_pix;
+	GtkWidget *widget;
+	int x, y;
+
+	widget = GTK_WIDGET (imhtml);
+
+	root_pix = get_pixmap_prop (GDK_WINDOW_XWINDOW (widget->window));
+	
+	if (root_pix == None) {
+		fprintf(stderr, "Unable to get the root pixmap.\n");
+		fprintf(stderr, "You may need to use Esetroot or GNOME "
+		        "control-center to set your background.\n");
+
+		imhtml->transparent = FALSE;
+
+		return;
+	}
+
+	gdk_window_get_origin (widget->window, &x, &y);
+
+#ifdef USE_PIXBUF
+	if (imhtml->shaded) {
+		int width, height;
+
+		gdk_window_get_size (widget->window, &width, &height);
+		imhtml->bg_pixmap = shade_pixmap (imhtml, root_pix, x, y, width,
+		                                  height);
+
+		if (imhtml->bg_pixmap == NULL) {
+			imhtml->shaded = 0;
+
+			imhtml->bg_pixmap = gdk_pixmap_foreign_new (root_pix);
+			gdk_gc_set_tile (imhtml->bgc, imhtml->bg_pixmap);
+			gdk_gc_set_ts_origin (imhtml->bgc, -x, -y);
+		}
+		else {
+			gdk_gc_set_tile (imhtml->bgc, imhtml->bg_pixmap);
+			gdk_gc_set_ts_origin (imhtml->bgc, 0, 0);
+		}
+	}
+	else {
+#endif
+		imhtml->bg_pixmap = gdk_pixmap_foreign_new (root_pix);
+		gdk_gc_set_tile (imhtml->bgc, imhtml->bg_pixmap);
+		gdk_gc_set_ts_origin (imhtml->bgc, -x, -y);
+#ifdef USE_PIXBUF
+	}
+#endif
+
+	gdk_gc_set_fill (imhtml->bgc, GDK_TILED);
+}
+
 void
 gtk_imhtml_remove_smileys (GtkIMHtml *imhtml)
 {
@@ -369,6 +622,7 @@
 		gdk_color_free (imhtml->default_fg_color);
 	if (imhtml->default_bg_color)
 		gdk_color_free (imhtml->default_bg_color);
+
 	if (imhtml->default_hl_color)
 		gdk_color_free (imhtml->default_hl_color);
 	if (imhtml->default_hlfg_color)
@@ -377,6 +631,17 @@
 	gdk_cursor_destroy (imhtml->hand_cursor);
 	gdk_cursor_destroy (imhtml->arrow_cursor);
 
+	if (imhtml->bg_pixmap) {
+#ifdef USE_XLIB
+		if (imhtml->transparent)
+			gtk_imhtml_free_trans (imhtml);
+		else
+#endif
+			gdk_pixmap_unref (imhtml->bg_pixmap);
+
+		imhtml->bg_pixmap = NULL;
+	}
+
 	gtk_smiley_tree_destroy (imhtml->smiley_data);
 
 #if GTK_CHECK_VERSION(1,3,0)
@@ -392,6 +657,7 @@
 {
 	GtkIMHtml *imhtml;
 	GdkWindowAttr attributes;
+	GdkGCValues val;
 	gint attributes_mask;
 
 	g_return_if_fail (widget != NULL);
@@ -439,7 +705,9 @@
 
 	imhtml->default_font = gdk_font_ref (GTK_IMHTML_GET_STYLE_FONT (widget->style));
 
-	gdk_window_set_background (widget->window, &widget->style->base [GTK_STATE_NORMAL]);
+	val.subwindow_mode = GDK_INCLUDE_INFERIORS;
+	val.graphics_exposures = 0;
+
 	gdk_window_set_background (GTK_LAYOUT (imhtml)->bin_window,
 				   &widget->style->base [GTK_STATE_NORMAL]);
 
@@ -448,6 +716,36 @@
 	imhtml->default_hl_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->bg [GTK_STATE_SELECTED]);
 	imhtml->default_hlfg_color=gdk_color_copy (&GTK_WIDGET (imhtml)->style->fg [GTK_STATE_SELECTED]);
 
+	imhtml->fgc = gdk_gc_new_with_values (GTK_WIDGET (imhtml)->window, &val,
+										  GDK_GC_EXPOSURES | GDK_GC_SUBWINDOW);
+	imhtml->bgc = gdk_gc_new_with_values (GTK_WIDGET (imhtml)->window, &val,
+										  GDK_GC_EXPOSURES | GDK_GC_SUBWINDOW);
+
+	gdk_gc_set_foreground (imhtml->fgc, imhtml->default_fg_color);
+	gdk_gc_set_background (imhtml->fgc, imhtml->default_bg_color);
+	gdk_gc_set_foreground (imhtml->bgc, imhtml->default_bg_color);
+
+#ifdef USE_XLIB
+	if (imhtml->transparent)
+		gtk_imhtml_load_trans (imhtml);
+	else if (imhtml->bg_pixmap) {
+		gdk_gc_set_tile (imhtml->bgc, imhtml->bg_pixmap);
+		gdk_gc_set_ts_origin (imhtml->bgc, 0, 0);
+		gdk_gc_set_fill (imhtml->bgc, GDK_TILED);
+	}
+#else
+	if (imhtml->bg_pixmap) {
+		gdk_gc_set_tile (imhtml->bgc, imhtml->bg_pixmap);
+		gdk_gc_set_ts_origin (imhtml->bgc, 0, 0);
+		gdk_gc_set_fill (imhtml->bgc, GDK_TILED);
+	}
+#endif
+
+	gdk_window_set_back_pixmap (GTK_WIDGET (imhtml)->window, NULL, FALSE);
+
+	/* draw directly to the window */
+	imhtml->draw_buf = GTK_WIDGET (imhtml)->window;
+
 	gdk_window_show (GTK_LAYOUT (imhtml)->bin_window);
 }
 
@@ -500,8 +798,11 @@
 		bg = imhtml->default_bg_color;
 	}
 
-	gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
-			    line->width ? line->width : imhtml->xsize, line->height);
+	if (!imhtml->transparent) {
+		gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff,
+							line->y - yoff, line->width ? line->width :
+							imhtml->xsize, line->height);
+	}
 
 	if (!line->text) {
 		gdk_gc_unref (gc);
@@ -511,8 +812,8 @@
 	if (bit->back != NULL) {
 		gdk_color_alloc (cmap, bit->back);
 		gdk_gc_set_foreground (gc, bit->back);
-		gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
-				    gdk_string_width (bit->font, line->text), line->height);
+		gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff,
+					gdk_string_width (bit->font, line->text), line->height);
 		bg = bit->back;
 	}
 
@@ -541,7 +842,7 @@
 
 		gdk_gc_set_foreground (gc, imhtml->default_hl_color);
 		
-		gdk_draw_rectangle (window, gc, TRUE, x + line->x - xoff, line->y - yoff,
+		gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, x + line->x - xoff, line->y - yoff,
 				    width, line->height);
 		gdk_gc_set_foreground (gc, imhtml->default_hlfg_color);
 		fg = gdk_color_copy(imhtml->default_hlfg_color);
@@ -573,22 +874,22 @@
 			       line->y - yoff + line->ascent, line->text, start - line->text);
 		offset = gdk_text_width(bit->font, line->text, start - line->text);
 		if (bit->underline || bit->url)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, 
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, 
 					    line->y - yoff + line->ascent + 1,
 					    offset, 1);
 		if (bit->strike)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff,
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff,
 					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
 					    offset, 1);
 		gdk_gc_set_foreground (gc, imhtml->default_hlfg_color);
 		gdk_draw_text (window, bit->font, gc, line->x - xoff + offset,
 			       line->y - yoff + line->ascent, start, end - start);
 		if (bit->underline || bit->url)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset, 
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff + offset, 
 					    line->y - yoff + line->ascent + 1,
 					    gdk_text_width(bit->font, line->text, end - start), 1);
 		if (bit->strike)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset,
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff + offset,
 					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
 					    gdk_text_width(bit->font, line->text, end - start), 1);
 		offset = gdk_text_width(bit->font, line->text, end - line->text);
@@ -596,11 +897,11 @@
 		gdk_draw_string (window, bit->font, gc, line->x - xoff + offset,
 			       line->y - yoff + line->ascent, end);
 		if (bit->underline || bit->url)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset, 
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff + offset, 
 					    line->y - yoff + line->ascent + 1,
 					    gdk_string_width(bit->font, end), 1);
 		if (bit->strike)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset,
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff + offset,
 					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
 					    gdk_string_width(bit->font, end), 1);
 	} else {
@@ -608,10 +909,10 @@
 				 line->y - yoff + line->ascent, line->text);
 		
 		if (bit->underline || bit->url)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff + line->ascent + 1,
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff + line->ascent + 1,
 					    gdk_string_width (bit->font, line->text), 1);
 		if (bit->strike)
-			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff,
+			gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff,
 					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
 					    gdk_string_width (bit->font, line->text), 1);
 	}
@@ -654,12 +955,14 @@
 		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
 	}
 
-	gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff, line->width, line->height);
+	if (!imhtml->transparent) {
+		gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff, line->width, line->height);
+	}
 
 	if (line->selected) {
 		gdk_color_alloc (cmap, imhtml->default_hl_color);
 		gdk_gc_set_foreground(gc, imhtml->default_hl_color);
-		gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
+		gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff,
 				    width, line->height);
 	} else if (bit->back != NULL) {
 		gdk_color_alloc (cmap, bit->back);
@@ -707,7 +1010,7 @@
 		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
 	}
 
-	gdk_draw_rectangle (drawable, gc, TRUE, line->x - xoff, line->y - yoff,
+	gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff,
 			    line->width, line->height);
 	
 	
@@ -721,7 +1024,7 @@
 
 	line_height = line->height / 2;
 
-	gdk_draw_rectangle (drawable, gc, TRUE, line->x - xoff, line->y - yoff + line_height / 2,
+	gdk_draw_rectangle (imhtml->draw_buf, gc, TRUE, line->x - xoff, line->y - yoff + line_height / 2,
 			    line->width, line_height);
 
 	gdk_gc_unref (gc);
@@ -758,6 +1061,23 @@
 }
 
 static void
+gtk_imhtml_render_page (GtkIMHtml *imhtml)
+{
+	int width, height;
+
+	gdk_window_get_size (GTK_WIDGET (imhtml)->window, &width, &height);
+	gdk_draw_rectangle (imhtml->draw_buf, imhtml->bgc, 1, 0, 0, width, height);
+}
+
+static gint
+gtk_imhtml_idle (GtkIMHtml *imhtml)
+{
+	imhtml->skip_exposure = FALSE;
+
+	return FALSE;
+}
+
+static void
 gtk_imhtml_draw_exposed (GtkIMHtml *imhtml)
 {
 	GList *bits;
@@ -771,6 +1091,39 @@
 	gint width, height;
 #endif
 
+	if (imhtml->skip_exposure) {
+		imhtml->skip_exposure = FALSE;
+
+		return;
+	}
+	
+	if (imhtml->transparent) {
+		int x2, y2;
+		
+		gdk_window_get_origin (GTK_WIDGET (imhtml)->window, &x2, &y2);
+
+		/* update transparency only if it moved */
+		if (imhtml->last_win_x != x2 || imhtml->last_win_y != y2) {
+			imhtml->last_win_x = x2;
+			imhtml->last_win_y = y2;
+
+			if (imhtml->shaded) {
+				imhtml->recycle = TRUE;
+				gtk_imhtml_load_trans (imhtml);
+				imhtml->recycle = FALSE;
+			}
+			else {
+				gtk_imhtml_free_trans (imhtml);
+				gtk_imhtml_load_trans (imhtml);
+			}
+		}
+	}
+
+	gtk_imhtml_render_page (imhtml);
+
+	imhtml->skip_exposure = TRUE;
+	gtk_idle_add ((GtkFunction)gtk_imhtml_idle, imhtml);
+
 	x = GTK_LAYOUT (imhtml)->hadjustment->value;
 	y = GTK_LAYOUT (imhtml)->vadjustment->value;
 	gdk_window_get_size (GTK_LAYOUT (imhtml)->bin_window, &width, &height);
@@ -1008,6 +1361,11 @@
 					allocation->width, allocation->height);
 		gdk_window_move_resize (layout->bin_window,
 					x, y, new_xsize, new_ysize);
+
+		if (imhtml->transparent && imhtml->shaded) {
+			gtk_imhtml_free_trans (imhtml);
+			gtk_imhtml_load_trans (imhtml);
+		}
 	}
 #endif
 
@@ -2335,6 +2693,10 @@
 	imhtml->bits = NULL;
 	imhtml->click = NULL;
 
+	imhtml->bg_pixmap = NULL;
+	imhtml->pixel_offset = 0;
+	imhtml->recycle = FALSE;
+
 	imhtml->x = 0;
 	imhtml->y = TOP_BORDER;
 	imhtml->llheight = 0;
@@ -2382,17 +2744,81 @@
 		if (imhtml->default_fg_color)
 			gdk_color_free (imhtml->default_fg_color);
 		imhtml->default_fg_color = gdk_color_copy (fg_color);
+		gdk_gc_set_foreground (imhtml->fgc, imhtml->default_fg_color);
 	}
 
 	if (bg_color) {
 		if (imhtml->default_bg_color)
 			gdk_color_free (imhtml->default_bg_color);
 		imhtml->default_bg_color = gdk_color_copy (bg_color);
+		gdk_gc_set_background (imhtml->bgc, imhtml->default_bg_color);
 		gdk_window_set_background (GTK_LAYOUT (imhtml)->bin_window, imhtml->default_bg_color);
 	}
 }
 
 void
+gtk_imhtml_set_background (GtkIMHtml *imhtml, GdkPixmap *pixmap,
+						   int trans, int shaded)
+{
+	GdkGCValues val;
+
+#ifndef USE_PIXBUF
+	shaded = FALSE;
+#endif
+
+#ifndef USE_XLIB
+	shaded = FALSE;
+	trans = FALSE;
+#endif
+
+	if (imhtml->bg_pixmap) {
+#ifdef USE_XLIB
+		if (imhtml->transparent)
+			gtk_imhtml_free_trans (imhtml);
+		else
+#endif
+			gdk_pixmap_unref (imhtml->bg_pixmap);
+
+		imhtml->bg_pixmap = NULL;
+	}
+
+	imhtml->transparent = trans;
+	
+#ifdef USE_XLIB
+	if (trans) {
+		imhtml->shaded = shaded;
+
+		if (GTK_WIDGET_REALIZED (imhtml))
+			gtk_imhtml_load_trans (imhtml);
+
+		return;
+	}
+#endif
+
+	imhtml->bg_pixmap = pixmap;
+
+	if (pixmap != 0) {
+		gdk_pixmap_ref (pixmap);
+
+		if (GTK_WIDGET_REALIZED (imhtml)) {
+			gdk_gc_set_tile (imhtml->bgc, pixmap);
+			gdk_gc_set_ts_origin (imhtml->bgc, 0, 0);
+			gdk_gc_set_fill (imhtml->bgc, GDK_TILED);
+		}
+	}
+	else {
+		if (GTK_WIDGET_REALIZED (imhtml)) {
+			gdk_gc_destroy (imhtml->bgc);
+			val.subwindow_mode = GDK_INCLUDE_INFERIORS;
+			val.graphics_exposures = 0;
+			imhtml->bgc = gdk_gc_new_with_values (GTK_WIDGET (imhtml)->window,
+					&val, GDK_GC_EXPOSURES | GDK_GC_SUBWINDOW);
+			gdk_gc_set_foreground (imhtml->bgc, imhtml->default_bg_color);
+		}
+	}
+}
+
+void
 gtk_imhtml_set_img_handler (GtkIMHtml      *imhtml,
 			    GtkIMHtmlImage  handler)
 {
@@ -3785,3 +4211,19 @@
 					     vadj->upper - vadj->page_size));
 	gtk_signal_emit_by_name (GTK_OBJECT (vadj), "changed");
 }
+
+void
+gtk_imhtml_refresh (GtkIMHtml *imhtml, int do_trans)
+{
+	if (GTK_WIDGET_REALIZED (GTK_WIDGET (imhtml))) {
+#ifdef USE_XLIB
+		if (imhtml->transparent && do_trans) {
+			gtk_imhtml_free_trans (imhtml);
+			gtk_imhtml_load_trans (imhtml);
+		}
+#endif
+
+		/* gtk_imhtml_render_page (imhtml); */
+		gtk_imhtml_draw_exposed (imhtml);
+	}
+}
diff -Nru gaim-0.58/src/gtkimhtml.c~ gaim-0.58-t/src/gtkimhtml.c~
--- gaim-0.58/src/gtkimhtml.c~	Wed Dec 31 19:00:00 1969
+++ gaim-0.58-t/src/gtkimhtml.c~	Sat May  4 21:06:15 2002
@@ -0,0 +1,3787 @@
+/*
+ * GtkIMHtml
+ *
+ * Copyright (C) 2000, Eric Warmenhoven <warmenhoven@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "gtkimhtml.h"
+#include <X11/Xlib.h>
+#include <stdlib.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_LANGINFO_CODESET
+#include <langinfo.h>
+#include <locale.h>
+#endif
+
+#if USE_PIXBUF
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <gdk-pixbuf/gdk-pixbuf-loader.h>
+#else
+#include "pixmaps/broken.xpm"
+#endif
+
+#if GTK_CHECK_VERSION(1,3,0)
+#  define GTK_IMHTML_GET_STYLE_FONT(style) gtk_style_get_font (style)
+#else
+#  define GTK_IMHTML_GET_STYLE_FONT(style) (style)->font
+#  define GTK_CLASS_TYPE(class) (class)->type
+#endif
+
+#include "pixmaps/angel.xpm"
+#include "pixmaps/bigsmile.xpm"
+#include "pixmaps/burp.xpm"
+#include "pixmaps/crossedlips.xpm"
+#include "pixmaps/cry.xpm"
+#include "pixmaps/embarrassed.xpm"
+#include "pixmaps/kiss.xpm"
+#include "pixmaps/moneymouth.xpm"
+#include "pixmaps/sad.xpm"
+#include "pixmaps/scream.xpm"
+#include "pixmaps/smile.xpm"
+#include "pixmaps/smile8.xpm"
+#include "pixmaps/think.xpm"
+#include "pixmaps/tongue.xpm"
+#include "pixmaps/wink.xpm"
+#include "pixmaps/yell.xpm"
+
+#define MAX_FONT_SIZE 7
+
+#define POINT_SIZE(x) (_point_sizes [MIN ((x), MAX_FONT_SIZE) - 1])
+static gint _point_sizes [] = { 80, 100, 120, 140, 200, 300, 400 };
+
+#define DEFAULT_PRE_FACE "courier"
+
+#define BORDER_SIZE 2
+#define TOP_BORDER 10
+#define MIN_HEIGHT 20
+#define HR_HEIGHT 2
+#define TOOLTIP_TIMEOUT 500
+
+#define DIFF(a, b) (((a) > (b)) ? ((a) - (b)) : ((b) - (a)))
+#define COLOR_MOD  0x8000
+#define COLOR_DIFF 0x800
+
+#define TYPE_TEXT     0
+#define TYPE_SMILEY   1
+#define TYPE_IMG      2
+#define TYPE_SEP      3
+#define TYPE_BR       4
+#define TYPE_COMMENT  5
+
+#define DRAW_IMG(x) (((x)->type == TYPE_IMG) || (imhtml->smileys && ((x)->type == TYPE_SMILEY)))
+
+typedef struct _GtkIMHtmlBit GtkIMHtmlBit;
+typedef struct _FontDetail   FontDetail;
+
+struct _GtkSmileyTree {
+	GString *values;
+	GtkSmileyTree **children;
+	gchar **image;
+};
+
+static GtkSmileyTree*
+gtk_smiley_tree_new ()
+{
+	return g_new0 (GtkSmileyTree, 1);
+}
+
+static void
+gtk_smiley_tree_insert (GtkSmileyTree *tree,
+			const gchar   *text,
+			gchar        **image)
+{
+	GtkSmileyTree *t = tree;
+	const gchar *x = text;
+
+	if (!strlen (x))
+		return;
+
+	while (*x) {
+		gchar *pos;
+		gint index;
+
+		if (!t->values)
+			t->values = g_string_new ("");
+
+		pos = strchr (t->values->str, *x);
+		if (!pos) {
+			t->values = g_string_append_c (t->values, *x);
+			index = t->values->len - 1;
+			t->children = g_realloc (t->children, t->values->len * sizeof (GtkSmileyTree *));
+			t->children [index] = g_new0 (GtkSmileyTree, 1);
+		} else
+			index = (int) pos - (int) t->values->str;
+
+		t = t->children [index];
+
+		x++;
+	}
+
+	t->image = image;
+}
+
+static void
+gtk_smiley_tree_remove (GtkSmileyTree *tree,
+			const gchar   *text)
+{
+	GtkSmileyTree *t = tree;
+	const gchar *x = text;
+	gint len = 0;
+
+	while (*x) {
+		gchar *pos;
+
+		if (!t->values)
+			return;
+
+		pos = strchr (t->values->str, *x);
+		if (pos)
+			t = t->children [(int) pos - (int) t->values->str];
+		else
+			return;
+
+		x++; len++;
+	}
+
+	if (t->image)
+		t->image = NULL;
+}
+
+static gint
+gtk_smiley_tree_lookup (GtkSmileyTree *tree,
+			const gchar   *text)
+{
+	GtkSmileyTree *t = tree;
+	const gchar *x = text;
+	gint len = 0;
+
+	while (*x) {
+		gchar *pos;
+
+		if (t->image)
+			return len;
+
+		if (!t->values)
+			return 0;
+
+		pos = strchr (t->values->str, *x);
+		if (pos)
+			t = t->children [(int) pos - (int) t->values->str];
+		else
+			return 0;
+
+		x++; len++;
+	}
+
+	if (t->image)
+		return len;
+
+	return 0;
+}
+
+static gchar**
+gtk_smiley_tree_image (GtkSmileyTree *tree,
+		       const gchar   *text)
+{
+	GtkSmileyTree *t = tree;
+	const gchar *x = text;
+
+	while (*x) {
+		gchar *pos;
+
+		if (!t->values)
+			return NULL;
+
+		pos = strchr (t->values->str, *x);
+		if (pos) {
+			t = t->children [(int) pos - (int) t->values->str];
+		} else
+			return NULL;
+
+		x++;
+	}
+
+	return t->image;
+}
+
+static void
+gtk_smiley_tree_destroy (GtkSmileyTree *tree)
+{
+	GSList *list = g_slist_append (NULL, tree);
+
+	while (list) {
+		GtkSmileyTree *t = list->data;
+		gint i;
+		list = g_slist_remove(list, t);
+		if (t->values) {
+			for (i = 0; i < t->values->len; i++)
+				list = g_slist_append (list, t->children [i]);
+			g_string_free (t->values, TRUE);
+			g_free (t->children);
+		}
+		g_free (t);
+	}
+}
+
+void
+gtk_imhtml_remove_smileys (GtkIMHtml *imhtml)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	gtk_smiley_tree_destroy (imhtml->smiley_data);
+	imhtml->smiley_data = gtk_smiley_tree_new ();
+}
+
+void
+gtk_imhtml_reset_smileys (GtkIMHtml *imhtml) 
+{
+	gtk_imhtml_remove_smileys(imhtml);
+	gtk_imhtml_init_smileys (imhtml);
+}
+	
+
+struct im_image {
+	gchar *filename;
+	
+	gint len;
+	gpointer data;
+	
+	gint x,y;
+	gint width,height;
+	GtkIMHtml *imhtml;
+	GtkIMHtmlBit *bit;
+#if USE_PIXBUF
+	GdkPixbuf *pb;
+#endif
+};
+
+struct _GtkIMHtmlBit {
+	gint type;
+
+	gchar *text;
+	struct im_image *img;
+	GdkPixmap *pm;
+	GdkBitmap *bm;
+
+	GdkFont *font;
+	GdkColor *fore;
+	GdkColor *back;
+	GdkColor *bg;
+	gboolean underline;
+	gboolean strike;
+	gchar *url;
+
+	GList *chunks;
+};
+
+struct _FontDetail {
+	gushort size;
+	gchar *face;
+	GdkColor *fore;
+	GdkColor *back;
+};
+
+struct line_info {
+	gint x;
+	gint y;
+	gint width;
+	gint height;
+	gint ascent;
+
+	gboolean selected;
+	gchar *sel_start;
+	gchar *sel_end;
+
+	gchar *text;
+	GtkIMHtmlBit *bit;
+};
+
+struct clickable {
+	gint x;
+	gint y;
+	gint width;
+	gint height;
+	GtkIMHtml *imhtml;
+	GtkIMHtmlBit *bit;
+};
+
+static GtkLayoutClass *parent_class = NULL;
+
+enum {
+	TARGET_STRING,
+	TARGET_TEXT,
+	TARGET_COMPOUND_TEXT
+};
+
+enum {
+	URL_CLICKED,
+	LAST_SIGNAL
+};
+static guint signals [LAST_SIGNAL] = { 0 };
+
+static void      gtk_imhtml_draw_bit            (GtkIMHtml *, GtkIMHtmlBit *);
+static GdkColor *gtk_imhtml_get_color           (const gchar *);
+static gint      gtk_imhtml_motion_notify_event (GtkWidget *, GdkEventMotion *);
+
+static void
+#if GTK_CHECK_VERSION(1,3,0)
+gtk_imhtml_finalize (GObject *object)
+#else
+gtk_imhtml_destroy (GtkObject *object)
+#endif
+{
+	GtkIMHtml *imhtml;
+
+	imhtml = GTK_IMHTML (object);
+
+	gtk_imhtml_clear (imhtml);
+
+	if (imhtml->selected_text)
+		g_string_free (imhtml->selected_text, TRUE);
+
+	if (imhtml->default_font)
+		gdk_font_unref (imhtml->default_font);
+	if (imhtml->default_fg_color)
+		gdk_color_free (imhtml->default_fg_color);
+	if (imhtml->default_bg_color)
+		gdk_color_free (imhtml->default_bg_color);
+	if (imhtml->default_hl_color)
+		gdk_color_free (imhtml->default_hl_color);
+	if (imhtml->default_hlfg_color)
+		gdk_color_free (imhtml->default_hlfg_color);
+	
+	gdk_cursor_destroy (imhtml->hand_cursor);
+	gdk_cursor_destroy (imhtml->arrow_cursor);
+
+	gtk_smiley_tree_destroy (imhtml->smiley_data);
+
+#if GTK_CHECK_VERSION(1,3,0)
+	G_OBJECT_CLASS (parent_class)->finalize (object);
+#else
+	if (GTK_OBJECT_CLASS (parent_class)->destroy != NULL)
+		(* GTK_OBJECT_CLASS (parent_class)->destroy) (object);
+#endif
+}
+
+static void
+gtk_imhtml_realize (GtkWidget *widget)
+{
+	GtkIMHtml *imhtml;
+	GdkWindowAttr attributes;
+	gint attributes_mask;
+
+	g_return_if_fail (widget != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (widget));
+
+	imhtml = GTK_IMHTML (widget);
+	GTK_WIDGET_SET_FLAGS (imhtml, GTK_REALIZED);
+
+	attributes.window_type = GDK_WINDOW_CHILD;
+	attributes.x = widget->allocation.x;
+	attributes.y = widget->allocation.y;
+	attributes.width = widget->allocation.width;
+	attributes.height = widget->allocation.height;
+	attributes.wclass = GDK_INPUT_OUTPUT;
+	attributes.visual = gtk_widget_get_visual (widget);
+	attributes.colormap = gtk_widget_get_colormap (widget);
+	attributes.event_mask = GDK_VISIBILITY_NOTIFY_MASK | GDK_EXPOSURE_MASK;
+
+	attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+
+	widget->window = gdk_window_new (gtk_widget_get_parent_window (widget),
+					 &attributes, attributes_mask);
+	gdk_window_set_user_data (widget->window, widget);
+
+#if GTK_CHECK_VERSION(1,3,0)
+	attributes.x = widget->style->xthickness + BORDER_SIZE;
+	attributes.y = widget->style->xthickness + BORDER_SIZE;
+#else
+	attributes.x = widget->style->klass->xthickness + BORDER_SIZE;
+	attributes.y = widget->style->klass->xthickness + BORDER_SIZE;
+#endif
+	attributes.width = MAX (1, (gint) widget->allocation.width - (gint) attributes.x * 2);
+	attributes.height = MAX (1, (gint) widget->allocation.height - (gint) attributes.y * 2);
+	attributes.event_mask = gtk_widget_get_events (widget)
+				| GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK
+				| GDK_POINTER_MOTION_MASK | GDK_EXPOSURE_MASK | GDK_LEAVE_NOTIFY_MASK;
+
+	GTK_LAYOUT (imhtml)->bin_window = gdk_window_new (widget->window,
+							  &attributes, attributes_mask);
+	gdk_window_set_user_data (GTK_LAYOUT (imhtml)->bin_window, widget);
+
+	widget->style = gtk_style_attach (widget->style, widget->window);
+
+	gdk_window_set_cursor (widget->window, imhtml->arrow_cursor);
+
+	imhtml->default_font = gdk_font_ref (GTK_IMHTML_GET_STYLE_FONT (widget->style));
+
+	gdk_window_set_background (widget->window, &widget->style->base [GTK_STATE_NORMAL]);
+	gdk_window_set_background (GTK_LAYOUT (imhtml)->bin_window,
+				   &widget->style->base [GTK_STATE_NORMAL]);
+
+	imhtml->default_fg_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->fg [GTK_STATE_NORMAL]);
+	imhtml->default_bg_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->base [GTK_STATE_NORMAL]);
+	imhtml->default_hl_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->bg [GTK_STATE_SELECTED]);
+	imhtml->default_hlfg_color=gdk_color_copy (&GTK_WIDGET (imhtml)->style->fg [GTK_STATE_SELECTED]);
+
+	gdk_window_show (GTK_LAYOUT (imhtml)->bin_window);
+}
+
+static gboolean
+similar_colors (GdkColor *bg,
+		GdkColor *fg)
+{
+	if ((DIFF (bg->red, fg->red) < COLOR_DIFF) &&
+	    (DIFF (bg->green, fg->green) < COLOR_DIFF) &&
+	    (DIFF (bg->blue, fg->blue) < COLOR_DIFF)) {
+		fg->red = (0xff00 - COLOR_MOD > bg->red) ?
+			bg->red + COLOR_MOD : bg->red - COLOR_MOD;
+		fg->green = (0xff00 - COLOR_MOD > bg->green) ?
+			bg->green + COLOR_MOD : bg->green - COLOR_MOD;
+		fg->blue = (0xff00 - COLOR_MOD > bg->blue) ?
+			bg->blue + COLOR_MOD : bg->blue - COLOR_MOD;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void
+draw_text (GtkIMHtml        *imhtml,
+	   struct line_info *line)
+{
+	GtkIMHtmlBit *bit;
+	GdkGC *gc;
+	GdkColormap *cmap;
+	GdkWindow *window = GTK_LAYOUT (imhtml)->bin_window;
+	gfloat xoff, yoff;
+	GdkColor *bg, *fg;
+	gchar *start = NULL, *end = NULL;
+
+	if (GTK_LAYOUT (imhtml)->freeze_count)
+		return;
+
+	bit = line->bit;
+	gc = gdk_gc_new (window);
+	cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml));
+	xoff = GTK_LAYOUT (imhtml)->hadjustment->value;
+	yoff = GTK_LAYOUT (imhtml)->vadjustment->value;
+
+	if (bit->bg != NULL) {
+		gdk_color_alloc (cmap, bit->bg);
+		gdk_gc_set_foreground (gc, bit->bg);
+		bg = bit->bg;
+	} else {
+		gdk_color_alloc (cmap, imhtml->default_bg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
+		bg = imhtml->default_bg_color;
+	}
+
+	gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
+			    line->width ? line->width : imhtml->xsize, line->height);
+
+	if (!line->text) {
+		gdk_gc_unref (gc);
+		return;
+	}
+
+	if (bit->back != NULL) {
+		gdk_color_alloc (cmap, bit->back);
+		gdk_gc_set_foreground (gc, bit->back);
+		gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
+				    gdk_string_width (bit->font, line->text), line->height);
+		bg = bit->back;
+	}
+
+	bg = gdk_color_copy (bg);
+
+	if (line->selected) {
+		gint width, x;
+		
+		if ((line->sel_start > line->sel_end) && (line->sel_end != NULL)) {
+			start = line->sel_end;
+			end = line->sel_start;
+		} else {
+			start = line->sel_start;
+			end = line->sel_end;
+		}
+
+		if (start == NULL)
+			x = 0;
+		else
+			x = gdk_text_width (bit->font, line->text, start - line->text);
+
+		if (end == NULL)
+			end = strchr(line->text, '\0');
+		
+		width = gdk_text_width (bit->font, line->text, end - line->text) - x;
+
+		gdk_gc_set_foreground (gc, imhtml->default_hl_color);
+		
+		gdk_draw_rectangle (window, gc, TRUE, x + line->x - xoff, line->y - yoff,
+				    width, line->height);
+		gdk_gc_set_foreground (gc, imhtml->default_hlfg_color);
+		fg = gdk_color_copy(imhtml->default_hlfg_color);
+	}
+	if (bit->url) {
+		GdkColor *tc = gtk_imhtml_get_color ("#0000a0");
+		gdk_color_alloc (cmap, tc);
+		gdk_gc_set_foreground (gc, tc);
+		fg = gdk_color_copy (tc);
+		gdk_color_free (tc);
+	} else if (bit->fore) {
+		gdk_color_alloc (cmap, bit->fore);
+		gdk_gc_set_foreground (gc, bit->fore);
+		fg = gdk_color_copy (bit->fore);
+	} else {
+		gdk_color_alloc (cmap, imhtml->default_fg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_fg_color);
+		fg = gdk_color_copy (imhtml->default_fg_color);
+	}
+
+	if (similar_colors (bg, fg)) {
+		gdk_color_alloc (cmap, fg);
+		gdk_gc_set_foreground (gc, fg);
+	}
+
+	if (start) {
+		int offset = 0;
+		gdk_draw_text (window, bit->font, gc, line->x - xoff,
+			       line->y - yoff + line->ascent, line->text, start - line->text);
+		offset = gdk_text_width(bit->font, line->text, start - line->text);
+		if (bit->underline || bit->url)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, 
+					    line->y - yoff + line->ascent + 1,
+					    offset, 1);
+		if (bit->strike)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff,
+					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
+					    offset, 1);
+		gdk_gc_set_foreground (gc, imhtml->default_hlfg_color);
+		gdk_draw_text (window, bit->font, gc, line->x - xoff + offset,
+			       line->y - yoff + line->ascent, start, end - start);
+		if (bit->underline || bit->url)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset, 
+					    line->y - yoff + line->ascent + 1,
+					    gdk_text_width(bit->font, line->text, end - start), 1);
+		if (bit->strike)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset,
+					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
+					    gdk_text_width(bit->font, line->text, end - start), 1);
+		offset = gdk_text_width(bit->font, line->text, end - line->text);
+		gdk_gc_set_foreground (gc, fg);
+		gdk_draw_string (window, bit->font, gc, line->x - xoff + offset,
+			       line->y - yoff + line->ascent, end);
+		if (bit->underline || bit->url)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset, 
+					    line->y - yoff + line->ascent + 1,
+					    gdk_string_width(bit->font, end), 1);
+		if (bit->strike)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff + offset,
+					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
+					    gdk_string_width(bit->font, end), 1);
+	} else {
+		gdk_draw_string (window, bit->font, gc, line->x - xoff,
+				 line->y - yoff + line->ascent, line->text);
+		
+		if (bit->underline || bit->url)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff + line->ascent + 1,
+					    gdk_string_width (bit->font, line->text), 1);
+		if (bit->strike)
+			gdk_draw_rectangle (window, gc, TRUE, line->x - xoff,
+					    line->y - yoff + line->ascent - (bit->font->ascent / 2),
+					    gdk_string_width (bit->font, line->text), 1);
+	}
+		
+	gdk_color_free (bg);
+	gdk_color_free (fg);
+
+	
+
+	gdk_gc_unref (gc);
+}
+
+static void
+draw_img (GtkIMHtml        *imhtml,
+	  struct line_info *line)
+{
+	GtkIMHtmlBit *bit;
+	GdkGC *gc;
+	GdkColormap *cmap;
+	gint width, height, hoff;
+	GdkWindow *window = GTK_LAYOUT (imhtml)->bin_window;
+	gfloat xoff, yoff;
+
+	if (GTK_LAYOUT (imhtml)->freeze_count)
+		return;
+
+	bit = line->bit;
+	gdk_window_get_size (bit->pm, &width, &height);
+	hoff = (line->height - height) / 2;
+	xoff = GTK_LAYOUT (imhtml)->hadjustment->value;
+	yoff = GTK_LAYOUT (imhtml)->vadjustment->value;
+	gc = gdk_gc_new (window);
+	cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml));
+	
+	if (bit->bg != NULL) {
+		gdk_color_alloc (cmap, bit->bg);
+		gdk_gc_set_foreground (gc, bit->bg);
+	} else {
+		gdk_color_alloc (cmap, imhtml->default_bg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
+	}
+
+	gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff, line->width, line->height);
+
+	if (line->selected) {
+		gdk_color_alloc (cmap, imhtml->default_hl_color);
+		gdk_gc_set_foreground(gc, imhtml->default_hl_color);
+		gdk_draw_rectangle (window, gc, TRUE, line->x - xoff, line->y - yoff,
+				    width, line->height);
+	} else if (bit->back != NULL) {
+		gdk_color_alloc (cmap, bit->back);
+		gdk_gc_set_foreground (gc, bit->back);
+	}
+
+	if (bit->bm) {
+		gdk_gc_set_clip_mask(gc, bit->bm);
+		gdk_gc_set_clip_origin(gc, line->x - xoff, line->y - yoff + hoff);
+	}
+	gdk_draw_pixmap (window, gc, bit->pm, 0, 0, line->x - xoff, line->y - yoff + hoff, -1, -1);
+
+	gdk_gc_unref (gc);
+}
+
+static void
+draw_line (GtkIMHtml        *imhtml,
+	   struct line_info *line)
+{
+	GtkIMHtmlBit *bit;
+	GdkDrawable *drawable;
+	GdkColormap *cmap;
+	GdkGC *gc;
+	guint line_height;
+	gfloat xoff, yoff;
+
+	if (GTK_LAYOUT (imhtml)->freeze_count)
+		return;
+
+	xoff = GTK_LAYOUT (imhtml)->hadjustment->value;
+	yoff = GTK_LAYOUT (imhtml)->vadjustment->value;
+	bit = line->bit;
+	drawable = GTK_LAYOUT (imhtml)->bin_window;
+	cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml));
+	gc = gdk_gc_new (drawable);
+
+	if (line->selected) {
+		gdk_color_alloc (cmap, imhtml->default_hl_color);
+		gdk_gc_set_foreground (gc, imhtml->default_hl_color);
+	} else if (bit->bg != NULL) {
+		gdk_color_alloc (cmap, bit->bg);
+		gdk_gc_set_foreground (gc, bit->bg);
+	} else {
+		gdk_color_alloc (cmap, imhtml->default_bg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
+	}
+
+	gdk_draw_rectangle (drawable, gc, TRUE, line->x - xoff, line->y - yoff,
+			    line->width, line->height);
+	
+	
+	if (line->selected) {
+		gdk_color_alloc (cmap, imhtml->default_hlfg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_hlfg_color);
+	} else {
+		gdk_color_alloc (cmap, imhtml->default_fg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_fg_color);
+	}
+
+	line_height = line->height / 2;
+
+	gdk_draw_rectangle (drawable, gc, TRUE, line->x - xoff, line->y - yoff + line_height / 2,
+			    line->width, line_height);
+
+	gdk_gc_unref (gc);
+}
+
+static void
+gtk_imhtml_draw_focus (GtkWidget *widget)
+{
+	GtkIMHtml *imhtml;
+	gint x = 0,
+	     y = 0,
+	     w = 0,
+	     h = 0;
+	
+	imhtml = GTK_IMHTML (widget);
+
+	if (!GTK_WIDGET_DRAWABLE (widget))
+		return;
+
+	if (GTK_WIDGET_HAS_FOCUS (widget)) {
+#if GTK_CHECK_VERSION(1,3,0)
+		gtk_paint_focus (widget->style, widget->window, GTK_STATE_NORMAL, NULL, widget, "text", 
+				 0, 0, widget->allocation.width - 1, widget->allocation.height - 1);
+#else
+		gtk_paint_focus (widget->style, widget->window, NULL, widget, "text", 0, 0,
+				 widget->allocation.width - 1, widget->allocation.height - 1);
+#endif
+		x = 1; y = 1; w = 2; h = 2;
+	}
+
+	gtk_paint_shadow (widget->style, widget->window, GTK_STATE_NORMAL,
+			  GTK_SHADOW_IN, NULL, widget, "text", x, y,
+			  widget->allocation.width - w, widget->allocation.height - h);
+}
+
+static void
+gtk_imhtml_draw_exposed (GtkIMHtml *imhtml)
+{
+	GList *bits;
+	GtkIMHtmlBit *bit;
+	GList *chunks;
+	struct line_info *line;
+	gfloat x, y;
+#if GTK_CHECK_VERSION(1,3,0)
+	guint32 width, height;
+#else
+	gint width, height;
+#endif
+
+	x = GTK_LAYOUT (imhtml)->hadjustment->value;
+	y = GTK_LAYOUT (imhtml)->vadjustment->value;
+	gdk_window_get_size (GTK_LAYOUT (imhtml)->bin_window, &width, &height);
+
+	bits = imhtml->bits;
+
+	while (bits) {
+		bit = bits->data;
+		chunks = bit->chunks;
+		if (DRAW_IMG (bit)) {
+			if (chunks) {
+				line = chunks->data;
+				if ((line->x <= x + width) &&
+				    (line->y <= y + height) &&
+				    (x <= line->x + line->width) &&
+				    (y <= line->y + line->height))
+					draw_img (imhtml, line);
+			}
+		} else if (bit->type == TYPE_SEP) {
+			if (chunks) {
+				line = chunks->data;
+				if ((line->x <= x + width) &&
+				    (line->y <= y + height) &&
+				    (x <= line->x + line->width) &&
+				    (y <= line->y + line->height))
+					draw_line (imhtml, line);
+
+				line = chunks->next->data;
+				if ((line->x <= x + width) &&
+				    (line->y <= y + height) &&
+				    (x <= line->x + line->width) &&
+				    (y <= line->y + line->height))
+					draw_text (imhtml, line);
+			}
+		} else {
+			while (chunks) {
+				line = chunks->data;
+				if ((line->x <= x + width) &&
+				    (line->y <= y + height) &&
+				    (x <= line->x + line->width) &&
+				    (y <= line->y + line->height))
+					draw_text (imhtml, line);
+				chunks = g_list_next (chunks);
+			}
+		}
+		bits = g_list_next (bits);
+	}
+
+	gtk_imhtml_draw_focus (GTK_WIDGET (imhtml));
+}
+
+#if !GTK_CHECK_VERSION(1,3,0)
+static void
+gtk_imhtml_draw (GtkWidget    *widget,
+		 GdkRectangle *area)
+{
+	GtkIMHtml *imhtml;
+
+	imhtml = GTK_IMHTML (widget);
+	gtk_imhtml_draw_exposed (imhtml);
+}
+#endif
+
+static void
+gtk_imhtml_style_set (GtkWidget *widget,
+		      GtkStyle  *style)
+{
+	GtkIMHtml *imhtml;
+
+	g_return_if_fail (widget != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (widget));
+
+	if (GTK_WIDGET_CLASS (parent_class)->style_set)
+		(* GTK_WIDGET_CLASS (parent_class)->style_set) (widget, style);
+
+	if (!GTK_WIDGET_REALIZED (widget))
+		return;
+
+	imhtml = GTK_IMHTML (widget);
+	if (imhtml->default_fg_color)
+		gdk_color_free(imhtml->default_fg_color);
+	if (imhtml->default_bg_color)
+		gdk_color_free(imhtml->default_bg_color);
+	if (imhtml->default_hl_color)
+		gdk_color_free(imhtml->default_hl_color);
+	if (imhtml->default_hlfg_color)
+		gdk_color_free(imhtml->default_hlfg_color);
+	imhtml->default_fg_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->fg [GTK_STATE_NORMAL]);
+	imhtml->default_bg_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->base [GTK_STATE_NORMAL]);
+	imhtml->default_hl_color = gdk_color_copy (&GTK_WIDGET (imhtml)->style->bg [GTK_STATE_SELECTED]);
+	imhtml->default_hlfg_color=gdk_color_copy (&GTK_WIDGET (imhtml)->style->fg [GTK_STATE_SELECTED]);
+	if (imhtml->default_font)
+		gdk_font_unref (imhtml->default_font);
+	imhtml->default_font = gdk_font_ref (GTK_IMHTML_GET_STYLE_FONT (widget->style));
+	gdk_window_set_background (widget->window, &widget->style->base [GTK_STATE_NORMAL]);
+	gdk_window_set_background (GTK_LAYOUT (imhtml)->bin_window,
+				   &widget->style->base [GTK_STATE_NORMAL]);
+	gtk_imhtml_draw_exposed (imhtml);
+}
+
+static gint
+gtk_imhtml_expose_event (GtkWidget      *widget,
+			 GdkEventExpose *event)
+{
+	GtkIMHtml *imhtml;
+
+	g_return_val_if_fail (widget != NULL, FALSE);
+	g_return_val_if_fail (GTK_IS_IMHTML (widget), FALSE);
+
+	imhtml = GTK_IMHTML (widget);
+	gtk_imhtml_draw_exposed (imhtml);
+
+	return FALSE;
+}
+
+static void
+gtk_imhtml_redraw_all (GtkIMHtml *imhtml)
+{
+	GList *b;
+	GtkIMHtmlBit *bit;
+	GtkAdjustment *vadj;
+	gfloat oldvalue;
+	gint oldy;
+
+	vadj = GTK_LAYOUT (imhtml)->vadjustment;
+	oldvalue = vadj->value / vadj->upper;
+	oldy = imhtml->y;
+
+	gtk_layout_freeze (GTK_LAYOUT (imhtml));
+
+	g_list_free (imhtml->line);
+	imhtml->line = NULL;
+
+	while (imhtml->click) {
+		g_free (imhtml->click->data);
+		imhtml->click = g_list_remove (imhtml->click, imhtml->click->data);
+	}
+
+	imhtml->x = 0;
+	imhtml->y = TOP_BORDER;
+	imhtml->llheight = 0;
+	imhtml->llascent = 0;
+
+	if (GTK_LAYOUT (imhtml)->vadjustment->value < TOP_BORDER)
+		gdk_window_clear_area (GTK_LAYOUT (imhtml)->bin_window, 0, 0,
+				       imhtml->xsize,
+				       TOP_BORDER - GTK_LAYOUT (imhtml)->vadjustment->value);
+
+	b = imhtml->bits;
+	while (b) {
+		bit = b->data;
+		b = g_list_next (b);
+		while (bit->chunks) {
+			struct line_info *li = bit->chunks->data;
+			if (li->text)
+				g_free (li->text);
+			bit->chunks = g_list_remove (bit->chunks, li);
+			g_free (li);
+		}
+		gtk_imhtml_draw_bit (imhtml, bit);
+	}
+
+	GTK_LAYOUT (imhtml)->height = imhtml->y;
+	GTK_LAYOUT (imhtml)->vadjustment->upper = imhtml->y;
+	gtk_signal_emit_by_name (GTK_OBJECT (GTK_LAYOUT (imhtml)->vadjustment), "changed");
+
+	gtk_widget_set_usize (GTK_WIDGET (imhtml), -1, imhtml->y);
+	gtk_adjustment_set_value (vadj, vadj->upper * oldvalue);
+
+	if (GTK_LAYOUT (imhtml)->bin_window && (imhtml->y < oldy)) {
+		GdkGC *gc;
+		GdkColormap *cmap;
+
+		gc = gdk_gc_new (GTK_LAYOUT (imhtml)->bin_window);
+		cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml));
+
+		gdk_color_alloc (cmap, imhtml->default_bg_color);
+		gdk_gc_set_foreground (gc, imhtml->default_bg_color);
+
+		gdk_draw_rectangle (GTK_LAYOUT (imhtml)->bin_window, gc, TRUE,
+				    0, imhtml->y - GTK_LAYOUT (imhtml)->vadjustment->value,
+				    GTK_WIDGET (imhtml)->allocation.width,
+				    oldy - imhtml->y);
+
+		gdk_gc_unref (gc);
+	}
+
+	gtk_layout_thaw (GTK_LAYOUT (imhtml));
+	gtk_imhtml_draw_focus (GTK_WIDGET (imhtml));
+}
+
+static void
+gtk_imhtml_size_allocate (GtkWidget     *widget,
+			  GtkAllocation *allocation)
+{
+	GtkIMHtml *imhtml;
+	GtkLayout *layout;
+	gint new_xsize, new_ysize;
+
+	g_return_if_fail (widget != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (widget));
+	g_return_if_fail (allocation != NULL);
+
+	imhtml = GTK_IMHTML (widget);
+	layout = GTK_LAYOUT (widget);
+
+	widget->allocation = *allocation;
+
+#if GTK_CHECK_VERSION(1,3,0)
+	new_xsize = MAX (1, (gint) allocation->width -
+			    (gint) (widget->style->xthickness + BORDER_SIZE) * 2);
+	new_ysize = MAX (1, (gint) allocation->height -
+			    (gint) (widget->style->ythickness + BORDER_SIZE) * 2);
+
+	if (GTK_WIDGET_REALIZED (widget)) {
+		gint x = widget->style->xthickness + BORDER_SIZE;
+		gint y = widget->style->ythickness + BORDER_SIZE;
+		gdk_window_move_resize (widget->window,
+					allocation->x, allocation->y,
+					allocation->width, allocation->height);
+		gdk_window_move_resize (layout->bin_window,
+					x, y, new_xsize, new_ysize);
+	}
+#else
+	new_xsize = MAX (1, (gint) allocation->width -
+			    (gint) (widget->style->klass->xthickness + BORDER_SIZE) * 2);
+	new_ysize = MAX (1, (gint) allocation->height -
+			    (gint) (widget->style->klass->ythickness + BORDER_SIZE) * 2);
+
+	if (GTK_WIDGET_REALIZED (widget)) {
+		gint x = widget->style->klass->xthickness + BORDER_SIZE;
+		gint y = widget->style->klass->ythickness + BORDER_SIZE;
+		gdk_window_move_resize (widget->window,
+					allocation->x, allocation->y,
+					allocation->width, allocation->height);
+		gdk_window_move_resize (layout->bin_window,
+					x, y, new_xsize, new_ysize);
+	}
+#endif
+
+	layout->hadjustment->page_size = new_xsize;
+	layout->hadjustment->page_increment = new_xsize / 2;
+	layout->hadjustment->lower = 0;
+	layout->hadjustment->upper = imhtml->x;
+
+	layout->vadjustment->page_size = new_ysize;
+	layout->vadjustment->page_increment = new_ysize / 2;
+	layout->vadjustment->lower = 0;
+	layout->vadjustment->upper = imhtml->y;
+
+	gtk_signal_emit_by_name (GTK_OBJECT (layout->hadjustment), "changed");
+	gtk_signal_emit_by_name (GTK_OBJECT (layout->vadjustment), "changed");
+
+	if (new_xsize == imhtml->xsize) {
+		if ((GTK_LAYOUT (imhtml)->vadjustment->value > imhtml->y - new_ysize)) {
+			if (imhtml->y > new_ysize)
+				gtk_adjustment_set_value (GTK_LAYOUT (imhtml)->vadjustment,
+							  imhtml->y - new_ysize);
+			else
+				gtk_adjustment_set_value (GTK_LAYOUT (imhtml)->vadjustment, 0);
+		}
+		return;
+	}
+
+	imhtml->xsize = new_xsize;
+
+	if (GTK_WIDGET_REALIZED (widget))
+		gtk_imhtml_redraw_all (imhtml);
+}
+
+static void
+gtk_imhtml_select_none (GtkIMHtml *imhtml)
+{
+	GList *bits;
+	GList *chunks;
+	GtkIMHtmlBit *bit;
+	struct line_info *chunk;
+
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	bits = imhtml->bits;
+	while (bits) {
+		bit = bits->data;
+		chunks = bit->chunks;
+
+		while (chunks) {
+			chunk = chunks->data;
+
+			if (chunk->selected) {
+				chunk->selected = FALSE;
+				chunk->sel_start = chunk->text;
+				chunk->sel_end = NULL;
+				if (DRAW_IMG (bit))
+					draw_img (imhtml, chunk);
+				else if ((bit->type == TYPE_SEP) && (bit->chunks->data == chunk))
+					draw_line (imhtml, chunk);
+				else if (chunk->width)
+					draw_text (imhtml, chunk);
+			}
+
+			chunks = g_list_next (chunks);
+		}
+
+		bits = g_list_next (bits);
+	}
+	imhtml->sel_endchunk = NULL;
+}
+
+static gchar*
+get_position (struct line_info *chunk,
+	      gint              x,
+	      gboolean          smileys)
+{
+	gint width = x - chunk->x;
+	gchar *text;
+	gchar *pos;
+	guint total = 0;
+
+	switch (chunk->bit->type) {
+	case TYPE_TEXT:
+	case TYPE_COMMENT:
+		text = chunk->text;
+		break;
+	case TYPE_SMILEY:
+		if (smileys)
+			return NULL;
+		else
+			text = chunk->text;
+		break;
+	default:
+		return NULL;
+		break;
+	}
+
+	if (width <= 0)
+		return text;
+
+	for (pos = text; *pos != '\0'; pos++) {
+		gint char_width = gdk_text_width (chunk->bit->font, pos, 1);
+		if ((width > total) && (width <= total + char_width)) {
+			if (width < total + (char_width / 2))
+				return pos;
+			else
+				return ++pos;
+		}
+		total += char_width;
+	}
+
+	return pos;
+}
+
+static GString*
+append_to_sel (GString          *string,
+	       struct line_info *chunk,
+	       gboolean          smileys)
+{
+	GString *new_string;
+	gchar *buf;
+	gchar *start;
+	gint length;
+
+	switch (chunk->bit->type) {
+	case TYPE_TEXT:
+	case TYPE_COMMENT:
+		start = (chunk->sel_start == NULL) ? chunk->text : chunk->sel_start;
+		length = (chunk->sel_end == NULL) ? strlen (start) : chunk->sel_end - start;
+		if (length <= 0)
+			return string;
+		buf = g_strndup (start, length);
+		break;
+	case TYPE_SMILEY:
+		if (smileys) {
+			start = (chunk->sel_start == NULL) ? chunk->bit->text : chunk->sel_start;
+			length = (chunk->sel_end == NULL) ? strlen (start) : chunk->sel_end - start;
+			if (length <= 0)
+				return string;
+			buf = g_strndup (start, length);
+		} else {
+			start = (chunk->sel_start == NULL) ? chunk->text : chunk->sel_start;
+			length = (chunk->sel_end == NULL) ? strlen (start) : chunk->sel_end - start;
+			if (length <= 0)
+				return string;
+			buf = g_strndup (start, length);
+		}
+		break;
+	case TYPE_BR:
+		buf = g_strdup ("\n");
+		break;
+	default:
+		return string;
+		break;
+	}
+
+	new_string = g_string_append (string, buf);
+	g_free (buf);
+
+	return new_string;
+}
+
+static void
+chunk_select_words (struct line_info *chunk)
+{
+	char *start, *end;
+
+	start = chunk->sel_start;
+	end = chunk->sel_end;
+
+	if (start != chunk->text) {
+		if (isalnum(*start) || *start == '\'')
+			while (start > chunk->text && 
+			       (isalnum(*(start-1)) || *(start-1) == '\''))
+				start--;
+		else if (isspace(*start))
+			while (start > chunk->text && isspace(*(start-1)))
+				start--;
+		else if (ispunct(*start))
+			while (start > chunk->text && ispunct(*(start-1)))
+				start--;
+	}
+	chunk->sel_start = start;
+
+	if (end != NULL) {
+		if (isalnum(*end) || *end == '\'')
+			while (*end != '\0' && 
+			       (isalnum(*end) || *end == '\''))
+				end++;
+		else if (isspace(*end))
+			while (*end != '\0' && isspace(*end))
+				end++;
+		else if (ispunct(*end))
+			while (*end != '\0' && ispunct(*end))
+				end++;
+	}
+	chunk->sel_end = end;
+}
+
+#define COORDS_IN_CHUNK(xx, yy) (((xx) < chunk->x + chunk->width) && \
+				 ((yy) < chunk->y + chunk->height))
+
+static void
+gtk_imhtml_select_bits (GtkIMHtml *imhtml)
+{
+	GList *bits;
+	GList *chunks;
+	GtkIMHtmlBit *bit;
+	struct line_info *chunk;
+
+	guint startx = imhtml->sel_startx,
+	      starty = imhtml->sel_starty,
+	      endx   = imhtml->sel_endx,
+	      endy   = imhtml->sel_endy;
+	gchar *new_pos;
+	gint selection = 0;
+	guint mode = imhtml->sel_mode;
+	gboolean smileys = imhtml->smileys;
+	gboolean redraw = FALSE;
+	gboolean got_start = FALSE;
+	gboolean got_end = FALSE;
+
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	if (!imhtml->selection)
+		return;
+
+	if (imhtml->selected_text) {
+		g_string_free (imhtml->selected_text, TRUE);
+		imhtml->selected_text = g_string_new ("");
+	}
+
+	if (mode == 2)
+		startx = endx = 0;
+
+	bits = imhtml->bits;
+	while (bits) {
+		bit = bits->data;
+		chunks = bit->chunks;
+
+		while (chunks) {
+			chunk = chunks->data;
+
+			switch (selection) {
+			case 0:
+				if (COORDS_IN_CHUNK (startx, starty)) {
+					new_pos = get_position (chunk, startx, smileys);
+					if (!chunk->selected ||
+					    (chunk->sel_start != new_pos) ||
+					    (chunk->sel_end != NULL))
+						redraw = TRUE;
+					chunk->selected = TRUE;
+					chunk->sel_start = new_pos;
+					chunk->sel_end = NULL;
+					selection++;
+					got_start = TRUE;
+					if (mode == 2)
+						endy += chunk->height;
+					if (mode == 1)
+						chunk_select_words (chunk);
+				}
+
+				if (COORDS_IN_CHUNK (endx, endy)) {
+					if (got_start) {
+						new_pos = get_position (chunk, endx, smileys);
+						if (chunk->sel_end != new_pos)
+							redraw = TRUE;
+						if (chunk->sel_start > new_pos) {
+							chunk->sel_end = chunk->sel_start;
+							chunk->sel_start = new_pos;
+						} else
+							chunk->sel_end = new_pos;
+						selection = 2;
+						imhtml->sel_endchunk = chunk;
+						got_end = TRUE;
+						if (mode == 1)
+							chunk_select_words (chunk);
+					} else {
+						new_pos = get_position (chunk, endx, smileys);
+						if ( !chunk->selected ||
+						    (chunk->sel_start != new_pos) ||
+						    (chunk->sel_end != NULL))
+							redraw = TRUE;
+						chunk->selected = TRUE;
+						chunk->sel_start = new_pos;
+						chunk->sel_end = NULL;
+						selection++;
+						imhtml->sel_endchunk = chunk;
+						got_end = TRUE;
+						if (mode == 2)
+							starty += chunk->height;
+						if (mode == 1)
+							chunk_select_words (chunk);
+					}
+				} else if (!COORDS_IN_CHUNK (startx, starty) && !got_start) {
+					if (chunk->selected)
+						redraw = TRUE;
+					chunk->selected = FALSE;
+					chunk->sel_start = chunk->text;
+					chunk->sel_end = NULL;
+				}
+
+				break;
+			case 1:
+				if (!got_start && COORDS_IN_CHUNK (startx, starty)) {
+					new_pos = get_position (chunk, startx, smileys);
+					if ( !chunk->selected ||
+					    (chunk->sel_end != new_pos) ||
+					    (chunk->sel_start != chunk->text))
+						redraw = TRUE;
+					chunk->selected = TRUE;
+					chunk->sel_start = chunk->text;
+					chunk->sel_end = new_pos;
+					selection++;
+					got_start = TRUE;
+					if (mode == 1)
+						chunk_select_words (chunk);
+				} else if (!got_end && COORDS_IN_CHUNK (endx, endy)) {
+					new_pos = get_position (chunk, endx, smileys);
+					if ( !chunk->selected ||
+					    (chunk->sel_end != new_pos) ||
+					    (chunk->sel_start != chunk->text))
+						redraw = TRUE;
+					chunk->selected = TRUE;
+					chunk->sel_start = chunk->text;
+					chunk->sel_end = new_pos;
+					selection++;
+					imhtml->sel_endchunk = chunk;
+					got_end = TRUE;
+					if (mode == 1)
+						chunk_select_words (chunk);
+				} else {
+					if ( !chunk->selected ||
+					    (chunk->sel_end != NULL) ||
+					    (chunk->sel_start != chunk->text))
+						redraw = TRUE;
+					chunk->selected = TRUE;
+					chunk->sel_start = chunk->text;
+					chunk->sel_end = NULL;
+				}
+
+				break;
+			case 2:
+				if (chunk->selected)
+					redraw = TRUE;
+				chunk->selected = FALSE;
+				chunk->sel_start = chunk->text;
+				chunk->sel_end = NULL;
+				break;
+			}
+
+			if (chunk->selected == TRUE)
+				imhtml->selected_text = append_to_sel (imhtml->selected_text,
+								       chunk, smileys);
+
+			if (redraw) {
+				if (DRAW_IMG (bit))
+					draw_img (imhtml, chunk);
+				else if ((bit->type == TYPE_SEP) && (bit->chunks->data == chunk))
+					draw_line (imhtml, chunk);
+				else if (chunk->width)
+					draw_text (imhtml, chunk);
+				redraw = FALSE;
+			}
+
+			chunks = g_list_next (chunks);
+		}
+
+		bits = g_list_next (bits);
+	}
+}
+
+static void
+gtk_imhtml_select_in_chunk (GtkIMHtml *imhtml,
+			    struct line_info *chunk)
+{
+	GtkIMHtmlBit *bit = chunk->bit;
+	gchar *new_pos;
+	guint endx = imhtml->sel_endx;
+	guint startx = imhtml->sel_startx;
+	guint starty = imhtml->sel_starty;
+	gboolean smileys = imhtml->smileys;
+	gboolean redraw = FALSE;
+
+	new_pos = get_position (chunk, endx, smileys);
+	if ((starty < chunk->y) ||
+	    ((starty < chunk->y + chunk->height) && (startx < endx))) {
+		if (chunk->sel_end != new_pos)
+			redraw = TRUE;
+		chunk->sel_end = new_pos;
+	} else {
+		if (chunk->sel_start != new_pos)
+			redraw = TRUE;
+		chunk->sel_start = new_pos;
+	}
+
+	if (redraw) {
+		if (DRAW_IMG (bit))
+			draw_img (imhtml, chunk);
+		else if ((bit->type == TYPE_SEP) && 
+			 (bit->chunks->data == chunk))
+			draw_line (imhtml, chunk);
+		else if (chunk->width)
+			draw_text (imhtml, chunk);
+	}
+}
+
+static gint
+scroll_timeout (GtkIMHtml *imhtml)
+{
+	GdkEventMotion event;
+	gint x, y;
+	GdkModifierType mask;
+
+	imhtml->scroll_timer = 0;
+
+	gdk_window_get_pointer (GTK_LAYOUT (imhtml)->bin_window, &x, &y, &mask);
+
+	if (mask & GDK_BUTTON1_MASK) {
+		event.is_hint = 0;
+		event.x = x;
+		event.y = y;
+		event.state = mask;
+
+		gtk_imhtml_motion_notify_event (GTK_WIDGET (imhtml), &event);
+	}
+
+	return FALSE;
+}
+
+static gint
+gtk_imhtml_tip_paint (GtkIMHtml *imhtml)
+{
+	GtkStyle *style;
+	GdkFont *font;
+	gint y, baseline_skip, gap;
+
+	style = imhtml->tip_window->style;
+	font = GTK_IMHTML_GET_STYLE_FONT (style);
+
+	gap = (font->ascent + font->descent) / 4;
+	if (gap < 2)
+		gap = 2;
+	baseline_skip = font->ascent + font->descent + gap;
+
+	if (!imhtml->tip_bit)
+		return FALSE;
+
+	gtk_paint_flat_box (style, imhtml->tip_window->window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+			   NULL, imhtml->tip_window, "tooltip", 0, 0, -1, -1);
+
+	y = font->ascent + 4;
+	if (imhtml->tip_bit->url)
+		gtk_paint_string (style, imhtml->tip_window->window, GTK_STATE_NORMAL, NULL,
+				  imhtml->tip_window, "tooltip", 4, y, imhtml->tip_bit->url);
+	else if (imhtml->tip_bit->img)
+		gtk_paint_string (style, imhtml->tip_window->window, GTK_STATE_NORMAL, NULL,
+				  imhtml->tip_window, "tooltip", 4, y, imhtml->tip_bit->img->filename);
+
+	return FALSE;
+}
+
+static gint
+gtk_imhtml_tip (gpointer data)
+{
+	GtkIMHtml *imhtml = data;
+	GtkWidget *widget = GTK_WIDGET (imhtml);
+	GtkStyle *style;
+	GdkFont *font;
+	gint gap, x, y, w, h, scr_w, scr_h, baseline_skip;
+
+	if (!imhtml->tip_bit || !GTK_WIDGET_DRAWABLE (widget)) {
+		imhtml->tip_timer = 0;
+		return FALSE;
+	}
+
+	if (imhtml->tip_window)
+		gtk_widget_destroy (imhtml->tip_window);
+
+	imhtml->tip_window = gtk_window_new (GTK_WINDOW_POPUP);
+	gtk_widget_set_app_paintable (imhtml->tip_window, TRUE);
+	gtk_window_set_policy (GTK_WINDOW (imhtml->tip_window), FALSE, FALSE, TRUE);
+	gtk_widget_set_name (imhtml->tip_window, "gtk-tooltips");
+	gtk_signal_connect_object (GTK_OBJECT (imhtml->tip_window), "expose_event",
+				   GTK_SIGNAL_FUNC (gtk_imhtml_tip_paint), GTK_OBJECT (imhtml));
+	gtk_signal_connect_object (GTK_OBJECT (imhtml->tip_window), "draw",
+				   GTK_SIGNAL_FUNC (gtk_imhtml_tip_paint), GTK_OBJECT (imhtml));
+
+	gtk_widget_ensure_style (imhtml->tip_window);
+	style = imhtml->tip_window->style;
+	font = GTK_IMHTML_GET_STYLE_FONT (style);
+
+	scr_w = gdk_screen_width ();
+	scr_h = gdk_screen_height ();
+
+	gap = (font->ascent + font->descent) / 4;
+	if (gap < 2)
+		gap = 2;
+	baseline_skip = font->ascent + font->descent + gap;
+
+	w = 8 + gdk_string_width (font, imhtml->tip_bit->img ? imhtml->tip_bit->img->filename : 
+				  imhtml->tip_bit->url);
+	h = 8 - gap + baseline_skip;
+
+	gdk_window_get_pointer (NULL, &x, &y, NULL);
+	if (GTK_WIDGET_NO_WINDOW (widget))
+		y += widget->allocation.y;
+
+	x -= ((w >> 1) + 4);
+
+	if ((x + w) > scr_w)
+		x -= (x + w) - scr_w;
+	else if (x < 0)
+		x = 0;
+
+	if ((y + h + + 4) > scr_h)
+		y = y - imhtml->tip_bit->font->ascent + imhtml->tip_bit->font->descent;
+	else 
+		if (imhtml->tip_bit->font)
+			y = y + imhtml->tip_bit->font->ascent + imhtml->tip_bit->font->descent;
+		else
+			y = y + font->ascent + font->descent;
+
+	gtk_widget_set_usize (imhtml->tip_window, w, h);
+	gtk_widget_set_uposition (imhtml->tip_window, x, y);
+	gtk_widget_show (imhtml->tip_window);
+
+	imhtml->tip_timer = 0;
+	return FALSE;
+}
+
+static gint
+gtk_imhtml_motion_notify_event (GtkWidget      *widget,
+				GdkEventMotion *event)
+{
+	gint x, y;
+	GdkModifierType state;
+	GtkIMHtml *imhtml = GTK_IMHTML (widget);
+	GtkAdjustment *vadj = GTK_LAYOUT (widget)->vadjustment;
+	GtkAdjustment *hadj = GTK_LAYOUT (widget)->hadjustment;
+
+	if (event->is_hint)
+		gdk_window_get_pointer (event->window, &x, &y, &state);
+	else {
+		x = event->x + hadj->value;
+		y = event->y + vadj->value;
+		state = event->state;
+	}
+
+	if (state & GDK_BUTTON1_MASK) {
+		gint diff;
+		gint height = vadj->page_size;
+		gint yy = y - vadj->value;
+
+		if (((yy < 0) || (yy > height)) &&
+		    (imhtml->scroll_timer == 0) &&
+		    (vadj->upper > vadj->page_size)) {
+			imhtml->scroll_timer = gtk_timeout_add (100,
+								(GtkFunction) scroll_timeout,
+								imhtml);
+			diff = (yy < 0) ? (yy / 2) : ((yy - height) / 2);
+			gtk_adjustment_set_value (vadj,
+						  MIN (vadj->value + diff, vadj->upper - height));
+		}
+
+		if (imhtml->selection) {
+			struct line_info *chunk = imhtml->sel_endchunk;
+			imhtml->sel_endx = MAX (x, 0);
+			imhtml->sel_endy = MAX (y, 0);
+			if ((chunk == NULL) ||
+			    (x < chunk->x) ||
+			    (x > chunk->x + chunk->width) ||
+			    (y < chunk->y) ||
+			    (y > chunk->y + chunk->height) ||
+			    (imhtml->sel_mode > 0))
+				gtk_imhtml_select_bits (imhtml);
+			else
+				gtk_imhtml_select_in_chunk (imhtml, chunk);
+		}
+	} else {
+		GList *click = imhtml->click;
+		struct clickable *uw;
+
+		while (click) {
+			uw = (struct clickable *) click->data;
+			if ((x > uw->x) && (x < uw->x + uw->width) &&
+			    (y > uw->y) && (y < uw->y + uw->height) &&
+			    (uw->bit->url || uw->bit->img)) {
+				if (imhtml->tip_bit != uw->bit) {
+					imhtml->tip_bit = uw->bit;
+					if (imhtml->tip_timer != 0)
+						gtk_timeout_remove (imhtml->tip_timer);
+					if (imhtml->tip_window) {
+						gtk_widget_destroy (imhtml->tip_window);
+						imhtml->tip_window = NULL;
+					}
+					imhtml->tip_timer = gtk_timeout_add (TOOLTIP_TIMEOUT,
+									     gtk_imhtml_tip,
+									     imhtml);
+				}
+				if (uw->bit->url)
+					gdk_window_set_cursor (GTK_LAYOUT (imhtml)->bin_window,
+							       imhtml->hand_cursor);
+				return TRUE;
+			}
+			click = g_list_next (click);
+		}
+	}
+
+	if (imhtml->tip_timer) {
+		gtk_timeout_remove (imhtml->tip_timer);
+		imhtml->tip_timer = 0;
+	}
+	if (imhtml->tip_window) {
+		gtk_widget_destroy (imhtml->tip_window);
+		imhtml->tip_window = NULL;
+	}
+	imhtml->tip_bit = NULL;
+
+	gdk_window_set_cursor (GTK_LAYOUT (imhtml)->bin_window, imhtml->arrow_cursor);
+
+	return TRUE;
+}
+
+static gint
+gtk_imhtml_leave_notify_event (GtkWidget        *widget,
+			       GdkEventCrossing *event)
+{
+	GtkIMHtml *imhtml = GTK_IMHTML (widget);
+
+	if (imhtml->tip_timer) {
+		gtk_timeout_remove (imhtml->tip_timer);
+		imhtml->tip_timer = 0;
+	}
+	if (imhtml->tip_window) {
+		gtk_widget_destroy (imhtml->tip_window);
+		imhtml->tip_window = NULL;
+	}
+	imhtml->tip_bit = NULL;
+return TRUE;
+}
+struct imgsv {
+	GtkWidget *savedialog;
+	struct im_image *img;
+};
+
+static void
+save_img (GtkObject *object,
+	  gpointer data)
+{
+	struct imgsv *is = data;
+	struct im_image *img = is->img;
+	gchar *filename;
+	FILE *f;
+	filename = gtk_file_selection_get_filename(GTK_FILE_SELECTION(is->savedialog));
+	g_print("Saving %s\n", filename);
+	if (! (f=fopen(filename, "w"))) {
+		/* There should be some sort of dialog */
+		g_print("Could not open file for writing.\n");
+		gtk_widget_destroy(is->savedialog);
+		g_free(is);
+		return;
+	}
+	
+	fwrite(img->data, 1, img->len, f);
+	fclose(f);
+	gtk_widget_destroy(is->savedialog);
+	g_free(is);
+}
+
+static void
+save_img_dialog (GtkObject *object,
+		 gpointer data)
+{
+	struct imgsv *is = g_malloc(sizeof(struct imgsv)); 
+	struct im_image *img = data;
+	GtkWidget *savedialog = gtk_file_selection_new ("Gaim - Save Image");
+	gtk_file_selection_set_filename (GTK_FILE_SELECTION(savedialog), img->filename);
+	gtk_signal_connect_object (GTK_OBJECT (GTK_FILE_SELECTION(savedialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC (gtk_widget_destroy),
+				   (gpointer) savedialog);
+	
+	is->img = img;
+	is->savedialog = savedialog;
+	
+	gtk_signal_connect (GTK_OBJECT (GTK_FILE_SELECTION(savedialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC (save_img), is);
+	gtk_widget_show (savedialog);
+
+
+}
+
+
+static void
+menu_open_url (GtkObject *object,
+	       gpointer   data)
+{
+	struct clickable *uw = data;
+
+	gtk_signal_emit (GTK_OBJECT (uw->imhtml), signals [URL_CLICKED], uw->bit->url);
+}
+
+static void
+menu_copy_link (GtkObject *object,
+		gpointer   data)
+{
+	struct clickable *uw = data;
+	GtkIMHtml *imhtml = uw->imhtml;
+
+	if (imhtml->selected_text)
+		g_string_free (imhtml->selected_text, TRUE);
+
+	gtk_imhtml_select_none (uw->imhtml);
+
+	imhtml->selection = TRUE;
+	imhtml->selected_text = g_string_new (uw->bit->url);
+
+	gtk_selection_owner_set (GTK_WIDGET (imhtml), GDK_SELECTION_PRIMARY, GDK_CURRENT_TIME);
+}
+
+static gint
+gtk_imhtml_button_press_event (GtkWidget      *widget,
+			       GdkEventButton *event)
+{
+	GtkIMHtml *imhtml = GTK_IMHTML (widget);
+	GtkAdjustment *vadj = GTK_LAYOUT (widget)->vadjustment;
+	GtkAdjustment *hadj = GTK_LAYOUT (widget)->hadjustment;
+	gint x, y;
+
+	x = event->x + hadj->value;
+	y = event->y + vadj->value;
+
+	if (event->button == 1) {
+		imhtml->sel_startx = imhtml->sel_endx = x;
+		imhtml->sel_starty = imhtml->sel_endy = y;
+		imhtml->selection = TRUE;
+		if (event->type == GDK_BUTTON_PRESS) {
+			imhtml->sel_mode = 0; /* select by letter */
+			gtk_imhtml_select_none (imhtml);
+		} else if (event->type == GDK_2BUTTON_PRESS) {
+			imhtml->sel_mode = 1; /* select by word */
+			gtk_imhtml_select_none (imhtml);
+		} else if (event->type == GDK_3BUTTON_PRESS) {
+			imhtml->sel_mode = 2; /* select by line */
+			gtk_imhtml_select_bits (imhtml);
+		}
+	}
+
+	if (event->button == 3) {
+		GList *click = imhtml->click;
+		struct clickable *uw;
+
+		while (click) {
+			uw = click->data;
+			if ((x > uw->x) && (x < uw->x + uw->width) &&
+			    (y > uw->y) && (y < uw->y + uw->height)) {
+				GtkWidget *menu = gtk_menu_new ();
+				GtkWidget *button;
+
+				if (uw->bit->url) {
+					button = gtk_menu_item_new_with_label ("Open URL");
+					gtk_signal_connect (GTK_OBJECT (button), "activate",
+							    GTK_SIGNAL_FUNC (menu_open_url), uw);
+					gtk_menu_append (GTK_MENU (menu), button);
+					gtk_widget_show (button);
+
+					button = gtk_menu_item_new_with_label ("Copy Link Location");
+					gtk_signal_connect (GTK_OBJECT (button), "activate",
+							    GTK_SIGNAL_FUNC (menu_copy_link), uw);
+					gtk_menu_append (GTK_MENU (menu), button);
+					gtk_widget_show (button);
+				}
+
+				if (uw->bit->img) {
+					button = gtk_menu_item_new_with_label ("Save Image");
+					gtk_signal_connect (GTK_OBJECT (button), "activate",
+							    GTK_SIGNAL_FUNC (save_img_dialog), uw->bit->img);
+					gtk_menu_append (GTK_MENU (menu), button);
+					gtk_widget_show (button);
+				}
+				
+				gtk_menu_popup (GTK_MENU (menu), NULL, NULL, NULL, NULL, 3, event->time);
+
+				if (imhtml->tip_timer) {
+					gtk_timeout_remove (imhtml->tip_timer);
+					imhtml->tip_timer = 0;
+				}
+				if (imhtml->tip_window) {
+					gtk_widget_destroy (imhtml->tip_window);
+					imhtml->tip_window = NULL;
+				}
+				imhtml->tip_bit = NULL;
+
+				return TRUE;
+			}
+			click = g_list_next (click);
+		}
+	}
+
+	return TRUE;
+}
+
+static gint
+gtk_imhtml_button_release_event (GtkWidget      *widget,
+				 GdkEventButton *event)
+{
+	GtkIMHtml *imhtml = GTK_IMHTML (widget);
+	GtkAdjustment *vadj = GTK_LAYOUT (widget)->vadjustment;
+	GtkAdjustment *hadj = GTK_LAYOUT (widget)->hadjustment;
+	gint x, y;
+
+	x = event->x + hadj->value;
+	y = event->y + vadj->value;
+
+	if ((event->button == 1) && imhtml->selection) {
+		if ((x == imhtml->sel_startx) && (y == imhtml->sel_starty) &&
+		    (imhtml->sel_mode == 0)) {
+			imhtml->sel_startx = imhtml->sel_starty = 0;
+			imhtml->selection = FALSE;
+			gtk_imhtml_select_none (imhtml);
+		} else {
+			imhtml->sel_endx = MAX (x, 0);
+			imhtml->sel_endy = MAX (y, 0);
+			gtk_imhtml_select_bits (imhtml);
+		}
+
+		gtk_selection_owner_set (widget, GDK_SELECTION_PRIMARY, event->time);
+	}
+
+	if ((event->button == 1) && (imhtml->sel_startx == 0)) {
+		GList *click = imhtml->click;
+		struct clickable *uw;
+
+		while (click) {
+			uw = (struct clickable *) click->data;
+			if ((x > uw->x) && (x < uw->x + uw->width) &&
+			    (y > uw->y) && (y < uw->y + uw->height)) {
+				gtk_signal_emit (GTK_OBJECT (imhtml), signals [URL_CLICKED],
+						 uw->bit->url);
+				return TRUE;
+			}
+			click = g_list_next (click);
+		}
+	}
+
+	return TRUE;
+}
+
+static void
+gtk_imhtml_selection_get (GtkWidget        *widget,
+			  GtkSelectionData *sel_data,
+			  guint             sel_info,
+			  guint32           time)
+{
+	GtkIMHtml *imhtml;
+	gchar *string;
+	gint length;
+
+	g_return_if_fail (widget != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (widget));
+	g_return_if_fail (sel_data->selection == GDK_SELECTION_PRIMARY);
+
+	imhtml = GTK_IMHTML (widget);
+
+	g_return_if_fail (imhtml->selected_text != NULL);
+	g_return_if_fail (imhtml->selected_text->str != NULL);
+
+	if (imhtml->selected_text->len <= 0)
+		return;
+
+	string = g_strdup (imhtml->selected_text->str);
+	length = strlen (string);
+
+	if (sel_info == TARGET_STRING) {
+		gtk_selection_data_set (sel_data,
+					GDK_SELECTION_TYPE_STRING,
+					8 * sizeof (gchar),
+					(guchar *) string,
+					length);
+	} else if ((sel_info == TARGET_TEXT) || (sel_info == TARGET_COMPOUND_TEXT)) {
+		guchar *text;
+		GdkAtom encoding;
+		gint format;
+		gint new_length;
+
+		gdk_string_to_compound_text (string, &encoding, &format, &text, &new_length);
+		gtk_selection_data_set (sel_data, encoding, format, text, new_length);
+		gdk_free_compound_text (text);
+	}
+
+	g_free (string);
+}
+
+static gint
+gtk_imhtml_selection_clear_event (GtkWidget         *widget,
+				  GdkEventSelection *event)
+{
+	GtkIMHtml *imhtml;
+
+	g_return_val_if_fail (widget != NULL, FALSE);
+	g_return_val_if_fail (GTK_IS_IMHTML (widget), FALSE);
+	g_return_val_if_fail (event != NULL, FALSE);
+	g_return_val_if_fail (event->selection == GDK_SELECTION_PRIMARY, TRUE);
+
+	if (!gtk_selection_clear (widget, event))
+		return FALSE;
+
+	imhtml = GTK_IMHTML (widget);
+
+	gtk_imhtml_select_none (imhtml);
+
+	return TRUE;
+}
+
+static void
+gtk_imhtml_adjustment_changed (GtkAdjustment *adjustment,
+			       GtkIMHtml     *imhtml)
+{
+	GtkLayout *layout = GTK_LAYOUT (imhtml);
+
+	if (!GTK_WIDGET_MAPPED (imhtml) || !GTK_WIDGET_REALIZED (imhtml))
+		return;
+
+	if (layout->freeze_count)
+		return;
+
+	if (layout->vadjustment->value < TOP_BORDER)
+		gdk_window_clear_area (layout->bin_window, 0, 0,
+				       imhtml->xsize, TOP_BORDER - layout->vadjustment->value);
+
+	gtk_imhtml_draw_exposed (imhtml);
+}
+
+static void
+gtk_imhtml_set_scroll_adjustments (GtkLayout     *layout,
+				   GtkAdjustment *hadj,
+				   GtkAdjustment *vadj)
+{
+	gboolean need_adjust = FALSE;
+
+	g_return_if_fail (layout != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (layout));
+
+	if (hadj)
+		g_return_if_fail (GTK_IS_ADJUSTMENT (hadj));
+	else
+		hadj = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
+	if (vadj)
+		g_return_if_fail (GTK_IS_ADJUSTMENT (vadj));
+	else
+		vadj = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
+
+	if (layout->hadjustment && (layout->hadjustment != hadj)) {
+		gtk_signal_disconnect_by_data (GTK_OBJECT (layout->hadjustment), layout);
+		gtk_object_unref (GTK_OBJECT (layout->hadjustment));
+	}
+
+	if (layout->vadjustment && (layout->vadjustment != vadj)) {
+		gtk_signal_disconnect_by_data (GTK_OBJECT (layout->vadjustment), layout);
+		gtk_object_unref (GTK_OBJECT (layout->vadjustment));
+	}
+
+	if (layout->hadjustment != hadj) {
+		layout->hadjustment = hadj;
+		gtk_object_ref (GTK_OBJECT (layout->hadjustment));
+		gtk_object_sink (GTK_OBJECT (layout->hadjustment));
+
+		gtk_signal_connect (GTK_OBJECT (layout->hadjustment), "value_changed",
+				    (GtkSignalFunc) gtk_imhtml_adjustment_changed, layout);
+		need_adjust = TRUE;
+	}
+	
+	if (layout->vadjustment != vadj) {
+		layout->vadjustment = vadj;
+		gtk_object_ref (GTK_OBJECT (layout->vadjustment));
+		gtk_object_sink (GTK_OBJECT (layout->vadjustment));
+
+		gtk_signal_connect (GTK_OBJECT (layout->vadjustment), "value_changed",
+				    (GtkSignalFunc) gtk_imhtml_adjustment_changed, layout);
+		need_adjust = TRUE;
+	}
+
+	if (need_adjust)
+		gtk_imhtml_adjustment_changed (NULL, GTK_IMHTML (layout));
+}
+
+static void
+gtk_imhtml_class_init (GtkIMHtmlClass *class)
+{
+#if GTK_CHECK_VERSION(1,3,0)
+	GObjectClass  *gobject_class;
+#endif
+	GtkObjectClass *object_class;
+	GtkWidgetClass *widget_class;
+	GtkLayoutClass *layout_class;
+
+#if GTK_CHECK_VERSION(1,3,0)
+	gobject_class = (GObjectClass*) class;
+#endif
+	object_class = (GtkObjectClass*) class;
+	widget_class = (GtkWidgetClass*) class;
+	layout_class = (GtkLayoutClass*) class;
+
+	parent_class = gtk_type_class (GTK_TYPE_LAYOUT);
+
+	signals [URL_CLICKED] =
+		gtk_signal_new ("url_clicked",
+				GTK_RUN_FIRST,
+				GTK_CLASS_TYPE (object_class),
+				GTK_SIGNAL_OFFSET (GtkIMHtmlClass, url_clicked),
+				gtk_marshal_NONE__POINTER,
+				GTK_TYPE_NONE, 1,
+				GTK_TYPE_POINTER);
+
+#if GTK_CHECK_VERSION(1,3,0)
+	gobject_class->finalize = gtk_imhtml_finalize;
+#else
+	gtk_object_class_add_signals (object_class, signals, LAST_SIGNAL);
+
+	object_class->destroy = gtk_imhtml_destroy;
+#endif
+
+	widget_class->realize = gtk_imhtml_realize;
+#if !GTK_CHECK_VERSION(1,3,0)
+	widget_class->draw = gtk_imhtml_draw;
+	widget_class->draw_focus = gtk_imhtml_draw_focus;
+#endif
+	widget_class->style_set = gtk_imhtml_style_set;
+	widget_class->expose_event  = gtk_imhtml_expose_event;
+	widget_class->size_allocate = gtk_imhtml_size_allocate;
+	widget_class->motion_notify_event = gtk_imhtml_motion_notify_event;
+	widget_class->leave_notify_event = gtk_imhtml_leave_notify_event;
+	widget_class->button_press_event = gtk_imhtml_button_press_event;
+	widget_class->button_release_event = gtk_imhtml_button_release_event;
+	widget_class->selection_get = gtk_imhtml_selection_get;
+	widget_class->selection_clear_event = gtk_imhtml_selection_clear_event;
+
+	layout_class->set_scroll_adjustments = gtk_imhtml_set_scroll_adjustments;
+}
+
+/* the font stuff is the most insane stuff. i don't understand it half
+ * the time. so we're going to comment it. isn't that wonderful. */
+
+/* when you g_strsplit a valid font name, these are the positions of all the various parts of it. */
+#define FNDRY 1
+#define FMLY 2
+#define WGHT 3
+#define SLANT 4
+#define SWDTH 5
+#define ADSTYL 6
+#define PXLSZ 7
+#define PTSZ 8
+#define RESX 9
+#define RESY 10
+#define SPC 11
+#define AVGWDTH 12
+#define RGSTRY 13
+#define ENCDNG 14
+
+static gchar*
+gtk_imhtml_get_font_name (GdkFont *font)
+{
+#if GTK_CHECK_VERSION(1,3,0)
+	return "--*-helvetica-medium-r-normal--10-*-*-*-*-*-*-*";
+#else
+	GdkFontPrivate *fontpriv = (GdkFontPrivate *) font;
+	return fontpriv->names->data;
+#endif
+}
+
+static GdkFont*
+gtk_imhtml_font_load (GtkIMHtml *imhtml,
+		      gchar     *name,
+		      gboolean   bold,
+		      gboolean   italics,
+		      gint       fontsize)
+{
+	GdkFont *default_font = imhtml->default_font;
+	gchar *default_name;
+	gchar **xnames;
+	gchar **pos;
+	gchar *tmp = NULL;
+	GdkFont *ret_font;
+	gchar *xname;
+	gchar **xflds;
+	gchar **newvals;
+	gchar **names = NULL;
+
+	char *italicstrings[] = {"i","o","*"};
+	int italicsind = 0, nameind = 0;
+	gboolean usebold = TRUE, usesize = TRUE, useregenc = TRUE;
+	
+	/* if we're not changing anything, use the default. this is the common case */
+	if (!name && !bold && !italics && !fontsize)
+		return gdk_font_ref (default_font);
+	
+	/* base things off of the default font name */
+	default_name = gtk_imhtml_get_font_name (default_font);
+	/* the default font name can actually be several names separated by ','.
+	 * This is a fontset... used in foreign encodings. */
+	do {
+		xnames = g_strsplit (default_name, ",", -1);
+		for (pos = xnames; pos && *pos; pos++) {
+			gint i, j;
+			gchar fs[10];
+			gchar *garbage;
+			xname = *pos;
+			xname = g_strchomp (xname);
+			xname = g_strchug (xname);
+			
+			xflds = g_strsplit (xname, "-", -1);
+			
+			/* figure out if we have a valid name. i wish there were an
+			 * easier way for determining how many values g_strplit gave */
+			for (i = 0; xflds [i]; i++);
+			if (i != 15) {
+				int tmp;
+				newvals = g_malloc0 (16 * sizeof (gchar *));
+				newvals [0] = "";
+				for (tmp = 1; tmp < 15; tmp++)
+					newvals [tmp] = "*";
+			} else
+				newvals = g_memdup (xflds, 16 * sizeof (xflds));
+			
+			/* we force foundry as "*" because i hate them. i should give a better reason. */
+			newvals [FNDRY] = "*";
+			
+			/* if it's "*" then it defaults to (nil) anyway. some fonts don't want (nil) */
+			if ((i > ADSTYL) && !xflds [ADSTYL][0])
+				newvals [ADSTYL] = "*";
+			
+			/* If the font doesn't work the first time, we try it with 
+			 * registry and encoding as "*" */
+			if (!useregenc) {
+				newvals [RGSTRY] = "*";
+				newvals [ENCDNG] = "*";
+			}
+			/* right. */
+			if (usebold && bold)
+				newvals [WGHT] = "bold";
+			else if (!usebold)
+				newvals [WGHT] = "*";
+			
+			if (italics)
+				/* We'll try "i" "o" to get italics and then just use "*" */
+				newvals [SLANT] = italicstrings[italicsind];
+			
+			if (usesize && fontsize) {
+				g_snprintf (fs, sizeof (fs), "%d", POINT_SIZE (fontsize));
+				newvals [PTSZ] = fs;
+				newvals [PXLSZ] = "*";
+			} else if (!usesize) {
+				newvals [PTSZ] = "*";
+				newvals [PXLSZ] = "*";
+			}
+			
+			if (name) {
+				/* we got passed a name. it might be a list of names. */
+				gchar **tmp_nms = g_strsplit (name, ",", -1);
+				for (j = 0; tmp_nms [j]; j++);
+				names = g_new0 (char *, j + 2);
+				for (j = 0; tmp_nms [j]; j++)
+					names [j] = tmp_nms [j];
+				g_free (tmp_nms);
+				/* Put the default font on the array. */
+				if (i > FMLY) {
+					names [j] = g_strdup (xflds [FMLY]);
+				}
+				newvals [FMLY] = names[nameind];
+			} else if (i > FMLY) {
+				/* we didn't get a name. we come here if the gtk font name is valid */
+				names = g_new0 (gchar *, 2);
+				names [0] = g_strdup (xflds [FMLY]);
+			} else {
+				/* we got fucked */
+				names = g_new0 (gchar *, 2);
+				names [0] = g_strdup ("*");
+			}
+			if (!tmp)
+				tmp = g_strjoinv("-", newvals);
+			else {
+				/* We have to concat the xlfds in the fontset */ 
+				garbage = tmp;
+				tmp = g_strconcat(garbage, ",", 
+						  g_strjoinv ("-", newvals), NULL); 
+				g_free(garbage);
+			}
+			g_free (newvals);
+			g_strfreev (xflds);
+		}
+		g_strfreev (xnames);
+		
+		if (default_font->type == GDK_FONT_FONT) 
+			ret_font = gdk_font_load (tmp); 
+		else {
+			/* For some reason, fontsets must end with a single * as an xlfd */
+			gchar *garbage = tmp;
+			tmp = g_strconcat(garbage, ",*", NULL);
+			ret_font = gdk_fontset_load (tmp); 
+		}
+		/* If the font didn't load, we change some of the xlfds one by one
+		 * to get the closest we can.  */
+		if (!ret_font) {
+			if (useregenc) {
+				useregenc = FALSE;
+			} else if (italics && italicsind != 2) {
+				useregenc = TRUE;
+				italicsind++;
+			} else if (bold && usebold) {
+				useregenc = TRUE;
+				italicsind=0;
+				usebold = FALSE;
+			} else if (usesize) {
+				useregenc = TRUE;        
+				italicsind = 0;
+				usebold = TRUE;
+				usesize = FALSE;
+			} else if (names && names[nameind++]) {
+				useregenc = TRUE;        
+				italicsind = 0;
+				usebold = TRUE;
+				usesize = TRUE;
+			} else {
+				ret_font = gdk_font_ref(default_font);
+			}
+		}
+		g_strfreev (names);
+		names = NULL;
+		g_free(tmp);
+		tmp=NULL;
+	} while (!ret_font); /* Loop with the new options */
+	return ret_font;
+}
+	
+static void
+gtk_imhtml_init (GtkIMHtml *imhtml)
+{
+	static const GtkTargetEntry targets [] = {
+		{ "STRING", 0, TARGET_STRING },
+		{ "TEXT", 0, TARGET_TEXT },
+		{ "COMPOUND_TEXT", 0, TARGET_COMPOUND_TEXT }
+	};
+
+	imhtml->hand_cursor = gdk_cursor_new (GDK_HAND2);
+	imhtml->arrow_cursor = gdk_cursor_new (GDK_LEFT_PTR);
+
+	GTK_WIDGET_SET_FLAGS (GTK_WIDGET (imhtml), GTK_CAN_FOCUS);
+	gtk_selection_add_targets (GTK_WIDGET (imhtml), GDK_SELECTION_PRIMARY, targets, 3);
+}
+
+GtkType
+gtk_imhtml_get_type (void)
+{
+	static GtkType imhtml_type = 0;
+
+	if (!imhtml_type) {
+		static const GtkTypeInfo imhtml_info = {
+			"GtkIMHtml",
+			sizeof (GtkIMHtml),
+			sizeof (GtkIMHtmlClass),
+			(GtkClassInitFunc) gtk_imhtml_class_init,
+			(GtkObjectInitFunc) gtk_imhtml_init,
+			NULL,
+			NULL,
+			NULL
+		};
+
+		imhtml_type = gtk_type_unique (GTK_TYPE_LAYOUT, &imhtml_info);
+	}
+
+	return imhtml_type;
+}
+
+void
+gtk_imhtml_init_smileys (GtkIMHtml *imhtml)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	imhtml->smiley_data = gtk_smiley_tree_new ();
+
+	gtk_imhtml_associate_smiley (imhtml, ":)", smile_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-)", smile_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, ":(", sad_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-(", sad_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, ";)", wink_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ";-)", wink_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, ":-p", tongue_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-P", tongue_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, "=-O", scream_xpm);
+	gtk_imhtml_associate_smiley (imhtml, "=-o", scream_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-*", kiss_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ">:O", yell_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ">:o", yell_xpm);
+	gtk_imhtml_associate_smiley (imhtml, "8-)", smile8_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-$", moneymouth_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-!", burp_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-[", embarrassed_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":'(", cry_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, ":-/", think_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-\\", think_xpm);
+
+	gtk_imhtml_associate_smiley (imhtml, ":-X", crossedlips_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-x", crossedlips_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-D", bigsmile_xpm);
+	gtk_imhtml_associate_smiley (imhtml, ":-d", bigsmile_xpm);
+	gtk_imhtml_associate_smiley (imhtml, "O:-)", angel_xpm);
+}
+
+GtkWidget*
+gtk_imhtml_new (GtkAdjustment *hadj,
+		GtkAdjustment *vadj)
+{
+	GtkIMHtml *imhtml = gtk_type_new (GTK_TYPE_IMHTML);
+
+	gtk_imhtml_set_adjustments (imhtml, hadj, vadj);
+
+	imhtml->im_images = NULL;
+
+	imhtml->bits = NULL;
+	imhtml->click = NULL;
+
+	imhtml->x = 0;
+	imhtml->y = TOP_BORDER;
+	imhtml->llheight = 0;
+	imhtml->llascent = 0;
+	imhtml->line = NULL;
+
+	imhtml->selected_text = g_string_new ("");
+	imhtml->scroll_timer = 0;
+
+	imhtml->img = NULL;
+
+	imhtml->smileys = TRUE;
+	imhtml->comments = FALSE;
+
+	gtk_imhtml_init_smileys (imhtml);
+
+	return GTK_WIDGET (imhtml);
+}
+
+void
+gtk_imhtml_set_adjustments (GtkIMHtml     *imhtml,
+			    GtkAdjustment *hadj,
+			    GtkAdjustment *vadj)
+{
+	gtk_layout_set_hadjustment (GTK_LAYOUT (imhtml), hadj);
+	gtk_layout_set_vadjustment (GTK_LAYOUT (imhtml), vadj);
+}
+
+void
+gtk_imhtml_set_defaults (GtkIMHtml *imhtml,
+			 GdkFont   *font,
+			 GdkColor  *fg_color,
+			 GdkColor  *bg_color)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	if (font) {
+		if (imhtml->default_font)
+			gdk_font_unref (imhtml->default_font);
+		imhtml->default_font = gdk_font_ref (font);
+	}
+
+	if (fg_color) {
+		if (imhtml->default_fg_color)
+			gdk_color_free (imhtml->default_fg_color);
+		imhtml->default_fg_color = gdk_color_copy (fg_color);
+	}
+
+	if (bg_color) {
+		if (imhtml->default_bg_color)
+			gdk_color_free (imhtml->default_bg_color);
+		imhtml->default_bg_color = gdk_color_copy (bg_color);
+		gdk_window_set_background (GTK_LAYOUT (imhtml)->bin_window, imhtml->default_bg_color);
+	}
+}
+
+void
+gtk_imhtml_set_img_handler (GtkIMHtml      *imhtml,
+			    GtkIMHtmlImage  handler)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	imhtml->img = handler;
+}
+
+void
+gtk_imhtml_associate_smiley (GtkIMHtml  *imhtml,
+			     gchar      *text,
+			     gchar     **xpm)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+	g_return_if_fail (text != NULL);
+
+	if (xpm == NULL)
+		gtk_smiley_tree_remove (imhtml->smiley_data, text);
+	else
+		gtk_smiley_tree_insert (imhtml->smiley_data, text, xpm);
+}
+
+static void
+new_line (GtkIMHtml *imhtml)
+{
+	GList *last = g_list_last (imhtml->line);
+	struct line_info *li;
+
+	if (last) {
+		li = last->data;
+		if (li->x + li->width != imhtml->xsize)
+			li->width = imhtml->xsize - li->x;
+	}
+
+	last = imhtml->line;
+	if (last) {
+		li = last->data;
+		if (li->height < MIN_HEIGHT) {
+			while (last) {
+				gint diff;
+				li = last->data;
+				diff = MIN_HEIGHT - li->height;
+				li->height = MIN_HEIGHT;
+				li->ascent += diff / 2;
+				last = g_list_next (last);
+			}
+			imhtml->llheight = MIN_HEIGHT;
+		}
+	}
+
+	g_list_free (imhtml->line);
+	imhtml->line = NULL;
+
+	imhtml->x = 0;
+	imhtml->y += imhtml->llheight;
+	imhtml->llheight = 0;
+	imhtml->llascent = 0;
+}
+
+static void
+backwards_update (GtkIMHtml    *imhtml,
+		  GtkIMHtmlBit *bit,
+		  gint          height,
+		  gint          ascent)
+{
+	gint diff;
+	GList *ls = NULL;
+	struct line_info *li;
+	struct clickable *uw;
+	struct im_image *img;
+	
+	if (height > imhtml->llheight) {
+		diff = height - imhtml->llheight;
+
+		ls = imhtml->line;
+		while (ls) {
+			li = ls->data;
+			li->height += diff;
+			if (ascent)
+				li->ascent = ascent;
+			else
+				li->ascent += diff / 2;
+			ls = g_list_next (ls);
+		}
+
+		ls = imhtml->click;
+		while (ls) {
+			uw = ls->data;
+			if (uw->y + diff > imhtml->y)
+				uw->y += diff;
+			ls = g_list_next (ls);
+		}
+
+		ls = imhtml->im_images;
+		while(ls) {
+			img = ls->data;
+			if (img->y + diff > imhtml->y)
+				img->y += diff;
+			ls = g_list_next(ls);
+		}
+
+		imhtml->llheight = height;
+		if (ascent)
+			imhtml->llascent = ascent;
+		else
+			imhtml->llascent += diff / 2;
+	}
+}
+
+static void
+add_text_renderer (GtkIMHtml    *imhtml,
+		   GtkIMHtmlBit *bit,
+		   gchar        *text)
+{
+	struct line_info *li;
+	struct clickable *uw;
+	gint width;
+
+	if (text)
+		width = gdk_string_width (bit->font, text);
+	else
+		width = 0;
+
+	li = g_new0 (struct line_info, 1);
+	li->x = imhtml->x;
+	li->y = imhtml->y;
+	li->width = width;
+	li->height = imhtml->llheight;
+	if (text)
+		li->ascent = MAX (imhtml->llascent, bit->font->ascent);
+	else
+		li->ascent = 0;
+	li->text = text;
+	li->bit = bit;
+
+	if (bit->url) {
+		uw = g_new0 (struct clickable, 1);
+		uw->x = imhtml->x;
+		uw->y = imhtml->y;
+		uw->width = width;
+		uw->height = imhtml->llheight;
+		uw->imhtml = imhtml;
+		uw->bit = bit;
+		imhtml->click = g_list_append (imhtml->click, uw);
+	}
+
+	bit->chunks = g_list_append (bit->chunks, li);
+	imhtml->line = g_list_append (imhtml->line, li);
+}
+
+static void
+add_img_renderer (GtkIMHtml    *imhtml,
+		  GtkIMHtmlBit *bit)
+{
+	struct line_info *li;
+	struct clickable *uw;
+	gint width;
+
+	gdk_window_get_size (bit->pm, &width, NULL);
+
+	li = g_new0 (struct line_info, 1);
+	li->x = imhtml->x;
+	li->y = imhtml->y;
+	li->width = width;
+	li->height = imhtml->llheight;
+	li->ascent = 0;
+	li->bit = bit;
+
+
+	if (bit->url || bit->img) {
+		uw = g_new0 (struct clickable, 1);
+		uw->x = imhtml->x;
+		uw->y = imhtml->y;
+		uw->width = width;
+		uw->height = imhtml->llheight;
+		uw->imhtml = imhtml;
+		uw->bit = bit;
+		imhtml->click = g_list_append (imhtml->click, uw);
+	}
+
+	bit->chunks = g_list_append (bit->chunks, li);
+	imhtml->line = g_list_append (imhtml->line, li);
+
+	imhtml->x += width;
+}
+
+static void
+gtk_imhtml_draw_bit (GtkIMHtml    *imhtml,
+		     GtkIMHtmlBit *bit)
+{
+	gint width, height;
+
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+	g_return_if_fail (bit != NULL);
+
+	if ( ((bit->type == TYPE_TEXT) ||
+	    ((bit->type == TYPE_SMILEY) && !imhtml->smileys) ||
+	    ((bit->type == TYPE_COMMENT) && imhtml->comments)) &&
+	     bit->text) {
+		gchar *copy = g_strdup (bit->text);
+		gint pos = 0;
+		gboolean seenspace = FALSE;
+		gchar *tmp;
+
+		height = bit->font->ascent + bit->font->descent;
+		width = gdk_string_width (bit->font, bit->text);
+
+		if ((imhtml->x != 0) && ((imhtml->x + width) > imhtml->xsize)) {
+			gint remain = imhtml->xsize - imhtml->x;
+			while (gdk_text_width (bit->font, copy, pos) < remain) {
+				if (copy [pos] == ' ')
+					seenspace = TRUE;
+				pos++;
+			}
+			if (seenspace) {
+				while (copy [pos - 1] != ' ') pos--;
+
+				tmp = g_strndup (copy, pos);
+
+				backwards_update (imhtml, bit, height, bit->font->ascent);
+				add_text_renderer (imhtml, bit, tmp);
+			} else
+				pos = 0;
+			seenspace = FALSE;
+			new_line (imhtml);
+		}
+
+		backwards_update (imhtml, bit, height, bit->font->ascent);
+
+		while (pos < strlen (bit->text)) {
+			width = gdk_string_width (bit->font, copy + pos);
+			if (imhtml->x + width > imhtml->xsize) {
+				gint newpos = 0;
+				gint remain = imhtml->xsize - imhtml->x;
+				while (gdk_text_width (bit->font, copy + pos, newpos) < remain) {
+					if (copy [pos + newpos] == ' ')
+						seenspace = TRUE;
+					newpos++;
+				}
+
+				if (seenspace)
+					while (copy [pos + newpos - 1] != ' ') newpos--;
+
+				if (newpos == 0)
+					break;
+
+				tmp = g_strndup (copy + pos, newpos);
+				pos += newpos;
+
+				backwards_update (imhtml, bit, height, bit->font->ascent);
+				add_text_renderer (imhtml, bit, tmp);
+
+				seenspace = FALSE;
+				new_line (imhtml);
+			} else {
+				tmp = g_strdup (copy + pos);
+
+				backwards_update (imhtml, bit, height, bit->font->ascent);
+				add_text_renderer (imhtml, bit, tmp);
+
+				pos = strlen (bit->text);
+
+				imhtml->x += width;
+			}
+		}
+
+		g_free (copy);
+	} else if ((bit->type == TYPE_SMILEY) || (bit->type == TYPE_IMG)) {
+#if USE_PIXBUF
+	  if (bit->img) {
+			GdkPixbuf *imagepb = bit->img->pb;
+			GdkPixbuf *tmp = NULL;
+			if (gdk_pixbuf_get_width(imagepb) > imhtml->xsize - imhtml->x)
+				new_line (imhtml);
+			
+			if (gdk_pixbuf_get_width(imagepb) > imhtml->xsize) {
+				tmp = gdk_pixbuf_scale_simple(imagepb, imhtml->xsize,
+							      gdk_pixbuf_get_height(imagepb) *
+							      imhtml->xsize/
+							      gdk_pixbuf_get_width(imagepb), 
+							      GDK_INTERP_TILES);
+				if (bit->pm)
+					gdk_pixmap_unref (bit->pm);
+				if (bit->bm)
+					gdk_bitmap_unref (bit->bm);
+				gdk_pixbuf_render_pixmap_and_mask(tmp, &(bit->pm), &(bit->bm), 100);
+				gdk_pixbuf_unref(tmp);
+			}
+			else {
+				if (bit->pm)
+					gdk_pixmap_unref (bit->pm);
+				if (bit->bm)
+					gdk_bitmap_unref (bit->bm);
+				gdk_pixbuf_render_pixmap_and_mask(imagepb, &(bit->pm), &(bit->bm), 100);
+			}
+	  }
+#endif
+		
+		gdk_window_get_size (bit->pm, &width, &height);
+
+		if ((imhtml->x != 0) && ((imhtml->x + width) > imhtml->xsize))
+			new_line (imhtml);
+		else
+			backwards_update (imhtml, bit, height, 0);
+
+		add_img_renderer (imhtml, bit);
+	} else if (bit->type == TYPE_BR) {
+		new_line (imhtml);
+		add_text_renderer (imhtml, bit, NULL);
+	} else if (bit->type == TYPE_SEP) {
+		struct line_info *li;
+		if (imhtml->llheight)
+			new_line (imhtml);
+
+		li = g_new0 (struct line_info, 1);
+		li->x = imhtml->x;
+		li->y = imhtml->y;
+		li->width = imhtml->xsize;
+		li->height = HR_HEIGHT * 2;
+		li->ascent = 0;
+		li->text = NULL;
+		li->bit = bit;
+
+		bit->chunks = g_list_append (bit->chunks, li);
+
+		imhtml->llheight = HR_HEIGHT * 2;
+		new_line (imhtml);
+		add_text_renderer (imhtml, bit, NULL);
+	}
+}
+
+void
+gtk_imhtml_show_smileys (GtkIMHtml *imhtml,
+			 gboolean   show)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	imhtml->smileys = show;
+
+	if (GTK_WIDGET_VISIBLE (GTK_WIDGET (imhtml)))
+		gtk_imhtml_redraw_all (imhtml);
+}
+
+void
+gtk_imhtml_show_comments (GtkIMHtml *imhtml,
+			  gboolean   show)
+{
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	imhtml->comments = show;
+
+	if (GTK_WIDGET_VISIBLE (GTK_WIDGET (imhtml)))
+		gtk_imhtml_redraw_all (imhtml);
+}
+
+static GdkColor *
+gtk_imhtml_get_color (const gchar *color)
+{
+	GdkColor c;
+
+	if (!gdk_color_parse (color, &c))
+		return NULL;
+
+	return gdk_color_copy (&c);
+}
+
+static gboolean
+gtk_imhtml_is_smiley (GtkIMHtml   *imhtml,
+		      const gchar *text,
+		      gint        *len)
+{
+	*len = gtk_smiley_tree_lookup (imhtml->smiley_data, text);
+	return (*len > 0);
+}
+
+static GtkIMHtmlBit *
+gtk_imhtml_new_bit (GtkIMHtml  *imhtml,
+		    gint        type,
+		    gchar      *text,
+		    gint        bold,
+		    gint        italics,
+		    gint        underline,
+		    gint        strike,
+		    FontDetail *font,
+		    GdkColor   *bg,
+		    gchar      *url,
+		    gint        pre,
+		    gint        sub,
+		    gint        sup)
+{
+	GtkIMHtmlBit *bit = NULL;
+
+	g_return_val_if_fail (imhtml != NULL, NULL);
+	g_return_val_if_fail (GTK_IS_IMHTML (imhtml), NULL);
+
+	if ((type == TYPE_TEXT) && ((text == NULL) || (strlen (text) == 0)))
+		return NULL;
+
+	bit = g_new0 (GtkIMHtmlBit, 1);
+	bit->type = type;
+
+	if ((text != NULL) && (strlen (text) != 0))
+		bit->text = g_strdup (text);
+
+	if ((font != NULL) || bold || italics || pre) {
+		if (font && (bold || italics || font->size || font->face || pre)) {
+			if (pre) {
+				bit->font = gtk_imhtml_font_load (imhtml, DEFAULT_PRE_FACE, bold, italics, font->size);
+			} else {
+				bit->font = gtk_imhtml_font_load (imhtml, font->face, bold, italics, font->size);
+			}
+		} else if (bold || italics || pre) {
+			if (pre) {
+				bit->font = gtk_imhtml_font_load (imhtml, DEFAULT_PRE_FACE, bold, italics, 0);
+			} else {
+				bit->font = gtk_imhtml_font_load (imhtml, NULL, bold, italics, 0);
+			}
+		}
+
+		if (font && (type != TYPE_BR)) {
+			if (font->fore != NULL)
+				bit->fore = gdk_color_copy (font->fore);
+
+			if (font->back != NULL)
+				bit->back = gdk_color_copy (font->back);
+		}
+	}
+
+	if (((bit->type == TYPE_TEXT) || (bit->type == TYPE_SMILEY) || (bit->type == TYPE_COMMENT)) &&
+	    (bit->font == NULL))
+		bit->font = gdk_font_ref (imhtml->default_font);
+
+	if (bg != NULL)
+		bit->bg = gdk_color_copy (bg);
+
+	bit->underline = underline;
+	bit->strike = strike;
+
+	if (url != NULL)
+		bit->url = g_strdup (url);
+
+	if (type == TYPE_SMILEY) {
+		GdkColor *clr;
+
+		if ((font != NULL) && (font->back != NULL))
+			clr = font->back;
+		else
+			clr = (bg != NULL) ? bg : imhtml->default_bg_color;
+
+		bit->pm = gdk_pixmap_create_from_xpm_d (GTK_WIDGET (imhtml)->window,
+							&bit->bm,
+							clr,
+							gtk_smiley_tree_image (imhtml->smiley_data, text));
+	}
+
+	return bit;
+}
+
+#define NEW_TEXT_BIT    gtk_imhtml_new_bit (imhtml, TYPE_TEXT, ws, bold, italics, underline, strike, \
+				fonts ? fonts->data : NULL, bg, url, pre, sub, sup)
+#define NEW_SMILEY_BIT  gtk_imhtml_new_bit (imhtml, TYPE_SMILEY, ws, bold, italics, underline, strike, \
+				fonts ? fonts->data : NULL, bg, url, pre, sub, sup)
+#define NEW_SEP_BIT     gtk_imhtml_new_bit (imhtml, TYPE_SEP, NULL, 0, 0, 0, 0, NULL, bg, NULL, 0, 0, 0)
+#define NEW_BR_BIT      gtk_imhtml_new_bit (imhtml, TYPE_BR, NULL, 0, 0, 0, 0, \
+				fonts ? fonts->data : NULL, bg, NULL, 0, 0, 0)
+#define NEW_COMMENT_BIT gtk_imhtml_new_bit (imhtml, TYPE_COMMENT, ws, bold, italics, underline, strike, \
+				fonts ? fonts->data : NULL, bg, url, pre, sub, sup)
+
+#define NEW_BIT(bit)	ws [wpos] = '\0';				\
+			{ GtkIMHtmlBit *tmp = bit; if (tmp != NULL)	\
+			  newbits = g_list_append (newbits, tmp); }	\
+			wpos = 0; ws [wpos] = '\0'
+
+#define UPDATE_BG_COLORS \
+	{ \
+		GdkColormap *cmap; \
+		GList *rev; \
+		cmap = gtk_widget_get_colormap (GTK_WIDGET (imhtml)); \
+		rev = g_list_last (newbits); \
+		while (rev) { \
+			GtkIMHtmlBit *bit = rev->data; \
+			if (bit->bg) \
+				gdk_color_free (bit->bg); \
+			bit->bg = gdk_color_copy (bg); \
+			if (bit->type == TYPE_BR) \
+				break; \
+			rev = g_list_previous (rev); \
+		} \
+		if (!rev) { \
+			rev = g_list_last (imhtml->bits); \
+			while (rev) { \
+				GtkIMHtmlBit *bit = rev->data; \
+				if (bit->bg) \
+					gdk_color_free (bit->bg); \
+				bit->bg = gdk_color_copy (bg); \
+				gdk_color_alloc (cmap, bit->bg); \
+				if (bit->type == TYPE_BR) \
+					break; \
+				rev = g_list_previous (rev); \
+			} \
+		} \
+	}
+
+static gboolean
+gtk_imhtml_is_amp_escape (const gchar *string,
+			  gchar       *replace,
+			  gint        *length)
+{
+	g_return_val_if_fail (string != NULL, FALSE);
+	g_return_val_if_fail (replace != NULL, FALSE);
+	g_return_val_if_fail (length != NULL, FALSE);
+
+	if (!g_strncasecmp (string, "&amp;", 5)) {
+		*replace = '&';
+		*length = 5;
+	} else if (!g_strncasecmp (string, "&lt;", 4)) {
+		*replace = '<';
+		*length = 4;
+	} else if (!g_strncasecmp (string, "&gt;", 4)) {
+		*replace = '>';
+		*length = 4;
+	} else if (!g_strncasecmp (string, "&nbsp;", 6)) {
+		*replace = ' ';
+		*length = 6;
+	} else if (!g_strncasecmp (string, "&copy;", 6)) {
+		*replace = '';
+		*length = 6;
+	} else if (!g_strncasecmp (string, "&quot;", 6)) {
+		*replace = '\"';
+		*length = 6;
+	} else if (!g_strncasecmp (string, "&reg;", 5)) {
+		*replace = '';
+		*length = 5;
+	} else if (*(string + 1) == '#') {
+		guint pound = 0;
+		if ((sscanf (string, "&#%u;", &pound) == 1) && pound != 0) {
+			if (*(string + 3 + (gint)log10 (pound)) != ';')
+				return FALSE;
+			*replace = (gchar)pound;
+			*length = 2;
+			while (isdigit ((gint) string [*length])) (*length)++;
+			if (string [*length] == ';') (*length)++;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+#define VALID_TAG(x)	if (!g_strncasecmp (string, x ">", strlen (x ">"))) {	\
+				*tag = g_strndup (string, strlen (x));		\
+				*len = strlen (x) + 1;				\
+				return TRUE;					\
+			}							\
+			(*type)++
+
+#define VALID_OPT_TAG(x)	if (!g_strncasecmp (string, x " ", strlen (x " "))) {	\
+					const gchar *c = string + strlen (x " ");	\
+					gchar e = '"';					\
+					gboolean quote = FALSE;				\
+					while (*c) {					\
+						if (*c == '"' || *c == '\'') {		\
+							if (quote && (*c == e))		\
+								quote = !quote;		\
+							else if (!quote) {		\
+								quote = !quote;		\
+								e = *c;			\
+							}				\
+						} else if (!quote && (*c == '>'))	\
+							break;				\
+						c++;					\
+					}						\
+					if (*c) {					\
+						*tag = g_strndup (string, c - string);	\
+						*len = c - string + 1;			\
+						return TRUE;				\
+					}						\
+				}							\
+				(*type)++
+
+static gboolean
+gtk_imhtml_is_tag (const gchar *string,
+		   gchar      **tag,
+		   gint        *len,
+		   gint        *type)
+{
+	*type = 1;
+
+	if (!strchr (string, '>'))
+		return FALSE;
+
+	VALID_TAG ("B");
+	VALID_TAG ("BOLD");
+	VALID_TAG ("/B");
+	VALID_TAG ("/BOLD");
+	VALID_TAG ("I");
+	VALID_TAG ("ITALIC");
+	VALID_TAG ("/I");
+	VALID_TAG ("/ITALIC");
+	VALID_TAG ("U");
+	VALID_TAG ("UNDERLINE");
+	VALID_TAG ("/U");
+	VALID_TAG ("/UNDERLINE");
+	VALID_TAG ("S");
+	VALID_TAG ("STRIKE");
+	VALID_TAG ("/S");
+	VALID_TAG ("/STRIKE");
+	VALID_TAG ("SUB");
+	VALID_TAG ("/SUB");
+	VALID_TAG ("SUP");
+	VALID_TAG ("/SUP");
+	VALID_TAG ("PRE");
+	VALID_TAG ("/PRE");
+	VALID_TAG ("TITLE");
+	VALID_TAG ("/TITLE");
+	VALID_TAG ("BR");
+	VALID_TAG ("HR");
+	VALID_TAG ("/FONT");
+	VALID_TAG ("/A");
+	VALID_TAG ("P");
+	VALID_TAG ("/P");
+	VALID_TAG ("H3");
+	VALID_TAG ("/H3");
+	VALID_TAG ("HTML");
+	VALID_TAG ("/HTML");
+	VALID_TAG ("BODY");
+	VALID_TAG ("/BODY");
+	VALID_TAG ("FONT");
+	VALID_TAG ("HEAD");
+	VALID_TAG ("/HEAD");
+	VALID_TAG ("BINARY");
+	VALID_TAG ("/BINARY");
+	
+	VALID_OPT_TAG ("HR");
+	VALID_OPT_TAG ("FONT");
+	VALID_OPT_TAG ("BODY");
+	VALID_OPT_TAG ("A");
+	VALID_OPT_TAG ("IMG");
+	VALID_OPT_TAG ("P");
+	VALID_OPT_TAG ("H3");
+
+	if (!g_strncasecmp(string, "!--", strlen ("!--"))) {
+		gchar *e = strstr (string + strlen("!--"), "-->");
+		if (e) {
+			*len = e - string + strlen ("-->");
+			*tag = g_strndup (string + strlen ("!--"), *len - strlen ("!---->"));
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static gchar*
+gtk_imhtml_get_html_opt (gchar       *tag,
+			 const gchar *opt)
+{
+	gchar *t = tag;
+	gchar *e, *a;
+
+	while (g_strncasecmp (t, opt, strlen (opt))) {
+		gboolean quote = FALSE;
+		if (*t == '\0') break;
+		while (*t && !((*t == ' ') && !quote)) {
+			if (*t == '\"')
+				quote = ! quote;
+			t++;
+		}
+		while (*t && (*t == ' ')) t++;
+	}
+
+	if (!g_strncasecmp (t, opt, strlen (opt))) {
+		t += strlen (opt);
+	} else {
+		return NULL;
+	}
+
+	if ((*t == '\"') || (*t == '\'')) {
+		e = a = ++t;
+		while (*e && (*e != *(t - 1))) e++;
+		if  (*e == '\0') {
+			return NULL;
+		} else 
+			return g_strndup (a, e - a);
+	} else {
+		e = a = t;
+		while (*e && !isspace ((gint) *e)) e++;
+		return g_strndup (a, e - a);
+	}
+}
+
+GString*
+gtk_imhtml_append_text (GtkIMHtml        *imhtml,
+			const gchar      *text,
+			gint              len,
+			GtkIMHtmlOptions  options)
+{
+	const gchar *c;
+	gboolean binary = TRUE;
+	gchar *ws;
+	gint pos = 0;
+	gint wpos = 0;
+
+	gchar *tag;
+	gint tlen;
+	gint type;
+
+	gchar amp;
+
+	gint smilelen;
+
+	GList *newbits = NULL;
+
+	guint	bold = 0,
+		italics = 0,
+		underline = 0,
+		strike = 0,
+		sub = 0,
+		sup = 0,
+		title = 0,
+		pre = 0;
+	GSList *fonts = NULL;
+	GdkColor *bg = NULL;
+	gchar *url = NULL;
+
+	GtkAdjustment *vadj;
+	gboolean scrolldown = TRUE;
+
+	GString *retval = NULL;
+
+	g_return_val_if_fail (imhtml != NULL, NULL);
+	g_return_val_if_fail (GTK_IS_IMHTML (imhtml), NULL);
+	g_return_val_if_fail (text != NULL, NULL);
+
+	if (options & GTK_IMHTML_RETURN_LOG)
+		retval = g_string_new ("");
+
+	vadj = GTK_LAYOUT (imhtml)->vadjustment;
+	if ((vadj->value < imhtml->y - GTK_WIDGET (imhtml)->allocation.height) &&
+	    (vadj->upper >= GTK_WIDGET (imhtml)->allocation.height))
+		scrolldown = FALSE;
+
+	c = text;
+	if (len == -1) {
+		binary = FALSE;
+		len = strlen (text);
+	}
+
+	ws = g_malloc (len + 1);
+	ws [0] = '\0';
+
+	while (pos < len) {
+		if (*c == '<' && gtk_imhtml_is_tag (c + 1, &tag, &tlen, &type)) {
+			c++;
+			pos++;
+			switch (type) {
+			case 1:		/* B */
+			case 2:		/* BOLD */
+				NEW_BIT (NEW_TEXT_BIT);
+				bold++;
+				break;
+			case 3:		/* /B */
+			case 4:		/* /BOLD */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (bold)
+					bold--;
+				break;
+			case 5:		/* I */
+			case 6:		/* ITALIC */
+				NEW_BIT (NEW_TEXT_BIT);
+				italics++;
+				break;
+			case 7:		/* /I */
+			case 8:		/* /ITALIC */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (italics)
+					italics--;
+				break;
+			case 9:		/* U */
+			case 10:	/* UNDERLINE */
+				NEW_BIT (NEW_TEXT_BIT);
+				underline++;
+				break;
+			case 11:	/* /U */
+			case 12:	/* /UNDERLINE */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (underline)
+					underline--;
+				break;
+			case 13:	/* S */
+			case 14:	/* STRIKE */
+				NEW_BIT (NEW_TEXT_BIT);
+				strike++;
+				break;
+			case 15:	/* /S */
+			case 16:	/* /STRIKE */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (strike)
+					strike--;
+				break;
+			case 17:	/* SUB */
+				NEW_BIT (NEW_TEXT_BIT);
+				sub++;
+				break;
+			case 18:	/* /SUB */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (sub)
+					sub--;
+				break;
+			case 19:	/* SUP */
+				NEW_BIT (NEW_TEXT_BIT);
+				sup++;
+				break;
+			case 20:	/* /SUP */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (sup)
+					sup--;
+				break;
+			case 21:	/* PRE */
+				NEW_BIT (NEW_TEXT_BIT);
+				pre++;
+				break;
+			case 22:	/* /PRE */
+				NEW_BIT (NEW_TEXT_BIT);
+				if (pre)
+					pre--;
+				break;
+			case 23:	/* TITLE */
+				NEW_BIT (NEW_TEXT_BIT);
+				title++;
+				break;
+			case 24:	/* /TITLE */
+				if (title) {
+					if (options & GTK_IMHTML_NO_TITLE) {
+						wpos = 0;
+						ws [wpos] = '\0';
+					}
+					title--;
+				}
+				break;
+			case 25:	/* BR */
+				NEW_BIT (NEW_TEXT_BIT);
+				NEW_BIT (NEW_BR_BIT);
+				break;
+			case 26:	/* HR */
+				NEW_BIT (NEW_TEXT_BIT);
+				NEW_BIT (NEW_SEP_BIT);
+				break;
+			case 27:	/* /FONT */
+				if (fonts) {
+					FontDetail *font = fonts->data;
+					NEW_BIT (NEW_TEXT_BIT);
+					fonts = g_slist_remove (fonts, font);
+					if (font->face)
+						g_free (font->face);
+					if (font->fore)
+						gdk_color_free (font->fore);
+					if (font->back)
+						gdk_color_free (font->back);
+					g_free (font);
+				}
+				break;
+			case 28:	/* /A */
+				if (url) {
+					NEW_BIT (NEW_TEXT_BIT);
+					g_free (url);
+					url = NULL;
+				}
+				break;
+			case 29:	/* P */
+			case 30:	/* /P */
+			case 31:	/* H3 */
+			case 32:	/* /H3 */
+			case 33:	/* HTML */
+			case 34:	/* /HTML */
+			case 35:	/* BODY */
+			case 36:	/* /BODY */
+			case 37:	/* FONT */
+			case 38:	/* HEAD */
+			case 39:	/* /HEAD */
+				break;
+			case 40:        /* BINARY */
+				
+				NEW_BIT (NEW_TEXT_BIT);
+				while (pos < len) {
+					if (!g_strncasecmp("</BINARY>", c, strlen("</BINARY>"))) 
+						break;
+					else {
+						c++;
+						pos++;
+					}
+				}
+				c = c - tlen; /* Because it will add this later */
+				break;
+			case 41:        /* /BINARY */
+				break;
+				
+			case 42:	/* HR (opt) */
+				NEW_BIT (NEW_TEXT_BIT);
+				NEW_BIT (NEW_SEP_BIT);
+				break;
+			case 43:	/* FONT (opt) */
+			{
+				gchar *color, *back, *face, *size;
+				FontDetail *font;
+
+				color = gtk_imhtml_get_html_opt (tag, "COLOR=");
+				back = gtk_imhtml_get_html_opt (tag, "BACK=");
+				face = gtk_imhtml_get_html_opt (tag, "FACE=");
+				size = gtk_imhtml_get_html_opt (tag, "SIZE=");
+
+				if (!(color || back || face || size))
+					break;
+
+				NEW_BIT (NEW_TEXT_BIT);
+
+				font = g_new0 (FontDetail, 1);
+				if (color && !(options & GTK_IMHTML_NO_COLOURS))
+					font->fore = gtk_imhtml_get_color (color);
+				if (back && !(options & GTK_IMHTML_NO_COLOURS))
+					font->back = gtk_imhtml_get_color (back);
+				if (face && !(options & GTK_IMHTML_NO_FONTS))
+					font->face = g_strdup (face);
+				if (size && !(options & GTK_IMHTML_NO_SIZES)) {
+					if (*size == '+') {
+						sscanf (size + 1, "%hd", &font->size);
+						font->size += 3;
+					} else if (*size == '-') {
+						sscanf (size + 1, "%hd", &font->size);
+						font->size = MAX (0, 3 - font->size);
+					} else if (isdigit (*size)) {
+						sscanf (size, "%hd", &font->size);
+					}
+				}
+
+				g_free (color);
+				g_free (back);
+				g_free (face);
+				g_free (size);
+
+				if (fonts) {
+					FontDetail *oldfont = fonts->data;
+					if (!font->size)
+						font->size = oldfont->size;
+					if (!font->face && oldfont->face) 
+						font->face = g_strdup (oldfont->face);
+					if (!font->fore && oldfont->fore)
+						font->fore = gdk_color_copy (oldfont->fore);
+					if (!font->back && oldfont->back)
+						font->back = gdk_color_copy (oldfont->back);
+				}
+
+				fonts = g_slist_prepend (fonts, font);
+			}
+				break;
+			case 44:	/* BODY (opt) */
+				if (!(options & GTK_IMHTML_NO_COLOURS)) {
+					gchar *bgcolor = gtk_imhtml_get_html_opt (tag, "BGCOLOR=");
+					if (bgcolor) {
+						GdkColor *tmp = gtk_imhtml_get_color (bgcolor);
+						g_free (bgcolor);
+						if (tmp) {
+							NEW_BIT (NEW_TEXT_BIT);
+							bg = tmp;
+							UPDATE_BG_COLORS;
+						}
+					}
+				}
+				break;
+			case 45:	/* A (opt) */
+			{
+				gchar *href = gtk_imhtml_get_html_opt (tag, "HREF=");
+				if (href) {
+					NEW_BIT (NEW_TEXT_BIT);
+					g_free (url);
+					url = href;
+				}
+			}
+				break;
+			case 46:	/* IMG (opt) */
+				{
+				gchar *src = gtk_imhtml_get_html_opt (tag, "SRC=");
+				gchar *id = gtk_imhtml_get_html_opt (tag, "ID=");
+				gchar *datasize = gtk_imhtml_get_html_opt (tag, "DATASIZE=");
+				gchar **xpm;
+				GdkColor *clr;
+				GtkIMHtmlBit *bit;
+
+				if (!src)
+					break;
+				
+				if (!imhtml->img && id && datasize) { /* This is an embedded IM image */
+					char *tmp, *imagedata, *e;
+					const gchar *alltext;
+					struct im_image *img;
+#if USE_PIXBUF
+					GdkPixbufLoader *load;
+					GdkPixbuf *imagepb = NULL;
+#endif
+					NEW_BIT (NEW_TEXT_BIT);
+					if (!id || !datasize)
+						break;
+					tmp = g_malloc(strlen("<DATA ID=\"\" SIZE=\"\">") + 
+						       strlen(id) + strlen(datasize));
+					g_snprintf(tmp, strlen("<DATA ID=\"\" SIZE=\"\">") + 
+						   strlen(id) + strlen(datasize) + 1, 
+						   "<DATA ID=\"%s\" SIZE=\"%s\">", id, datasize);
+					alltext = c;
+					while (g_strncasecmp(alltext, tmp, strlen(tmp)) && alltext < (c + len))
+						alltext++;
+					alltext = alltext + strlen("<DATA ID=\"\" SIZE=\"\">") + strlen(id) + strlen(datasize);
+					g_free(tmp);
+					if (atoi(datasize) > len - pos)
+						break;
+					imagedata = g_malloc(atoi(datasize));
+					memcpy(imagedata, alltext, atoi(datasize));
+					
+					if (!GTK_WIDGET_REALIZED (imhtml))
+						gtk_widget_realize (GTK_WIDGET (imhtml));
+					
+					img = g_new0 (struct im_image, 1);
+					tmp = e = src;
+					while (*tmp){
+						if (*tmp == '/' || *tmp == '\\') {
+							tmp++;
+							src = tmp;
+						} else
+							tmp++;
+					}
+					
+					*tmp = '\0';
+					
+					img->filename = g_strdup(src);
+					img->len = atoi(datasize);
+					if (img->len) {
+						img->data = g_malloc(img->len);
+						memcpy(img->data, imagedata, img->len);
+#if USE_PIXBUF
+						load = gdk_pixbuf_loader_new();
+						if (!gdk_pixbuf_loader_write(load, imagedata, img->len))
+							g_print("IM Image corrupt or unreadable.\n");
+						else 
+							imagepb = gdk_pixbuf_loader_get_pixbuf(load);
+						img->pb = imagepb;
+#endif
+					}
+#if USE_PIXBUF
+					if (imagepb) {
+						bit = g_new0 (GtkIMHtmlBit, 1);
+						bit->type = TYPE_IMG;
+						bit->img = img;
+						if (url)
+							bit->url = g_strdup (url);
+						
+						NEW_BIT (bit);
+					} else {
+						g_free(img->filename);
+						g_free(img->data);
+					}
+#else
+					bit = g_new0 (GtkIMHtmlBit, 1);
+						bit->type = TYPE_IMG;
+						bit->img = img;
+						if (url)
+							bit->url = g_strdup (url);
+						if (!fonts || ((clr = ((FontDetail *) fonts->data)->back) == NULL))
+							clr = (bg != NULL) ? bg : imhtml->default_bg_color;
+						
+						bit->pm = gdk_pixmap_create_from_xpm_d (GTK_WIDGET (imhtml)->window,
+											&bit->bm, clr, broken_xpm);
+						NEW_BIT (bit);
+#endif
+					g_free(imagedata);
+					g_free(e);
+					g_free(id);
+					g_free(datasize);
+
+					break;
+				}
+				
+				if (!imhtml->img || ((xpm = imhtml->img (src)) == NULL)) {
+					g_free (src);
+					break;
+				}
+
+				if (!fonts || ((clr = ((FontDetail *) fonts->data)->back) == NULL))
+					clr = (bg != NULL) ? bg : imhtml->default_bg_color;
+
+				if (!GTK_WIDGET_REALIZED (imhtml))
+					gtk_widget_realize (GTK_WIDGET (imhtml));
+
+				bit = g_new0 (GtkIMHtmlBit, 1);
+				bit->type = TYPE_IMG;
+				bit->pm = gdk_pixmap_create_from_xpm_d (GTK_WIDGET (imhtml)->window,
+									&bit->bm, clr, xpm);
+				if (url)
+					bit->url = g_strdup (url);
+
+				NEW_BIT (bit);
+
+				g_free (src);
+			}
+				break;
+			case 47:	/* P (opt) */
+			case 48:	/* H3 (opt) */
+				break;
+			case 49:	/* comment */
+				NEW_BIT (NEW_TEXT_BIT);
+				wpos = g_snprintf (ws, len, "%s", tag);
+				NEW_BIT (NEW_COMMENT_BIT);
+				break;
+			default:
+				break;
+			}
+			g_free (tag);
+			c += tlen;
+			pos += tlen;
+		} else if (*c == '&' && gtk_imhtml_is_amp_escape (c, &amp, &tlen)) {
+			ws [wpos++] = amp;
+			c += tlen;
+			pos += tlen;
+		} else if (*c == '\n') {
+			if (!(options & GTK_IMHTML_NO_NEWLINE)) {
+				NEW_BIT (NEW_TEXT_BIT);
+				NEW_BIT (NEW_BR_BIT);
+			}
+			c++;
+			pos++;
+		} else if (gtk_imhtml_is_smiley (imhtml, c, &smilelen)) {
+			NEW_BIT (NEW_TEXT_BIT);
+			wpos = g_snprintf (ws, smilelen + 1, "%s", c);
+			NEW_BIT (NEW_SMILEY_BIT);
+			c += smilelen;
+			pos += smilelen;
+		} else if (*c) {
+			ws [wpos++] = *c++;
+			pos++;
+		} else {
+			break;
+		}
+	}
+
+	NEW_BIT (NEW_TEXT_BIT);
+
+	while (newbits) {
+		GtkIMHtmlBit *bit = newbits->data;
+		imhtml->bits = g_list_append (imhtml->bits, bit);
+		newbits = g_list_remove (newbits, bit);
+		gtk_imhtml_draw_bit (imhtml, bit);
+	}
+
+	GTK_LAYOUT (imhtml)->height = imhtml->y;
+	GTK_LAYOUT (imhtml)->vadjustment->upper = imhtml->y;
+	gtk_signal_emit_by_name (GTK_OBJECT (GTK_LAYOUT (imhtml)->vadjustment), "changed");
+
+	gtk_widget_set_usize (GTK_WIDGET (imhtml), -1, imhtml->y);
+
+#if GTK_CHECK_VERSION(1,3,0)
+	if (!(options & GTK_IMHTML_NO_SCROLL) &&
+	    scrolldown &&
+	    (imhtml->y >= MAX (1,
+			       (GTK_WIDGET (imhtml)->allocation.height -
+				(GTK_WIDGET (imhtml)->style->ythickness + BORDER_SIZE) * 2))))
+		gtk_adjustment_set_value (vadj, imhtml->y -
+					  MAX (1, (GTK_WIDGET (imhtml)->allocation.height - 
+						   (GTK_WIDGET (imhtml)->style->ythickness +
+						    BORDER_SIZE) * 2)));
+#else
+	if (!(options & GTK_IMHTML_NO_SCROLL) &&
+	    scrolldown &&
+	    (imhtml->y >= MAX (1,
+			       (GTK_WIDGET (imhtml)->allocation.height -
+				(GTK_WIDGET (imhtml)->style->klass->ythickness + BORDER_SIZE) * 2))))
+		gtk_adjustment_set_value (vadj, imhtml->y -
+					  MAX (1, (GTK_WIDGET (imhtml)->allocation.height - 
+						   (GTK_WIDGET (imhtml)->style->klass->ythickness +
+						    BORDER_SIZE) * 2)));
+#endif
+
+	if (url) {
+		g_free (url);
+		if (retval)
+			retval = g_string_append (retval, "</A>");
+	}
+	if (bg)
+		gdk_color_free (bg);
+	while (fonts) {
+		FontDetail *font = fonts->data;
+		fonts = g_slist_remove (fonts, font);
+		if (font->face)
+			g_free (font->face);
+		if (font->fore)
+			gdk_color_free (font->fore);
+		if (font->back)
+			gdk_color_free (font->back);
+		g_free (font);
+		if (retval)
+			retval = g_string_append (retval, "</FONT>");
+	}
+	if (retval) {
+		while (bold) {
+			retval = g_string_append (retval, "</B>");
+			bold--;
+		}
+		while (italics) {
+			retval = g_string_append (retval, "</I>");
+			italics--;
+		}
+		while (underline) {
+			retval = g_string_append (retval, "</U>");
+			underline--;
+		}
+		while (strike) {
+			retval = g_string_append (retval, "</S>");
+			strike--;
+		}
+		while (sub) {
+			retval = g_string_append (retval, "</SUB>");
+			sub--;
+		}
+		while (sup) {
+			retval = g_string_append (retval, "</SUP>");
+			sup--;
+		}
+		while (title) {
+			retval = g_string_append (retval, "</TITLE>");
+			title--;
+		}
+		while (pre) {
+			retval = g_string_append (retval, "</PRE>");
+			pre--;
+		}
+	}
+	g_free (ws);
+
+	return retval;
+}
+
+void
+gtk_imhtml_clear (GtkIMHtml *imhtml)
+{
+	GtkLayout *layout;
+
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	layout = GTK_LAYOUT (imhtml);
+
+	while (imhtml->bits) {
+		GtkIMHtmlBit *bit = imhtml->bits->data;
+		imhtml->bits = g_list_remove (imhtml->bits, bit);
+		if (bit->text)
+			g_free (bit->text);
+		if (bit->font)
+			gdk_font_unref (bit->font);
+		if (bit->fore)
+			gdk_color_free (bit->fore);
+		if (bit->back)
+			gdk_color_free (bit->back);
+		if (bit->bg)
+			gdk_color_free (bit->bg);
+		if (bit->url)
+			g_free (bit->url);
+		if (bit->pm)
+			gdk_pixmap_unref (bit->pm);
+		if (bit->bm)
+			gdk_bitmap_unref (bit->bm);
+#if USE_PIXBUF
+		if (bit->img) {
+			g_free(bit->img->filename);
+			g_free(bit->img->data);
+			gdk_pixbuf_unref(bit->img->pb);
+			g_free(bit->img);
+		}
+#endif 
+		
+		while (bit->chunks) {
+			struct line_info *li = bit->chunks->data;
+			if (li->text)
+				g_free (li->text);
+			bit->chunks = g_list_remove (bit->chunks, li);
+			g_free (li);
+		}
+		g_free (bit);
+	}
+
+	while (imhtml->click) {
+		g_free (imhtml->click->data);
+		imhtml->click = g_list_remove (imhtml->click, imhtml->click->data);
+	}
+	
+#if USE_PIXBUF
+	while (imhtml->im_images) {
+		imhtml->im_images = g_list_remove(imhtml->im_images, imhtml->im_images->data);
+	}
+#endif
+	
+	if (imhtml->selected_text) {
+		g_string_free (imhtml->selected_text, TRUE);
+		imhtml->selected_text = g_string_new ("");
+	}
+
+	imhtml->sel_startx = 0;
+	imhtml->sel_starty = 0;
+	imhtml->sel_endx = 0;
+	imhtml->sel_endx = 0;
+	imhtml->sel_endchunk = NULL;
+
+	if (imhtml->tip_timer) {
+		gtk_timeout_remove (imhtml->tip_timer);
+		imhtml->tip_timer = 0;
+	}
+	if (imhtml->tip_window) {
+		gtk_widget_destroy (imhtml->tip_window);
+		imhtml->tip_window = NULL;
+	}
+	imhtml->tip_bit = NULL;
+
+	if (imhtml->scroll_timer) {
+		gtk_timeout_remove (imhtml->scroll_timer);
+		imhtml->scroll_timer = 0;
+	}
+
+#if USE_PIXBUF
+	g_list_free(imhtml->im_images);
+	imhtml->im_images = NULL;
+#endif
+
+	imhtml->x = 0;
+	imhtml->y = TOP_BORDER;
+	imhtml->xsize = 0;
+	imhtml->llheight = 0;
+	imhtml->llascent = 0;
+	if (imhtml->line)
+		g_list_free (imhtml->line);
+	imhtml->line = NULL;
+
+	layout->hadjustment->page_size = 0;
+	layout->hadjustment->page_increment = 0;
+	layout->hadjustment->lower = 0;
+	layout->hadjustment->upper = imhtml->x;
+	gtk_adjustment_set_value (layout->hadjustment, 0);
+
+	layout->vadjustment->page_size = 0;
+	layout->vadjustment->page_increment = 0;
+	layout->vadjustment->lower = 0;
+	layout->vadjustment->upper = imhtml->y;
+	gtk_adjustment_set_value (layout->vadjustment, 0);
+
+	if (GTK_WIDGET_REALIZED (GTK_WIDGET (imhtml))) {
+		gdk_window_set_cursor (GTK_LAYOUT (imhtml)->bin_window, imhtml->arrow_cursor);
+		gdk_window_clear (GTK_LAYOUT (imhtml)->bin_window);
+		gtk_signal_emit_by_name (GTK_OBJECT (layout->hadjustment), "changed");
+		gtk_signal_emit_by_name (GTK_OBJECT (layout->vadjustment), "changed");
+	}
+}
+
+void
+gtk_imhtml_page_up (GtkIMHtml *imhtml)
+{
+	GtkAdjustment *vadj;
+
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	vadj = GTK_LAYOUT (imhtml)->vadjustment;
+	gtk_adjustment_set_value (vadj, MAX (vadj->value - vadj->page_increment,
+					     vadj->lower));
+	gtk_signal_emit_by_name (GTK_OBJECT (vadj), "changed");
+}
+
+void
+gtk_imhtml_page_down (GtkIMHtml *imhtml)
+{
+	GtkAdjustment *vadj;
+
+	g_return_if_fail (imhtml != NULL);
+	g_return_if_fail (GTK_IS_IMHTML (imhtml));
+
+	vadj = GTK_LAYOUT (imhtml)->vadjustment;
+	gtk_adjustment_set_value (vadj, MIN (vadj->value + vadj->page_increment,
+					     vadj->upper - vadj->page_size));
+	gtk_signal_emit_by_name (GTK_OBJECT (vadj), "changed");
+}
diff -Nru gaim-0.58/src/gtkimhtml.h gaim-0.58-t/src/gtkimhtml.h
--- gaim-0.58/src/gtkimhtml.h	Sat Apr 20 04:10:13 2002
+++ gaim-0.58-t/src/gtkimhtml.h	Wed Jun 12 20:09:47 2002
@@ -50,10 +50,25 @@
 	GdkColor *default_bg_color;
 	GdkColor *default_hl_color;
 	GdkColor *default_hlfg_color;
+	GdkGC *bgc;
+	GdkGC *fgc;
 
 	GdkCursor *hand_cursor;
 	GdkCursor *arrow_cursor;
 
+	GdkDrawable *draw_buf;
+
+	char transparent : 1;
+	char shaded : 1;
+	char recycle : 1;
+	char skip_exposure : 1;
+
+	GdkPixmap *bg_pixmap;
+	int pixel_offset;
+
+	int last_win_x;
+	int last_win_y;
+
 	GList *bits;
 	GList *click;
 	struct _GtkIMHtmlBit *tip_bit;
@@ -114,6 +129,11 @@
 					GdkColor         *fg_color,
 					GdkColor         *bg_color);
 
+void       gtk_imhtml_set_background   (GtkIMHtml        *imhtml,
+					GdkPixmap        *pixmap,
+					int               trans,
+					int               shaded);
+
 void       gtk_imhtml_set_img_handler  (GtkIMHtml        *imhtml,
 					GtkIMHtmlImage    handler);
 
@@ -144,6 +164,9 @@
 
 void       gtk_imhtml_page_down        (GtkIMHtml        *imhtml);
 
+void       gtk_imhtml_refresh          (GtkIMHtml        *imhtml,
+					int               do_trans);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nru gaim-0.58/src/prefs.c gaim-0.58-t/src/prefs.c
--- gaim-0.58/src/prefs.c	Sat May  4 00:20:42 2002
+++ gaim-0.58-t/src/prefs.c	Wed Jun 12 20:09:47 2002
@@ -61,6 +61,8 @@
 static void delete_prefs(GtkWidget *, void *);
 void set_default_away(GtkWidget *, gpointer);
 static void set_font_option(GtkWidget *w, int option);
+static void set_trans_option(GtkWidget *w, int option);
+static void update_tint_value(GtkObject *o, gushort *value);
 
 static GtkWidget *sounddialog = NULL;
 static GtkWidget *prefdialog = NULL;
@@ -1190,7 +1192,7 @@
 	gtk_widget_show(prefdialog);
 }
 
-static GtkWidget *show_color_pref(GtkWidget *box, gboolean fgc)
+static GtkWidget *show_color_pref(GtkWidget *box, gboolean fgc, gboolean out)
 {
 	/* more stuff stolen from X-Chat */
 	GtkWidget *swid;
@@ -1198,20 +1200,28 @@
 	GtkStyle *style;
 	c.pixel = 0;
 	if (fgc) {
-		if (font_options & OPT_FONT_FGCOL) {
-			c.red = fgcolor.red << 8;
-			c.blue = fgcolor.blue << 8;
-			c.green = fgcolor.green << 8;
+		if (out && (font_options & OPT_FONT_OUT_FGCOL)) {
+			c.red = out_fgcolor.red << 8;
+			c.blue = out_fgcolor.blue << 8;
+			c.green = out_fgcolor.green << 8;
+		} else if (!out && (font_options & OPT_FONT_DEF_FGCOL)) {
+			c.red = def_fgcolor.red << 8;
+			c.blue = def_fgcolor.blue << 8;
+			c.green = def_fgcolor.green << 8;
 		} else {
 			c.red = 0;
 			c.blue = 0;
 			c.green = 0;
 		}
 	} else {
-		if (font_options & OPT_FONT_BGCOL) {
-			c.red = bgcolor.red << 8;
-			c.blue = bgcolor.blue << 8;
-			c.green = bgcolor.green << 8;
+		if (out && (font_options & OPT_FONT_OUT_BGCOL)) {
+			c.red = out_bgcolor.red << 8;
+			c.blue = out_bgcolor.blue << 8;
+			c.green = out_bgcolor.green << 8;
+		} else if (!out && (font_options & OPT_FONT_DEF_BGCOL)) {
+			c.red = def_bgcolor.red << 8;
+			c.blue = def_bgcolor.blue << 8;
+			c.green = def_bgcolor.green << 8;
 		} else {
 			c.red = 0xffff;
 			c.blue = 0xffff;
@@ -1231,29 +1241,48 @@
 	return swid;
 }
 
-GtkWidget *pref_fg_picture = NULL;
-GtkWidget *pref_bg_picture = NULL;
+GtkWidget *pref_out_fg_picture = NULL;
+GtkWidget *pref_out_bg_picture = NULL;
+GtkWidget *pref_def_fg_picture = NULL;
+GtkWidget *pref_def_bg_picture = NULL;
 
 void update_color(GtkWidget *w, GtkWidget *pic)
 {
 	GdkColor c;
 	GtkStyle *style;
 	c.pixel = 0;
-	if (pic == pref_fg_picture) {
-		if (font_options & OPT_FONT_FGCOL) {
-			c.red = fgcolor.red << 8;
-			c.blue = fgcolor.blue << 8;
-			c.green = fgcolor.green << 8;
+	if (pic == pref_out_fg_picture || pic == pref_def_fg_picture) {
+		if (pic == pref_out_fg_picture &&
+			(font_options & OPT_FONT_OUT_FGCOL)) {
+
+			c.red = out_fgcolor.red << 8;
+			c.blue = out_fgcolor.blue << 8;
+			c.green = out_fgcolor.green << 8;
+
+		} else if (pic == pref_def_fg_picture &&
+				   (font_options & OPT_FONT_DEF_FGCOL)) {
+
+			c.red = def_fgcolor.red << 8;
+			c.blue = def_fgcolor.blue << 8;
+			c.green = def_fgcolor.green << 8;
 		} else {
 			c.red = 0;
 			c.blue = 0;
 			c.green = 0;
 		}
 	} else {
-		if (font_options & OPT_FONT_BGCOL) {
-			c.red = bgcolor.red << 8;
-			c.blue = bgcolor.blue << 8;
-			c.green = bgcolor.green << 8;
+		if (pic == pref_out_bg_picture &&
+			(font_options & OPT_FONT_OUT_BGCOL)) {
+
+			c.red = out_bgcolor.red << 8;
+			c.blue = out_bgcolor.blue << 8;
+			c.green = out_bgcolor.green << 8;
+		} else if (pic == pref_def_bg_picture &&
+				   (font_options & OPT_FONT_DEF_BGCOL)) {
+
+			c.red = def_bgcolor.red << 8;
+			c.blue = def_bgcolor.blue << 8;
+			c.green = def_bgcolor.green << 8;
 		} else {
 			c.red = 0xffff;
 			c.blue = 0xffff;
@@ -1336,7 +1365,56 @@
 
 	/* ----------- */
 
-	frame = gtk_frame_new("Font Color");
+	frame = gtk_frame_new("Outgoing Font Color");
+	fbox = gtk_vbox_new(FALSE, 5);
+
+	gtk_container_add(GTK_CONTAINER(frame), fbox);
+	gtk_container_set_border_width(GTK_CONTAINER(fbox), 5);
+
+	gtk_widget_show(fbox);
+	gtk_widget_show(frame);
+
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	pref_out_fg_picture = show_color_pref(hbox, TRUE, TRUE);
+	button = gaim_button(_("Text Color"), &font_options, OPT_FONT_OUT_FGCOL, hbox);
+
+	select = picture_button(prefs, _("Select"), fgcolor_xpm);
+	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
+	if (!(font_options & OPT_FONT_OUT_FGCOL))
+		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_out_fgcolor_dialog), NULL);
+	gtk_widget_show(select);
+
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
+			   pref_out_fg_picture);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	pref_out_bg_picture = show_color_pref(hbox, FALSE, TRUE);
+	button = gaim_button(_("Background Color"), &font_options, OPT_FONT_OUT_BGCOL, hbox);
+
+	select = picture_button(prefs, _("Select"), bgcolor_xpm);
+	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
+	if (!(font_options & OPT_FONT_OUT_BGCOL))
+		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_out_bgcolor_dialog), NULL);
+	gtk_widget_show(select);
+
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
+			   pref_out_bg_picture);
+
+	/* ----------- */
+
+	frame = gtk_frame_new("Default Font Color");
 	fbox = gtk_vbox_new(FALSE, 5);
 
 	gtk_container_add(GTK_CONTAINER(frame), fbox);
@@ -1351,37 +1429,37 @@
 	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
 	gtk_widget_show(hbox);
 
-	pref_fg_picture = show_color_pref(hbox, TRUE);
-	button = gaim_button(_("Text Color"), &font_options, OPT_FONT_FGCOL, hbox);
+	pref_def_fg_picture = show_color_pref(hbox, TRUE, FALSE);
+	button = gaim_button(_("Text Color"), &font_options, OPT_FONT_DEF_FGCOL, hbox);
 
 	select = picture_button(prefs, _("Select"), fgcolor_xpm);
 	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
-	if (!(font_options & OPT_FONT_FGCOL))
+	if (!(font_options & OPT_FONT_DEF_FGCOL))
 		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
-	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_fgcolor_dialog), NULL);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_def_fgcolor_dialog), NULL);
 	gtk_widget_show(select);
 
 	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
 	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
-			   pref_fg_picture);
+			   pref_def_fg_picture);
 
 	hbox = gtk_hbox_new(FALSE, 5);
 	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
 	gtk_widget_show(hbox);
 
-	pref_bg_picture = show_color_pref(hbox, FALSE);
-	button = gaim_button(_("Background Color"), &font_options, OPT_FONT_BGCOL, hbox);
+	pref_def_bg_picture = show_color_pref(hbox, FALSE, FALSE);
+	button = gaim_button(_("Background Color"), &font_options, OPT_FONT_DEF_BGCOL, hbox);
 
 	select = picture_button(prefs, _("Select"), bgcolor_xpm);
 	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
-	if (!(font_options & OPT_FONT_BGCOL))
+	if (!(font_options & OPT_FONT_DEF_BGCOL))
 		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
-	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_bgcolor_dialog), NULL);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_def_bgcolor_dialog), NULL);
 	gtk_widget_show(select);
 
 	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
 	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
-			   pref_bg_picture);
+			   pref_def_bg_picture);
 
 	/* ----------- */
 
@@ -1430,6 +1508,124 @@
 	gtk_widget_show(prefdialog);
 }
 
+static void create_tint_slider(GtkWidget *vbox, char *text, gushort *value)
+{
+	GtkObject *adj;
+	GtkWidget *scale;
+	GtkWidget *hbox;
+	GtkWidget *lbox;
+	GtkWidget *label;
+
+	hbox = gtk_hbox_new(0, 0);
+	gtk_container_add(GTK_CONTAINER(vbox), hbox);
+	gtk_widget_show(hbox);
+
+	lbox = gtk_hbox_new(0, 0);
+	gtk_box_pack_start(GTK_BOX(hbox), lbox, 0, 0, 2);
+	gtk_widget_set_usize(lbox, 60, 0);
+	gtk_widget_show(lbox);
+
+	label = gtk_label_new(text);
+	gtk_box_pack_end(GTK_BOX(lbox), label, 0, 0, 0);
+	gtk_widget_show(label);
+
+	adj = gtk_adjustment_new(*value, 0, 255.0, 1, 25, 0);
+	gtk_signal_connect(adj, "value-changed",
+					   GTK_SIGNAL_FUNC(update_tint_value), value);
+
+	scale = gtk_hscale_new(GTK_ADJUSTMENT(adj));
+	gtk_scale_set_value_pos(GTK_SCALE(scale), GTK_POS_RIGHT);
+	gtk_scale_set_digits(GTK_SCALE(scale), 0);
+	gtk_container_add(GTK_CONTAINER(hbox), scale);
+	gtk_widget_show(scale);
+}
+
+static void trans_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *hbox;
+	GtkWidget *button;
+	GtkWidget *select;
+	GtkWidget *spin;
+	GtkObject *adjust;
+	GtkWidget *frame;
+	GtkWidget *fbox;
+	GtkWidget *table;
+	GtkWidget *scale;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Transparency"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new("Enable/Disable Transparency");
+
+	table = gtk_table_new(2, 2, FALSE);
+	gtk_container_set_border_width(GTK_CONTAINER(table), 5);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 5);
+	gtk_container_add(GTK_CONTAINER(frame), table);
+
+	button = gtk_check_button_new_with_label(_("Conversation Window"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (trans_options & OPT_TRANS_CONV));
+	gtk_table_attach(GTK_TABLE(table), button, 0, 1, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_trans_option), (int *)OPT_TRANS_CONV);
+
+	button = gtk_check_button_new_with_label(_("Chat Window"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (trans_options & OPT_TRANS_CHAT));
+	gtk_table_attach(GTK_TABLE(table), button, 0, 1, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_trans_option), (int *)OPT_TRANS_CHAT);
+
+	button = gtk_check_button_new_with_label(_("Away Message Window"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (trans_options & OPT_TRANS_AWAY));
+	gtk_table_attach(GTK_TABLE(table), button, 1, 2, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_trans_option), (int *)OPT_TRANS_AWAY);
+
+
+	gtk_widget_show_all(table);
+	gtk_widget_show(frame);
+
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+
+	/* ----------- */
+
+	frame = gtk_frame_new("Tint Settings");
+	fbox = gtk_vbox_new(FALSE, 3);
+
+	gtk_container_add(GTK_CONTAINER(frame), fbox);
+	gtk_container_set_border_width(GTK_CONTAINER(fbox), 5);
+
+	gtk_widget_show(fbox);
+	gtk_widget_show(frame);
+
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+
+	create_tint_slider(fbox, "Red:",   &trans_tint.red);
+	create_tint_slider(fbox, "Green:", &trans_tint.green);
+	create_tint_slider(fbox, "Blue:",  &trans_tint.blue);
+
+	gtk_widget_show(fbox);
+	gtk_widget_show(frame);
+
+	gtk_widget_show(prefdialog);
+}
+
+
 static GtkWidget *sndent[NUM_SOUNDS];
 static GtkWidget *sndcmd = NULL;
 static char *last_sound_dir = NULL;
@@ -2018,6 +2214,18 @@
 	gtk_widget_show(sw2);
 
 	away_text = gtk_imhtml_new(NULL, NULL);
+
+#if 0
+	if ((trans_flags & OPT_TRANS_AWAY) == OPT_TRANS_AWAY) {
+		gtk_imhtml_set_background(GTK_IMHTML(away_text), NULL, 1, 1);
+
+	}
+
+	gtk_signal_connect(GTK_OBJECT(prefs), "configure_event",
+			   GTK_SIGNAL_FUNC(win_move), away_text);
+
+#endif
+
 	gtk_container_add(GTK_CONTAINER(sw2), away_text);
 	GTK_LAYOUT(away_text)->hadjustment->step_increment = 10.0;
 	GTK_LAYOUT(away_text)->vadjustment->step_increment = 10.0;
@@ -2785,6 +2993,22 @@
 	save_prefs();
 }
 
+static void set_trans_option(GtkWidget *w, int option)
+{
+	trans_options ^= option;
+	
+	update_transparency();
+
+	save_prefs();
+}
+
+static void update_tint_value(GtkObject *o, gushort *value)
+{
+	*value = (gushort)(GTK_ADJUSTMENT(o)->value);
+	
+	update_tints();
+}
+
 static void set_away_option(GtkWidget *w, int option)
 {
 	away_options ^= option;
@@ -2920,6 +3144,11 @@
 	node = gtk_ctree_insert_node(GTK_CTREE(preftree), parent, NULL,
 				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
 	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, font_page);
+
+	text[0] = _("Transparency");
+	node = gtk_ctree_insert_node(GTK_CTREE(preftree), parent, NULL,
+				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, trans_page);
 }
 
 void prefs_build_sound()
diff -Nru gaim-0.58/src/prefs.c~ gaim-0.58-t/src/prefs.c~
--- gaim-0.58/src/prefs.c~	Wed Dec 31 19:00:00 1969
+++ gaim-0.58-t/src/prefs.c~	Sat May  4 00:20:42 2002
@@ -0,0 +1,2957 @@
+/*
+ * gaim
+ *
+ * Copyright (C) 1998-1999, Mark Spencer <markster@marko.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <string.h>
+#include <sys/time.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <gtk/gtk.h>
+#include "gtkimhtml.h"
+#include "gaim.h"
+#include "prpl.h"
+#include "pixmaps/cancel.xpm"
+#include "pixmaps/fontface2.xpm"
+#include "pixmaps/gnome_add.xpm"
+#include "pixmaps/gnome_remove.xpm"
+#include "pixmaps/gnome_preferences.xpm"
+#include "pixmaps/bgcolor.xpm"
+#include "pixmaps/fgcolor.xpm"
+#include "pixmaps/save.xpm"
+#include "proxy.h"
+
+struct debug_window *dw = NULL;
+static GtkWidget *prefs = NULL;
+
+static GtkWidget *gaim_button(const char *, guint *, int, GtkWidget *);
+static GtkWidget *blist_tab_radio(const char *, int, GtkWidget *, GtkWidget *);
+static void prefs_build_general();
+static void prefs_build_buddy();
+static void prefs_build_convo();
+static void prefs_build_sound();
+static void prefs_build_away();
+static void prefs_build_deny();
+static gint handle_delete(GtkWidget *, GdkEvent *, void *);
+static void delete_prefs(GtkWidget *, void *);
+void set_default_away(GtkWidget *, gpointer);
+static void set_font_option(GtkWidget *w, int option);
+
+static GtkWidget *sounddialog = NULL;
+static GtkWidget *prefdialog = NULL;
+static GtkWidget *tickerbutton = NULL;
+GtkWidget *debugbutton = NULL;
+
+extern GtkWidget *tickerwindow;
+extern void BuddyTickerShow();
+
+GtkWidget *prefs_away_list = NULL;
+GtkWidget *prefs_away_menu = NULL;
+GtkWidget *preftree = NULL;
+GtkCTreeNode *general_node = NULL;
+GtkCTreeNode *deny_node = NULL;
+GtkWidget *prefs_proxy_frame = NULL;
+
+static void destdeb(GtkWidget *m, gpointer n)
+{
+	gtk_widget_destroy(debugbutton);
+	debugbutton = NULL;
+}
+
+static void desttkr(GtkWidget *m, gpointer n)
+{
+	gtk_widget_destroy(tickerbutton);
+	tickerbutton = NULL;
+}
+
+static void set_idle(GtkWidget *w, int *data)
+{
+	report_idle = (int)data;
+	save_prefs();
+}
+
+static GtkWidget *idle_radio(char *label, int which, GtkWidget *box, GtkWidget *set)
+{
+	GtkWidget *opt;
+
+	if (!set)
+		opt = gtk_radio_button_new_with_label(NULL, label);
+	else
+		opt =
+		    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)),
+						    label);
+	gtk_box_pack_start(GTK_BOX(box), opt, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked", GTK_SIGNAL_FUNC(set_idle), (void *)which);
+	gtk_widget_show(opt);
+	if (report_idle == which)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+	return opt;
+}
+
+static GtkWidget *browser_entry = NULL;
+static GtkWidget *new_window = NULL;
+
+static void set_browser(GtkWidget *w, int *data)
+{
+	web_browser = (int)data;
+	if (web_browser != BROWSER_MANUAL) {
+		if (browser_entry)
+			gtk_widget_set_sensitive(browser_entry, FALSE);
+	} else {
+		if (browser_entry)
+			gtk_widget_set_sensitive(browser_entry, TRUE);
+	}
+
+	if (web_browser != BROWSER_NETSCAPE) {
+		if (new_window)
+			gtk_widget_set_sensitive(new_window, FALSE);
+	} else {
+		if (new_window)
+			gtk_widget_set_sensitive(new_window, TRUE);
+	}
+
+
+	save_prefs();
+}
+
+static int manualentry_key_pressed(GtkWidget *w, GdkEvent *event, void *dummy)
+{
+	g_snprintf(web_command, sizeof(web_command), "%s", gtk_entry_get_text(GTK_ENTRY(browser_entry)));
+	save_prefs();
+	return TRUE;
+}
+
+static GtkWidget *browser_radio(char *label, int which, GtkWidget *box, GtkWidget *set)
+{
+	GtkWidget *opt;
+
+	if (!set)
+		opt = gtk_radio_button_new_with_label(NULL, label);
+	else
+		opt =
+		    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)),
+						    label);
+	gtk_box_pack_start(GTK_BOX(box), opt, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked", GTK_SIGNAL_FUNC(set_browser), (void *)which);
+	gtk_widget_show(opt);
+	if (web_browser == which)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+	return opt;
+}
+
+static void brentdes(GtkWidget *m, gpointer n)
+{
+	browser_entry = NULL;
+	new_window = NULL;
+}
+
+static void general_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *hbox;
+	GtkWidget *vbox;
+	GtkWidget *frame;
+	GtkWidget *mbox;
+	GtkWidget *sep;
+	GtkWidget *idle;
+	GtkWidget *opt;
+	GtkWidget *typingbutton;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("General Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	frame = gtk_frame_new(_("Miscellaneous"));
+	gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 5);
+	gtk_widget_show(frame);
+
+	mbox = gtk_vbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), mbox);
+	gtk_widget_show(mbox);
+
+	gaim_button(_("Use borderless buttons"), &misc_options, OPT_MISC_COOL_LOOK, mbox);
+
+	if (!tickerwindow && (misc_options & OPT_MISC_BUDDY_TICKER))
+		misc_options ^= OPT_MISC_BUDDY_TICKER;
+	tickerbutton = gaim_button(_("Show Buddy Ticker"), &misc_options, OPT_MISC_BUDDY_TICKER, mbox);
+	gtk_signal_connect(GTK_OBJECT(tickerbutton), "destroy", GTK_SIGNAL_FUNC(desttkr), 0);
+
+	if (!dw && (misc_options & OPT_MISC_DEBUG))
+		misc_options ^= OPT_MISC_DEBUG;
+	debugbutton = gaim_button(_("Show Debug Window"), &misc_options, OPT_MISC_DEBUG, mbox);
+	gtk_signal_connect(GTK_OBJECT(debugbutton), "destroy", GTK_SIGNAL_FUNC(destdeb), 0);
+	
+	/* Preferences should be positive */
+	typingbutton = gaim_button(_("Notify buddies that you are typing to them"), &misc_options,
+				   OPT_MISC_STEALTH_TYPING, mbox);
+
+	/* So we have to toggle it */
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON(typingbutton), !gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(typingbutton)));
+	misc_options ^= OPT_MISC_STEALTH_TYPING;
+	
+	frame = gtk_frame_new(_("Report Idle Times"));
+	gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 5);
+	gtk_widget_show(frame);
+
+	mbox = gtk_vbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), mbox);
+	gtk_widget_show(mbox);
+
+	idle = idle_radio(_("None"), IDLE_NONE, mbox, NULL);
+	idle = idle_radio(_("Gaim Use"), IDLE_GAIM, mbox, idle);
+#ifdef USE_SCREENSAVER
+	idle = idle_radio(_("X Use"), IDLE_SCREENSAVER, mbox, idle);
+#endif
+
+	frame = gtk_frame_new(_("Logging"));
+	gtk_box_pack_start(GTK_BOX(hbox), frame, TRUE, TRUE, 5);
+	gtk_widget_show(frame);
+
+	mbox = gtk_vbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), mbox);
+	gtk_widget_show(mbox);
+
+	gaim_button(_("Log all conversations"), &logging_options, OPT_LOG_ALL, mbox);
+	gaim_button(_("Strip HTML from logs"), &logging_options, OPT_LOG_STRIP_HTML, mbox);
+
+	sep = gtk_hseparator_new();
+	gtk_box_pack_start(GTK_BOX(mbox), sep, FALSE, FALSE, 0);
+	gtk_widget_show(sep);
+
+	gaim_button(_("Log when buddies sign on/sign off"), &logging_options, OPT_LOG_BUDDY_SIGNON,
+		    mbox);
+	gaim_button(_("Log when buddies become idle/un-idle"), &logging_options, OPT_LOG_BUDDY_IDLE,
+		    mbox);
+	gaim_button(_("Log when buddies go away/come back"), &logging_options, OPT_LOG_BUDDY_AWAY, mbox);
+	gaim_button(_("Log your own signons/idleness/awayness"), &logging_options, OPT_LOG_MY_SIGNON,
+		    mbox);
+	gaim_button(_("Individual log file for each buddy's signons"), &logging_options,
+		    OPT_LOG_INDIVIDUAL, mbox);
+
+	frame = gtk_frame_new(_("Browser"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	opt = browser_radio(_("KFM"), BROWSER_KFM, vbox, NULL);
+	opt = browser_radio(_("Opera"), BROWSER_OPERA, vbox, opt);
+	opt = browser_radio(_("Netscape"), BROWSER_NETSCAPE, vbox, opt);
+
+	new_window =
+	    gaim_button(_("Pop up new window by default"), &misc_options, OPT_MISC_BROWSER_POPUP, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+#ifdef USE_GNOME
+	opt = browser_radio(_("GNOME URL Handler"), BROWSER_GNOME, vbox, opt);
+#endif /* USE_GNOME */
+	opt = browser_radio(_("Galeon"), BROWSER_GALEON, vbox, opt);
+	opt = browser_radio(_("Manual"), BROWSER_MANUAL, vbox, opt);
+
+	browser_entry = gtk_entry_new();
+	gtk_box_pack_start(GTK_BOX(vbox), browser_entry, FALSE, FALSE, 0);
+	gtk_entry_set_text(GTK_ENTRY(browser_entry), web_command);
+	gtk_signal_connect(GTK_OBJECT(browser_entry), "focus_out_event",
+			   GTK_SIGNAL_FUNC(manualentry_key_pressed), NULL);
+	gtk_signal_connect(GTK_OBJECT(browser_entry), "destroy", GTK_SIGNAL_FUNC(brentdes), NULL);
+	gtk_widget_show(browser_entry);
+
+	if (web_browser != BROWSER_MANUAL) {
+		gtk_widget_set_sensitive(browser_entry, FALSE);
+	} else {
+		gtk_widget_set_sensitive(browser_entry, TRUE);
+	}
+
+	if (web_browser != BROWSER_NETSCAPE) {
+		gtk_widget_set_sensitive(new_window, FALSE);
+	} else {
+		gtk_widget_set_sensitive(new_window, TRUE);
+	}
+
+	gtk_widget_show(prefdialog);
+}
+
+#define PROXYHOST 0
+#define PROXYPORT 1
+#define PROXYTYPE 2
+#define PROXYUSER 3
+#define PROXYPASS 4
+
+static void proxy_print_option(GtkEntry *entry, int entrynum)
+{
+	if (entrynum == PROXYHOST)
+		g_snprintf(proxyhost, sizeof(proxyhost), "%s", gtk_entry_get_text(entry));
+	else if (entrynum == PROXYPORT)
+		proxyport = atoi(gtk_entry_get_text(entry));
+	else if (entrynum == PROXYUSER)
+		g_snprintf(proxyuser, sizeof(proxyuser), "%s", gtk_entry_get_text(entry));
+	else if (entrynum == PROXYPASS)
+		g_snprintf(proxypass, sizeof(proxypass), "%s", gtk_entry_get_text(entry));
+	save_prefs();
+}
+
+static void proxy_print_optionrad(GtkRadioButton * entry, int entrynum)
+{
+	if (entrynum == PROXY_NONE)
+		gtk_widget_set_sensitive(prefs_proxy_frame, FALSE);
+	else
+		gtk_widget_set_sensitive(prefs_proxy_frame, TRUE);
+
+	proxytype = entrynum;
+	save_prefs();
+}
+
+static void proxy_page()
+{
+	GtkWidget *parent;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *label;
+	GtkWidget *entry;
+	GtkWidget *first, *opt;
+	GtkWidget *frame;
+	GtkWidget *table;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Proxy Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), vbox);
+	gtk_widget_show(vbox);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	label = gtk_label_new(_("Not all protocols can use these proxy options. Please see the "
+				"README file for details."));
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Proxy Type"));
+	gtk_container_set_border_width(GTK_CONTAINER(frame), 5);
+	gtk_widget_show(frame);
+	gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, FALSE, 5);
+
+	table = gtk_table_new(2, 2, FALSE);
+	gtk_container_set_border_width(GTK_CONTAINER(table), 5);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 5);
+	gtk_widget_show(table);
+	gtk_container_add(GTK_CONTAINER(frame), table);
+
+	frame = gtk_frame_new(_("Proxy Server"));
+	prefs_proxy_frame = frame;
+
+	first = gtk_radio_button_new_with_label(NULL, _("No Proxy"));
+	gtk_table_attach(GTK_TABLE(table), first, 0, 1, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+
+	gtk_signal_connect(GTK_OBJECT(first), "clicked",
+			   GTK_SIGNAL_FUNC(proxy_print_optionrad), (void *)PROXY_NONE);
+	gtk_widget_show(first);
+
+	if (proxytype == PROXY_NONE)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(first), TRUE);
+
+	opt =
+	    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(first)),
+					    _("SOCKS 4"));
+	gtk_table_attach(GTK_TABLE(table), opt, 1, 2, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked",
+			   GTK_SIGNAL_FUNC(proxy_print_optionrad), (void *)PROXY_SOCKS4);
+	gtk_widget_show(opt);
+	if (proxytype == PROXY_SOCKS4)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+	opt =
+	    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(first)),
+					    _("SOCKS 5"));
+	gtk_table_attach(GTK_TABLE(table), opt, 0, 1, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked",
+			   GTK_SIGNAL_FUNC(proxy_print_optionrad), (void *)PROXY_SOCKS5);
+	gtk_widget_show(opt);
+	if (proxytype == PROXY_SOCKS5)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+	opt =
+	    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(first)), _("HTTP"));
+	gtk_table_attach(GTK_TABLE(table), opt, 1, 2, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked",
+			   GTK_SIGNAL_FUNC(proxy_print_optionrad), (void *)PROXY_HTTP);
+	gtk_widget_show(opt);
+	if (proxytype == PROXY_HTTP)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+
+	gtk_container_set_border_width(GTK_CONTAINER(frame), 5);
+	gtk_widget_show(frame);
+	gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, FALSE, 5);
+
+	if (proxytype == PROXY_NONE)
+		gtk_widget_set_sensitive(GTK_WIDGET(frame), FALSE);
+
+	table = gtk_table_new(2, 4, FALSE);
+	gtk_container_set_border_width(GTK_CONTAINER(table), 5);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 10);
+	gtk_widget_show(table);
+	gtk_container_add(GTK_CONTAINER(frame), table);
+
+
+	label = gtk_label_new(_("Host"));
+	gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+	gtk_widget_show(label);
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+
+	entry = gtk_entry_new();
+	gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(entry), "changed",
+			   GTK_SIGNAL_FUNC(proxy_print_option), (void *)PROXYHOST);
+	gtk_entry_set_text(GTK_ENTRY(entry), proxyhost);
+	gtk_widget_show(entry);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Port"));
+	gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_widget_show(label);
+
+	entry = gtk_entry_new();
+	gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(entry), "changed",
+			   GTK_SIGNAL_FUNC(proxy_print_option), (void *)PROXYPORT);
+
+	if (proxyport) {
+		char buf[128];
+		g_snprintf(buf, sizeof(buf), "%d", proxyport);
+		gtk_entry_set_text(GTK_ENTRY(entry), buf);
+	}
+	gtk_widget_show(entry);
+
+	label = gtk_label_new(_("User"));
+	gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_widget_show(label);
+
+	entry = gtk_entry_new();
+	gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 2, 3, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(entry), "changed",
+			   GTK_SIGNAL_FUNC(proxy_print_option), (void *)PROXYUSER);
+	gtk_entry_set_text(GTK_ENTRY(entry), proxyuser);
+	gtk_widget_show(entry);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Password"));
+	gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, 3, 4, GTK_FILL, 0, 0, 0);
+	gtk_widget_show(label);
+
+	entry = gtk_entry_new();
+	gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 3, 4, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);
+	gtk_signal_connect(GTK_OBJECT(entry), "changed",
+			   GTK_SIGNAL_FUNC(proxy_print_option), (void *)PROXYPASS);
+	gtk_entry_set_text(GTK_ENTRY(entry), proxypass);
+	gtk_widget_show(entry);
+
+	gtk_widget_show(prefdialog);
+}
+
+static void buddy_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *hbox;
+	GtkWidget *vbox;
+	GtkWidget *sep;
+	GtkWidget *opt;
+	GtkWidget *button;
+	GtkWidget *button2;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Buddy List Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Buddy List Window"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	/* "Place blist tabs  */
+	vbox = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, FALSE, FALSE, 5);
+	gtk_widget_show(vbox);
+
+	label = gtk_label_new(_("Tab Placement:"));
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);	
+	
+	opt = blist_tab_radio(_("Top"), ~(OPT_BLIST_BOTTOM_TAB), vbox, NULL);
+	opt = blist_tab_radio(_("Bottom"), OPT_BLIST_BOTTOM_TAB, vbox, opt);
+
+	sep = gtk_vseparator_new();
+	gtk_box_pack_start(GTK_BOX(hbox), sep, FALSE, FALSE, 5);
+	gtk_widget_show(sep);
+
+	/* End of blist tab options */
+
+	vbox = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	button = gaim_button(_("Hide IM/Info/Chat buttons"), &blist_options, OPT_BLIST_NO_BUTTONS, vbox);
+#ifdef USE_APPLET
+	gaim_button(_("Automatically show buddy list on sign on"), &blist_options,
+		    OPT_BLIST_APP_BUDDY_SHOW, vbox);
+	gaim_button(_("Display Buddy List near applet"), &blist_options, OPT_BLIST_NEAR_APPLET, vbox);
+	
+#endif
+	gaim_button(_("Save Window Size/Position"), &blist_options, OPT_BLIST_SAVED_WINDOWS, vbox);
+
+	button2 =
+	    gaim_button(_("Show pictures on buttons"), &blist_options, OPT_BLIST_SHOW_BUTTON_XPM, vbox);
+	if (blist_options & OPT_BLIST_NO_BUTTONS)
+		gtk_widget_set_sensitive(button2, FALSE);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), button2);
+	gaim_button(_("Raise Buddy List on Signons and Signoffs"), &blist_options, OPT_BLIST_POPUP, vbox);
+
+	frame = gtk_frame_new(_("Group Displays"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Hide groups with no online buddies"), &blist_options, OPT_BLIST_NO_MT_GRP, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Show numbers in groups"), &blist_options, OPT_BLIST_SHOW_GRPNUM, vbox);
+
+	frame = gtk_frame_new(_("Buddy Displays"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Show buddy type icons"), &blist_options, OPT_BLIST_SHOW_PIXMAPS, vbox);
+	gaim_button(_("Show warning levels"), &blist_options, OPT_BLIST_SHOW_WARN, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Show idle times"), &blist_options, OPT_BLIST_SHOW_IDLETIME, vbox);
+	gaim_button(_("Grey idle buddies"), &blist_options, OPT_BLIST_GREY_IDLERS, vbox);
+
+	gtk_widget_show(prefdialog);
+}
+
+static void convo_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *hbox;
+	GtkWidget *vbox;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Conversation Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Keyboard Options"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Enter sends message"), &convo_options, OPT_CONVO_ENTER_SENDS, vbox);
+	gaim_button(_("Control-Enter sends message"), &convo_options, OPT_CONVO_CTL_ENTER, vbox);
+	gaim_button(_("Escape closes window"), &convo_options, OPT_CONVO_ESC_CAN_CLOSE, vbox);
+	gaim_button(_("Control-W closes window"), &convo_options, OPT_CONVO_CTL_W_CLOSES, vbox);
+
+	vbox = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Control-{B/I/U/S} inserts HTML tags"), &convo_options, OPT_CONVO_CTL_CHARS, vbox);
+	gaim_button(_("Control-(number) inserts smileys"), &convo_options, OPT_CONVO_CTL_SMILEYS, vbox);
+	gaim_button(_("F2 toggles timestamp display"), &convo_options, OPT_CONVO_F2_TOGGLES, vbox);
+
+	frame = gtk_frame_new(_("Display and General Options"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Show graphical smileys"), &convo_options, OPT_CONVO_SHOW_SMILEY, vbox);
+	gaim_button(_("Show timestamp on messages"), &convo_options, OPT_CONVO_SHOW_TIME, vbox);
+	gaim_button(_("Show URLs as links"), &convo_options, OPT_CONVO_SEND_LINKS, vbox);
+	gaim_button(_("Highlight misspelled words"), &convo_options, OPT_CONVO_CHECK_SPELLING, vbox);
+	gaim_button(_("Sending messages removes away status"), &away_options, OPT_AWAY_BACK_ON_IM, vbox);
+	gaim_button(_("Queue new messages when away"), &away_options, OPT_AWAY_QUEUE, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Ignore colors"), &convo_options, OPT_CONVO_IGNORE_COLOUR, vbox);
+	gaim_button(_("Ignore font faces"), &convo_options, OPT_CONVO_IGNORE_FONTS, vbox);
+	gaim_button(_("Ignore font sizes"), &convo_options, OPT_CONVO_IGNORE_SIZES, vbox);
+	gaim_button(_("Ignore TiK Automated Messages"), &away_options, OPT_AWAY_TIK_HACK, vbox);
+	gaim_button(_("Ignore new conversations when away"), &away_options, OPT_AWAY_DISCARD, vbox);
+
+	gtk_widget_show(prefdialog);
+}
+
+static void set_buttons_opt(GtkWidget *w, int data)
+{
+	int mask;
+	if (data & 0x1) {	/* set the first bit if we're affecting chat buttons */
+		mask = (OPT_CHAT_BUTTON_TEXT | OPT_CHAT_BUTTON_XPM);
+		chat_options &= ~(mask);
+		chat_options |= (data & mask);
+		update_chat_button_pix();
+	} else {
+		mask = (OPT_IM_BUTTON_TEXT | OPT_IM_BUTTON_XPM);
+		im_options &= ~(mask);
+		im_options |= (data & mask);
+		update_im_button_pix();
+	}
+
+	save_prefs();
+}
+
+/* i like everclear */
+static GtkWidget *am_radio(char *label, int which, GtkWidget *box, GtkWidget *set)
+{
+	GtkWidget *opt;
+
+	if (!set)
+		opt = gtk_radio_button_new_with_label(NULL, label);
+	else
+		opt =
+		    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)),
+						    label);
+	gtk_box_pack_start(GTK_BOX(box), opt, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked", GTK_SIGNAL_FUNC(set_buttons_opt), (void *)which);
+	gtk_widget_show(opt);
+	if (which & 1) {
+		if (which == (OPT_CHAT_BUTTON_TEXT | 1)) {
+			if ((chat_options & OPT_CHAT_BUTTON_TEXT) &&
+			    !(chat_options & OPT_CHAT_BUTTON_XPM))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		} else if (which == (OPT_CHAT_BUTTON_XPM | 1)) {
+			if (!(chat_options & OPT_CHAT_BUTTON_TEXT) &&
+			    (chat_options & OPT_CHAT_BUTTON_XPM))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		} else {
+			if (((chat_options & OPT_CHAT_BUTTON_TEXT) &&
+			     (chat_options & OPT_CHAT_BUTTON_XPM)) ||
+			    (!(chat_options & OPT_CHAT_BUTTON_TEXT) &&
+			     !(chat_options & OPT_CHAT_BUTTON_XPM)))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		}
+	} else {
+		if (which == OPT_IM_BUTTON_TEXT) {
+			if ((im_options & OPT_IM_BUTTON_TEXT) && !(im_options & OPT_IM_BUTTON_XPM))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		} else if (which == OPT_IM_BUTTON_XPM) {
+			if (!(im_options & OPT_IM_BUTTON_TEXT) && (im_options & OPT_IM_BUTTON_XPM))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		} else {
+			if (((im_options & OPT_IM_BUTTON_TEXT) &&
+			     (im_options & OPT_IM_BUTTON_XPM)) ||
+			    (!(im_options & OPT_IM_BUTTON_TEXT) && !(im_options & OPT_IM_BUTTON_XPM)))
+				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		}
+	}
+
+	return opt;
+}
+
+static void set_tab_opt(GtkWidget *w, int data)
+{
+	int mask;
+	if (convo_options & OPT_CONVO_COMBINE) {
+		/* through an amazing coincidence (this wasn't planned), we're able to do this,
+		 * since the two sets of options end up having the same value. isn't that great. */
+		mask = (OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB);
+		chat_options &= ~(mask);
+		chat_options |= (data & mask);
+
+		mask = (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB);
+		im_options &= ~(mask);
+		im_options |= (data & mask);
+
+		update_im_tabs();
+	} else {
+		if (data & 0x1) {	/* set the first bit if we're affecting chat buttons */
+			mask = (OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB);
+			chat_options &= ~(mask);
+			chat_options |= (data & mask);
+			update_chat_tabs();
+		} else {
+			mask = (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB);
+			im_options &= ~(mask);
+			im_options |= (data & mask);
+			update_im_tabs();
+		}
+	}
+
+	save_prefs();
+}
+
+static GtkWidget *tab_radio(char *label, int which, GtkWidget *box, GtkWidget *set)
+{
+	GtkWidget *opt;
+
+	if (!set)
+		opt = gtk_radio_button_new_with_label(NULL, label);
+	else
+		opt =
+		    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)),
+						    label);
+	gtk_box_pack_start(GTK_BOX(box), opt, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "clicked", GTK_SIGNAL_FUNC(set_tab_opt), (void *)which);
+	gtk_widget_show(opt);
+	if (which & 1) {
+		if ((chat_options & (OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB)) == (which ^ 1))
+			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		if (!(chat_options & OPT_CHAT_ONE_WINDOW))
+			gtk_widget_set_sensitive(opt, FALSE);
+	} else {
+		if ((im_options & (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB)) == which)
+			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+		if (!(im_options & OPT_IM_ONE_WINDOW))
+			gtk_widget_set_sensitive(opt, FALSE);
+	}
+
+	return opt;
+}
+
+static void update_spin_value(GtkWidget *w, GtkWidget *spin)
+{
+	int *value = gtk_object_get_user_data(GTK_OBJECT(spin));
+	*value = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(spin));
+}
+
+static void gaim_labeled_spin_button(GtkWidget *box, const gchar *title, int *val, int min, int max)
+{
+	GtkWidget *hbox;
+	GtkWidget *label;
+	GtkWidget *spin;
+	GtkObject *adjust;
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(title);
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	adjust = gtk_adjustment_new(*val, min, max, 1, 1, 1);
+	spin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);
+	gtk_object_set_user_data(GTK_OBJECT(spin), val);
+	gtk_widget_set_usize(spin, 50, -1);
+	gtk_box_pack_start(GTK_BOX(hbox), spin, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(adjust), "value-changed",
+			   GTK_SIGNAL_FUNC(update_spin_value), GTK_WIDGET(spin));
+	gtk_widget_show(spin);
+}
+
+static gboolean current_is_im = FALSE;
+
+static void not_im()
+{
+	current_is_im = FALSE;
+}
+
+static void im_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *vbox2;
+	GtkWidget *opt;
+	GtkWidget *sep;
+	GtkWidget *button;
+	GtkWidget *hbox2;
+	GtkWidget *vbox3;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	current_is_im = TRUE;
+
+	prefdialog = gtk_frame_new(_("IM Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+	gtk_signal_connect(GTK_OBJECT(prefdialog), "destroy", GTK_SIGNAL_FUNC(not_im), NULL);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("IM Window"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	vbox2 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, FALSE, FALSE, 5);
+	gtk_widget_show(vbox2);
+
+	label = gtk_label_new(_("Show buttons as: "));
+	gtk_box_pack_start(GTK_BOX(vbox2), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	opt = am_radio(_("Pictures And Text"), OPT_IM_BUTTON_TEXT | OPT_IM_BUTTON_XPM, vbox2, NULL);
+	opt = am_radio(_("Pictures"), OPT_IM_BUTTON_XPM, vbox2, opt);
+	opt = am_radio(_("Text"), OPT_IM_BUTTON_TEXT, vbox2, opt);
+
+	sep = gtk_vseparator_new();
+	gtk_box_pack_start(GTK_BOX(hbox), sep, FALSE, FALSE, 5);
+	gtk_widget_show(sep);
+
+	vbox2 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	button =
+	    gaim_button(_("Show all conversations in one tabbed window"), &im_options, OPT_IM_ONE_WINDOW,
+			vbox2);
+	opt = gaim_button(_("Show chats in the same tabbed window"), &convo_options, OPT_CONVO_COMBINE, vbox2);
+	if (chat_options & OPT_CHAT_ONE_WINDOW) {
+		if (!(im_options & OPT_IM_ONE_WINDOW))
+			gtk_widget_set_sensitive(opt, FALSE);
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	} else
+		gtk_widget_set_sensitive(opt, FALSE);
+	gaim_button(_("Raise windows on events"), &im_options, OPT_IM_POPUP, vbox2);
+	gaim_button(_("Show logins in window"), &im_options, OPT_IM_LOGON, vbox2);
+	gaim_button(_("Show aliases in tabs/titles"), &im_options, OPT_IM_ALIAS_TAB, vbox2);
+	gaim_button(_("Hide window on send"), &im_options, OPT_IM_POPDOWN, vbox2);
+
+	frame = gtk_frame_new(_("Window Sizes"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	gaim_labeled_spin_button(vbox, _("New window width:"), &conv_size.width, 25, 9999);
+	gaim_labeled_spin_button(vbox, _("New window height:"), &conv_size.height, 25, 9999);
+	gaim_labeled_spin_button(vbox, _("Entry widget height:"), &conv_size.entry_height, 25, 9999);
+
+	frame = gtk_frame_new(_("Tab Placement"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	hbox2 = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox2, TRUE, TRUE, 5);
+	gtk_widget_show(hbox2);
+
+	vbox3 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox2), vbox3, TRUE, TRUE, 5);
+	gtk_widget_show(vbox3);
+
+	opt = tab_radio(_("Top"), 0, vbox3, NULL);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	opt = tab_radio(_("Bottom"), OPT_IM_BR_TAB, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+
+	vbox3 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox2), vbox3, TRUE, TRUE, 5);
+	gtk_widget_show(vbox3);
+
+	opt = tab_radio(_("Left"), OPT_IM_SIDE_TAB, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	opt = tab_radio(_("Right"), OPT_IM_SIDE_TAB | OPT_IM_BR_TAB, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+
+#if USE_PIXBUF
+	frame = gtk_frame_new(_("Buddy Icons"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	gaim_button(_("Hide Buddy Icons"), &im_options, OPT_IM_HIDE_ICONS, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+	
+	gaim_button(_("Disable Buddy Icon Animation"), &im_options, OPT_IM_NO_ANIMATION, vbox);
+#endif
+
+	gtk_widget_show(prefdialog);
+}
+
+static void chat_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *vbox2;
+	GtkWidget *opt;
+	GtkWidget *sep;
+	GtkWidget *button;
+	GtkWidget *hbox2;
+	GtkWidget *vbox3;
+	GtkWidget *tab;
+	GtkWidget *old;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Chat Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Group Chat Window"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	vbox2 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, FALSE, FALSE, 5);
+	gtk_widget_show(vbox2);
+
+	label = gtk_label_new(_("Show buttons as: "));
+	gtk_box_pack_start(GTK_BOX(vbox2), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	opt =
+	    am_radio(_("Pictures And Text"), OPT_CHAT_BUTTON_TEXT | OPT_CHAT_BUTTON_XPM | 1, vbox2,
+		     NULL);
+	opt = am_radio(_("Pictures"), OPT_CHAT_BUTTON_XPM | 1, vbox2, opt);
+	opt = am_radio(_("Text"), OPT_CHAT_BUTTON_TEXT | 1, vbox2, opt);
+
+	sep = gtk_vseparator_new();
+	gtk_box_pack_start(GTK_BOX(hbox), sep, FALSE, FALSE, 5);
+	gtk_widget_show(sep);
+
+	vbox2 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	button =
+	    gaim_button(_("Show all chats in one tabbed window"), &chat_options, OPT_CHAT_ONE_WINDOW,
+			vbox2);
+	opt = gaim_button(_("Show conversations in the same tabbed window"), &convo_options, OPT_CONVO_COMBINE, vbox2);
+	if (im_options & OPT_IM_ONE_WINDOW) {
+		if (!(chat_options & OPT_CHAT_ONE_WINDOW))
+			gtk_widget_set_sensitive(opt, FALSE);
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	} else
+		gtk_widget_set_sensitive(opt, FALSE);
+	gaim_button(_("Raise windows on events"), &chat_options, OPT_CHAT_POPUP, vbox2);
+	gaim_button(_("Show people joining/leaving in window"), &chat_options, OPT_CHAT_LOGON, vbox2);
+
+	frame = gtk_frame_new(_("Window Sizes"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	gaim_labeled_spin_button(vbox, _("New window width:"), &buddy_chat_size.width, 25, 9999);
+	gaim_labeled_spin_button(vbox, _("New window height:"), &buddy_chat_size.height, 25, 9999);
+	gaim_labeled_spin_button(vbox, _("Entry widget height:"), &buddy_chat_size.entry_height, 25, 9999);
+
+	frame = gtk_frame_new(_("Tab Placement"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	hbox2 = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox2, TRUE, TRUE, 5);
+	gtk_widget_show(hbox2);
+
+	vbox3 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox2), vbox3, TRUE, TRUE, 5);
+	gtk_widget_show(vbox3);
+
+	opt = tab_radio(_("Top"), 1, vbox3, NULL);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	opt = tab_radio(_("Bottom"), OPT_CHAT_BR_TAB | 1, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+
+	vbox3 = gtk_vbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox2), vbox3, TRUE, TRUE, 5);
+	gtk_widget_show(vbox3);
+
+	opt = tab_radio(_("Left"), OPT_CHAT_SIDE_TAB | 1, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+	opt = tab_radio(_("Right"), OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB | 1, vbox3, opt);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), opt);
+
+	frame = gtk_frame_new(_("Tab Completion"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), hbox);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	tab = gaim_button(_("Tab-Complete Nicks"), &chat_options, OPT_CHAT_TAB_COMPLETE, vbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	old = gaim_button(_("Old-Style Tab Completion"), &chat_options, OPT_CHAT_OLD_STYLE_TAB, vbox);
+	if (!(chat_options & OPT_CHAT_TAB_COMPLETE))
+		gtk_widget_set_sensitive(GTK_WIDGET(old), FALSE);
+	gtk_signal_connect(GTK_OBJECT(tab), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), old);
+
+	gtk_widget_show(prefdialog);
+}
+
+static GtkWidget *show_color_pref(GtkWidget *box, gboolean fgc)
+{
+	/* more stuff stolen from X-Chat */
+	GtkWidget *swid;
+	GdkColor c;
+	GtkStyle *style;
+	c.pixel = 0;
+	if (fgc) {
+		if (font_options & OPT_FONT_FGCOL) {
+			c.red = fgcolor.red << 8;
+			c.blue = fgcolor.blue << 8;
+			c.green = fgcolor.green << 8;
+		} else {
+			c.red = 0;
+			c.blue = 0;
+			c.green = 0;
+		}
+	} else {
+		if (font_options & OPT_FONT_BGCOL) {
+			c.red = bgcolor.red << 8;
+			c.blue = bgcolor.blue << 8;
+			c.green = bgcolor.green << 8;
+		} else {
+			c.red = 0xffff;
+			c.blue = 0xffff;
+			c.green = 0xffff;
+		}
+	}
+
+	style = gtk_style_new();
+	style->bg[0] = c;
+
+	swid = gtk_event_box_new();
+	gtk_widget_set_style(GTK_WIDGET(swid), style);
+	gtk_style_unref(style);
+	gtk_widget_set_usize(GTK_WIDGET(swid), 40, -1);
+	gtk_box_pack_start(GTK_BOX(box), swid, FALSE, FALSE, 5);
+	gtk_widget_show(swid);
+	return swid;
+}
+
+GtkWidget *pref_fg_picture = NULL;
+GtkWidget *pref_bg_picture = NULL;
+
+void update_color(GtkWidget *w, GtkWidget *pic)
+{
+	GdkColor c;
+	GtkStyle *style;
+	c.pixel = 0;
+	if (pic == pref_fg_picture) {
+		if (font_options & OPT_FONT_FGCOL) {
+			c.red = fgcolor.red << 8;
+			c.blue = fgcolor.blue << 8;
+			c.green = fgcolor.green << 8;
+		} else {
+			c.red = 0;
+			c.blue = 0;
+			c.green = 0;
+		}
+	} else {
+		if (font_options & OPT_FONT_BGCOL) {
+			c.red = bgcolor.red << 8;
+			c.blue = bgcolor.blue << 8;
+			c.green = bgcolor.green << 8;
+		} else {
+			c.red = 0xffff;
+			c.blue = 0xffff;
+			c.green = 0xffff;
+		}
+	}
+
+	style = gtk_style_new();
+	style->bg[0] = c;
+	gtk_widget_set_style(pic, style);
+	gtk_style_unref(style);
+}
+
+static void font_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *hbox;
+	GtkWidget *button;
+	GtkWidget *select;
+	GtkWidget *spin;
+	GtkObject *adjust;
+	GtkWidget *frame;
+	GtkWidget *fbox;
+	GtkWidget *table;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Font Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new("Font Style");
+
+	table = gtk_table_new(2, 2, FALSE);
+	gtk_container_set_border_width(GTK_CONTAINER(table), 5);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 5);
+	gtk_container_add(GTK_CONTAINER(frame), table);
+
+	button = gtk_check_button_new_with_label(_("Bold Text"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (font_options & OPT_FONT_BOLD));
+	gtk_table_attach(GTK_TABLE(table), button, 0, 1, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_font_option), (int *)OPT_FONT_BOLD);
+
+	button = gtk_check_button_new_with_label(_("Italic Text"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (font_options & OPT_FONT_ITALIC));
+	gtk_table_attach(GTK_TABLE(table), button, 0, 1, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_font_option), (int *)OPT_FONT_ITALIC);
+
+	button = gtk_check_button_new_with_label(_("Underline Text"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (font_options & OPT_FONT_UNDERLINE));
+	gtk_table_attach(GTK_TABLE(table), button, 1, 2, 0, 1, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_font_option), (int *)OPT_FONT_UNDERLINE);
+
+	button = gtk_check_button_new_with_label(_("Strike through Text"));
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (font_options & OPT_FONT_STRIKE));
+	gtk_table_attach(GTK_TABLE(table), button, 1, 2, 1, 2, GTK_FILL | GTK_EXPAND, 0, 0, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked",
+			   GTK_SIGNAL_FUNC(set_font_option), (int *)OPT_FONT_STRIKE);
+
+
+	gtk_widget_show_all(table);
+	gtk_widget_show(frame);
+
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+
+	/* ----------- */
+
+	frame = gtk_frame_new("Font Color");
+	fbox = gtk_vbox_new(FALSE, 5);
+
+	gtk_container_add(GTK_CONTAINER(frame), fbox);
+	gtk_container_set_border_width(GTK_CONTAINER(fbox), 5);
+
+	gtk_widget_show(fbox);
+	gtk_widget_show(frame);
+
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	pref_fg_picture = show_color_pref(hbox, TRUE);
+	button = gaim_button(_("Text Color"), &font_options, OPT_FONT_FGCOL, hbox);
+
+	select = picture_button(prefs, _("Select"), fgcolor_xpm);
+	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
+	if (!(font_options & OPT_FONT_FGCOL))
+		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_fgcolor_dialog), NULL);
+	gtk_widget_show(select);
+
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
+			   pref_fg_picture);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	pref_bg_picture = show_color_pref(hbox, FALSE);
+	button = gaim_button(_("Background Color"), &font_options, OPT_FONT_BGCOL, hbox);
+
+	select = picture_button(prefs, _("Select"), bgcolor_xpm);
+	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 5);
+	if (!(font_options & OPT_FONT_BGCOL))
+		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_bgcolor_dialog), NULL);
+	gtk_widget_show(select);
+
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(update_color),
+			   pref_bg_picture);
+
+	/* ----------- */
+
+	frame = gtk_frame_new("Font Face");
+	fbox = gtk_vbox_new(FALSE, 5);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	button = gaim_button(_("Font Face for Text"), &font_options, OPT_FONT_FACE, hbox);
+
+	select = picture_button(prefs, _("Select"), fontface2_xpm);
+	gtk_box_pack_start(GTK_BOX(hbox), select, FALSE, FALSE, 0);
+	if (!(font_options & OPT_FONT_FACE))
+		gtk_widget_set_sensitive(GTK_WIDGET(select), FALSE);
+	gtk_signal_connect(GTK_OBJECT(select), "clicked", GTK_SIGNAL_FUNC(show_font_dialog), NULL);
+	gtk_widget_show(select);
+
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), select);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(fbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	button = gaim_button(_("Font Size for Text"), &font_options, OPT_FONT_SIZE, hbox);
+
+	adjust = gtk_adjustment_new(fontsize, 1, 7, 1, 1, 1);
+	spin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);
+	gtk_widget_set_usize(spin, 50, -1);
+	gtk_object_set_user_data(GTK_OBJECT(spin), &fontsize);
+	if (!(font_options & OPT_FONT_SIZE))
+		gtk_widget_set_sensitive(GTK_WIDGET(spin), FALSE);
+	gtk_box_pack_start(GTK_BOX(hbox), spin, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), spin);
+	+gtk_signal_connect(GTK_OBJECT(adjust), "value-changed", GTK_SIGNAL_FUNC(update_spin_value),
+			    GTK_WIDGET(spin));
+	gtk_widget_show(spin);
+
+	gtk_container_add(GTK_CONTAINER(frame), fbox);
+	gtk_container_set_border_width(GTK_CONTAINER(fbox), 5);
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(fbox);
+	gtk_widget_show(frame);
+
+	gtk_widget_show(prefdialog);
+}
+
+static GtkWidget *sndent[NUM_SOUNDS];
+static GtkWidget *sndcmd = NULL;
+static char *last_sound_dir = NULL;
+
+void close_sounddialog(GtkWidget *w, GtkWidget *w2)
+{
+
+	GtkWidget *dest;
+
+	if (!GTK_IS_WIDGET(w2))
+		dest = w;
+	else
+		dest = w2;
+
+	sounddialog = NULL;
+
+	gtk_widget_destroy(dest);
+}
+
+void do_select_sound(GtkWidget *w, int snd)
+{
+	const char *file;
+
+	file = gtk_file_selection_get_filename(GTK_FILE_SELECTION(sounddialog));
+
+	/* If they type in a directory, change there */
+	if (file_is_dir(file, sounddialog))
+		return;
+
+	/* Let's just be safe */
+	if (sound_file[snd])
+		free(sound_file[snd]);
+
+	/* Set it -- and forget it */
+	sound_file[snd] = g_strdup(file);
+
+	save_prefs();
+
+	/* Set our text entry */
+	gtk_entry_set_text(GTK_ENTRY(sndent[snd]), sound_file[snd]);
+
+	/* Close the window! It's getting cold in here! */
+	close_sounddialog(NULL, sounddialog);
+
+	if (last_sound_dir)
+		g_free(last_sound_dir);
+	last_sound_dir = g_dirname(sound_file[snd]);
+}
+
+static void test_sound(GtkWidget *button, int snd)
+{
+	guint32 tmp_sound = sound_options;
+	if (!(sound_options & OPT_SOUND_WHEN_AWAY))
+		sound_options ^= OPT_SOUND_WHEN_AWAY;
+	if (!(sound_options & sounds[snd].opt))
+		sound_options ^= sounds[snd].opt;
+	play_sound(snd);
+	sound_options = tmp_sound;
+}
+
+static void reset_sound(GtkWidget *button, int snd)
+{
+
+	/* This just resets a sound file back to default */
+	sound_file[snd] = NULL;
+
+	gtk_entry_set_text(GTK_ENTRY(sndent[snd]), "(default)");
+}
+
+static void sel_sound(GtkWidget *button, int snd)
+{
+	char *buf = g_malloc(BUF_LEN);
+
+	if (!sounddialog) {
+		sounddialog = gtk_file_selection_new(_("Gaim - Sound Configuration"));
+
+		gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(sounddialog));
+
+		g_snprintf(buf, BUF_LEN - 1, "%s/", last_sound_dir ? last_sound_dir : g_get_home_dir());
+
+		gtk_file_selection_set_filename(GTK_FILE_SELECTION(sounddialog), buf);
+
+		gtk_signal_connect(GTK_OBJECT(sounddialog), "destroy",
+				   GTK_SIGNAL_FUNC(close_sounddialog), sounddialog);
+
+		gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(sounddialog)->ok_button),
+				   "clicked", GTK_SIGNAL_FUNC(do_select_sound), (int *)snd);
+
+		gtk_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(sounddialog)->cancel_button),
+				   "clicked", GTK_SIGNAL_FUNC(close_sounddialog), sounddialog);
+	}
+
+	g_free(buf);
+	gtk_widget_show(sounddialog);
+	gdk_window_raise(sounddialog->window);
+}
+
+static void sound_entry(GtkWidget *box, int snd)
+{
+	GtkWidget *hbox;
+	GtkWidget *entry;
+	GtkWidget *button;
+
+	hbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	gaim_button(sounds[snd].label, &sound_options, sounds[snd].opt, hbox);
+
+	button = gtk_button_new_with_label(_("Test"));
+	gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, FALSE, 3);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(test_sound), (void *)snd);
+	gtk_widget_show(button);
+
+	button = gtk_button_new_with_label(_("Reset"));
+	gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, FALSE, 3);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(reset_sound), (void *)snd);
+	gtk_widget_show(button);
+
+	button = gtk_button_new_with_label(_("Choose..."));
+	gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, FALSE, 3);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(sel_sound), (void *)snd);
+	gtk_widget_show(button);
+
+	entry = gtk_entry_new();
+	gtk_entry_set_editable(GTK_ENTRY(entry), FALSE);
+
+	if (sound_file[snd])
+		gtk_entry_set_text(GTK_ENTRY(entry), sound_file[snd]);
+	else
+		gtk_entry_set_text(GTK_ENTRY(entry), "(default)");
+
+	gtk_box_pack_end(GTK_BOX(hbox), entry, FALSE, FALSE, 5);
+	sndent[snd] = entry;
+	gtk_widget_show(entry);
+}
+
+static gint sound_cmd_yeah(GtkEntry *entry, GdkEvent *event, gpointer d)
+{
+	g_snprintf(sound_cmd, sizeof(sound_cmd), "%s", gtk_entry_get_text(GTK_ENTRY(sndcmd)));
+	save_prefs();
+	return TRUE;
+}
+
+static void set_sound_driver(GtkWidget *w, int option)
+{
+	if (option == OPT_SOUND_CMD)
+		gtk_widget_set_sensitive(sndcmd, TRUE);
+	else
+		gtk_widget_set_sensitive(sndcmd, FALSE);
+
+	sound_options &= ~(OPT_SOUND_NORMAL | OPT_SOUND_BEEP |
+			   OPT_SOUND_NAS | OPT_SOUND_ARTSC |
+			   OPT_SOUND_ESD | OPT_SOUND_CMD);
+	sound_options |= option;
+	save_prefs();
+}
+
+static void sound_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *vbox2;
+	GtkWidget *sep;
+	GtkWidget *omenu;
+	GtkWidget *menu;
+	GtkWidget *opt;
+	int i=1, driver=0, j;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Sound Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Options"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	vbox2 = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	gaim_button(_("No sounds when you log in"), &sound_options, OPT_SOUND_SILENT_SIGNON, vbox2);
+
+	vbox2 = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	gaim_button(_("Sounds while away"), &sound_options, OPT_SOUND_WHEN_AWAY, vbox2);
+
+	sep = gtk_hseparator_new();
+	gtk_box_pack_start(GTK_BOX(vbox), sep, FALSE, FALSE, 0);
+	gtk_widget_show(sep);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Sound method"));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	omenu = gtk_option_menu_new();
+	menu = gtk_menu_new();
+
+	opt = gtk_menu_item_new_with_label("Console Beep");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_BEEP);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_BEEP) && !driver) driver = i;
+	i++;
+
+#ifdef ESD_SOUND
+	opt = gtk_menu_item_new_with_label("ESD");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_ESD);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_ESD) && !driver) driver = i;
+	i++;
+#endif
+#ifdef ARTSC_SOUND
+	opt = gtk_menu_item_new_with_label("ArtsC");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_ARTSC);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_ARTSC) && !driver) driver = i;
+	i++;
+#endif
+#ifdef NAS_SOUND
+	opt = gtk_menu_item_new_with_label("NAS");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_NAS);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_NAS) && !driver) driver = i;
+	i++;
+#endif
+
+	opt = gtk_menu_item_new_with_label("Internal");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_NORMAL);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_NORMAL) && !driver) driver = i;
+	i++;
+
+	opt = gtk_menu_item_new_with_label("Command");
+	gtk_signal_connect(GTK_OBJECT(opt), "activate",
+			   GTK_SIGNAL_FUNC(set_sound_driver), 
+			   (gpointer)OPT_SOUND_CMD);
+	gtk_widget_show(opt);
+	gtk_menu_append(GTK_MENU(menu), opt);
+	if ((sound_options & OPT_SOUND_CMD) && !driver) driver = i;
+	i++;
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(omenu), menu);
+	gtk_option_menu_set_history(GTK_OPTION_MENU(omenu), driver - 1);
+	gtk_box_pack_start(GTK_BOX(hbox), omenu, FALSE, FALSE, 5);
+	gtk_widget_show_all(omenu);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Sound command\n(%s for filename)"));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	sndcmd = gtk_entry_new();
+	gtk_entry_set_editable(GTK_ENTRY(sndcmd), TRUE);
+	gtk_entry_set_text(GTK_ENTRY(sndcmd), sound_cmd);
+	gtk_box_pack_end(GTK_BOX(hbox), sndcmd, FALSE, FALSE, 5);
+	gtk_signal_connect(GTK_OBJECT(sndcmd), "focus_out_event", GTK_SIGNAL_FUNC(sound_cmd_yeah), NULL);
+	gtk_widget_set_sensitive(sndcmd, (OPT_SOUND_CMD & sound_options));
+	gtk_widget_show(sndcmd);
+
+	frame = gtk_frame_new(_("Sound played when:"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	for (j=0; j < NUM_SOUNDS; j++) {
+		/* no entry for sounds without an option */
+		if (sounds[j].opt == 0)
+			continue;
+
+		/* seperators before SND_RECEIVE and SND_CHAT_JOIN */
+		if ((j == SND_RECEIVE) || (j == SND_CHAT_JOIN)) {
+			sep = gtk_hseparator_new();
+			gtk_box_pack_start(GTK_BOX(vbox), sep, FALSE, FALSE, 5);
+			gtk_widget_show(sep);
+		}
+
+		sound_entry(vbox, j);
+	}
+
+	gtk_widget_show(prefdialog);
+}
+
+static struct away_message *cur_message;
+static GtkWidget *away_text;
+static GtkWidget *make_away_button = NULL;
+
+void away_list_clicked(GtkWidget *widget, struct away_message *a)
+{
+	gchar buffer[BUF_LONG];
+	char *tmp;
+
+	cur_message = a;
+
+	/* Clear the Box */
+	gtk_imhtml_clear(GTK_IMHTML(away_text));
+
+	/* Fill the text box with new message */
+	strcpy(buffer, a->message);
+	tmp = stylize(buffer, BUF_LONG);
+	gtk_imhtml_append_text(GTK_IMHTML(away_text), tmp, -1, GTK_IMHTML_NO_TITLE |
+			       GTK_IMHTML_NO_COMMENTS | GTK_IMHTML_NO_SCROLL);
+	gtk_imhtml_append_text(GTK_IMHTML(away_text), "<BR>", -1, GTK_IMHTML_NO_TITLE |
+			       GTK_IMHTML_NO_COMMENTS | GTK_IMHTML_NO_SCROLL);
+	g_free(tmp);
+}
+
+void remove_away_message(GtkWidget *widget, void *dummy)
+{
+	GList *i;
+	struct away_message *a;
+
+	i = GTK_LIST(prefs_away_list)->selection;
+
+	if (!i)
+		return;
+	if (!i->next) {
+		gtk_imhtml_clear(GTK_IMHTML(away_text));
+	}
+	a = gtk_object_get_user_data(GTK_OBJECT(i->data));
+	rem_away_mess(NULL, a);
+}
+
+static void paldest(GtkWidget *m, gpointer n)
+{
+	gtk_widget_destroy(prefs_away_list);
+	prefs_away_list = NULL;
+	prefs_away_menu = NULL;
+	make_away_button = NULL;
+}
+
+static void do_away_mess(GtkWidget *m, gpointer n)
+{
+	GList *i = GTK_LIST(prefs_away_list)->selection;
+	if (i)
+		do_away_message(NULL, gtk_object_get_user_data(GTK_OBJECT(i->data)));
+}
+
+void set_default_away(GtkWidget *w, gpointer i)
+{
+	int length = g_slist_length(away_messages);
+
+	if (away_messages == NULL)
+		default_away = NULL;
+	else if ((int)i >= length)
+		default_away = g_slist_nth_data(away_messages, length - 1);
+	else
+		default_away = g_slist_nth_data(away_messages, (int)i);
+}
+
+void default_away_menu_init(GtkWidget *omenu)
+{
+	GtkWidget *menu, *opt;
+	int index = 0;
+	GSList *awy = away_messages;
+	struct away_message *a;
+
+	menu = gtk_menu_new();
+
+	while (awy) {
+		a = (struct away_message *)awy->data;
+		opt = gtk_menu_item_new_with_label(a->name);
+		gtk_signal_connect(GTK_OBJECT(opt), "activate", GTK_SIGNAL_FUNC(set_default_away),
+				   (gpointer)index);
+		gtk_widget_show(opt);
+		gtk_menu_append(GTK_MENU(menu), opt);
+
+		awy = awy->next;
+		index++;
+	}
+
+	gtk_option_menu_remove_menu(GTK_OPTION_MENU(omenu));
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(omenu), menu);
+	gtk_option_menu_set_history(GTK_OPTION_MENU(omenu), g_slist_index(away_messages, default_away));
+}
+
+static void away_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *frame;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *vbox2;
+	GtkWidget *button;
+	GtkWidget *button2;
+	GtkWidget *top;
+	GtkWidget *bot;
+	GtkWidget *sw;
+	GtkWidget *sw2;
+	GtkWidget *list_item;
+	GtkWidget *sep;
+	GtkObject *adjust;
+	GtkWidget *spin;
+	GSList *awy = away_messages;
+	struct away_message *a;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	prefdialog = gtk_frame_new(_("Away Messages"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	frame = gtk_frame_new(_("Options"));
+	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, FALSE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	hbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	vbox2 = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	gaim_button(_("Ignore new conversations when away"), &away_options, OPT_AWAY_DISCARD, vbox2);
+	gaim_button(_("Sounds while away"), &sound_options, OPT_SOUND_WHEN_AWAY, vbox2);
+	gaim_button(_("Sending messages removes away status"), &away_options, OPT_AWAY_BACK_ON_IM,
+		    vbox2);
+
+	vbox2 = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox2, TRUE, TRUE, 5);
+	gtk_widget_show(vbox2);
+
+	button = gaim_button(_("Don't send auto-response"), &away_options, OPT_AWAY_NO_AUTO_RESP, vbox2);
+	button2 = gaim_button(_("Only send auto-response when idle"), &away_options, OPT_AWAY_IDLE_RESP,
+			      vbox2);
+	if (away_options & OPT_AWAY_NO_AUTO_RESP)
+		gtk_widget_set_sensitive(button2, FALSE);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), button2);
+	gaim_button(_("Queue new messages when away"), &away_options, OPT_AWAY_QUEUE, vbox2);
+
+	sep = gtk_hseparator_new();
+	gtk_box_pack_start(GTK_BOX(vbox), sep, FALSE, FALSE, 0);
+	gtk_widget_show(sep);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	gaim_labeled_spin_button(hbox, _("Time between sending auto-responses (in seconds):"),
+			&away_resend, 1, 24 * 60 * 60);
+
+	if (away_options & OPT_AWAY_NO_AUTO_RESP)
+		gtk_widget_set_sensitive(hbox, FALSE);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), hbox);
+
+	sep = gtk_hseparator_new();
+	gtk_box_pack_start(GTK_BOX(vbox), sep, FALSE, FALSE, 0);
+	gtk_widget_show(sep);
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	button = gaim_button(_("Auto Away after"), &away_options, OPT_AWAY_AUTO, hbox);
+
+	adjust = gtk_adjustment_new(auto_away, 1, 1440, 1, 10, 10);
+	spin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);
+	gtk_widget_set_usize(spin, 50, -1);
+	gtk_object_set_user_data(GTK_OBJECT(spin), &auto_away);
+	if (!(away_options & OPT_AWAY_AUTO))
+		gtk_widget_set_sensitive(GTK_WIDGET(spin), FALSE);
+	gtk_box_pack_start(GTK_BOX(hbox), spin, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive), spin);
+	gtk_signal_connect(GTK_OBJECT(adjust), "value-changed", GTK_SIGNAL_FUNC(update_spin_value),
+			   GTK_WIDGET(spin));
+	gtk_widget_show(spin);
+
+	label = gtk_label_new(_("minutes using"));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+	gtk_widget_show(label);
+
+	prefs_away_menu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(hbox), prefs_away_menu, FALSE, FALSE, 0);
+	default_away_menu_init(prefs_away_menu);
+	if (!(away_options & OPT_AWAY_AUTO))
+		gtk_widget_set_sensitive(GTK_WIDGET(prefs_away_menu), FALSE);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(toggle_sensitive),
+			   prefs_away_menu);
+	gtk_widget_show(prefs_away_menu);
+
+	frame = gtk_frame_new(_("Messages"));
+	gtk_box_pack_start(GTK_BOX(box), frame, TRUE, TRUE, 5);
+	gtk_widget_show(frame);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	hbox = gtk_hbox_new(TRUE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new(_("Title"));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	label = gtk_label_new(_("Message"));
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	top = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), top, TRUE, TRUE, 0);
+	gtk_widget_show(top);
+
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw),
+				       GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(top), sw, TRUE, TRUE, 0);
+	gtk_widget_set_usize(sw, -1, 225);
+	gtk_widget_show(sw);
+
+	prefs_away_list = gtk_list_new();
+	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(sw), prefs_away_list);
+	gtk_signal_connect(GTK_OBJECT(prefs_away_list), "destroy", GTK_SIGNAL_FUNC(paldest), 0);
+	gtk_widget_show(prefs_away_list);
+
+	sw2 = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2),
+				       GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+	gtk_box_pack_start(GTK_BOX(top), sw2, TRUE, TRUE, 0);
+	gtk_widget_show(sw2);
+
+	away_text = gtk_imhtml_new(NULL, NULL);
+	gtk_container_add(GTK_CONTAINER(sw2), away_text);
+	GTK_LAYOUT(away_text)->hadjustment->step_increment = 10.0;
+	GTK_LAYOUT(away_text)->vadjustment->step_increment = 10.0;
+	gaim_setup_imhtml(away_text);
+	gtk_widget_show(away_text);
+
+	bot = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), bot, FALSE, FALSE, 5);
+	gtk_widget_show(bot);
+
+	button = picture_button(prefs, _("Add"), gnome_add_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(create_away_mess), NULL);
+	gtk_box_pack_start(GTK_BOX(bot), button, TRUE, FALSE, 5);
+
+	button = picture_button(prefs, _("Edit"), save_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(create_away_mess), button);
+	gtk_box_pack_start(GTK_BOX(bot), button, TRUE, FALSE, 5);
+
+	make_away_button = picture_button(prefs, _("Make Away"), gnome_preferences_xpm);
+	gtk_signal_connect(GTK_OBJECT(make_away_button), "clicked", GTK_SIGNAL_FUNC(do_away_mess), NULL);
+	gtk_box_pack_start(GTK_BOX(bot), make_away_button, TRUE, FALSE, 5);
+	if (!connections)
+		gtk_widget_set_sensitive(make_away_button, FALSE);
+
+	button = picture_button(prefs, _("Remove"), gnome_remove_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(remove_away_message), NULL);
+	gtk_box_pack_start(GTK_BOX(bot), button, TRUE, FALSE, 5);
+
+	if (awy != NULL) {
+		char buffer[BUF_LONG];
+		char *tmp;
+		a = (struct away_message *)awy->data;
+		g_snprintf(buffer, sizeof(buffer), "%s", a->message);
+		tmp = stylize(buffer, BUF_LONG);
+		gtk_imhtml_append_text(GTK_IMHTML(away_text), tmp, -1, GTK_IMHTML_NO_TITLE |
+				       GTK_IMHTML_NO_COMMENTS | GTK_IMHTML_NO_SCROLL);
+		gtk_imhtml_append_text(GTK_IMHTML(away_text), "<BR>", -1, GTK_IMHTML_NO_TITLE |
+				       GTK_IMHTML_NO_COMMENTS | GTK_IMHTML_NO_SCROLL);
+		g_free(tmp);
+	}
+
+	while (awy) {
+		a = (struct away_message *)awy->data;
+		list_item = gtk_list_item_new();
+		gtk_container_add(GTK_CONTAINER(prefs_away_list), list_item);
+		gtk_signal_connect(GTK_OBJECT(list_item), "select", GTK_SIGNAL_FUNC(away_list_clicked),
+				   a);
+		gtk_object_set_user_data(GTK_OBJECT(list_item), a);
+		gtk_widget_show(list_item);
+
+		hbox = gtk_hbox_new(FALSE, 5);
+		gtk_container_add(GTK_CONTAINER(list_item), hbox);
+		gtk_widget_show(hbox);
+
+		label = gtk_label_new(a->name);
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 5);
+		gtk_widget_show(label);
+
+		awy = awy->next;
+	}
+	if (away_messages != NULL)
+		gtk_list_select_item(GTK_LIST(prefs_away_list), 0);
+
+	gtk_widget_show(prefdialog);
+}
+
+static GtkWidget *deny_type = NULL;
+static GtkWidget *deny_conn_hbox = NULL;
+static GtkWidget *deny_opt_menu = NULL;
+static struct gaim_connection *current_deny_gc = NULL;
+static gboolean current_is_deny = FALSE;
+static GtkWidget *allow_list = NULL;
+static GtkWidget *block_list = NULL;
+
+static void set_deny_mode(GtkWidget *w, int data)
+{
+	if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)))
+		return;
+	debug_printf("setting deny mode %d\n", data);
+	current_deny_gc->permdeny = data;
+	serv_set_permit_deny(current_deny_gc);
+	do_export(current_deny_gc);
+}
+
+static GtkWidget *deny_opt(char *label, int which, GtkWidget *box, GtkWidget *set)
+{
+	GtkWidget *opt;
+
+	if (!set)
+		opt = gtk_radio_button_new_with_label(NULL, label);
+	else
+		opt =
+		    gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)),
+						    label);
+	gtk_box_pack_start(GTK_BOX(box), opt, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(opt), "toggled", GTK_SIGNAL_FUNC(set_deny_mode), (void *)which);
+	gtk_widget_show(opt);
+	if (current_deny_gc->permdeny == which)
+		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(opt), TRUE);
+
+	return opt;
+}
+
+static void des_deny_opt(GtkWidget *d, gpointer e)
+{
+	gtk_widget_destroy(d);
+	current_deny_gc = NULL;
+	deny_conn_hbox = NULL;
+	deny_type = NULL;
+	deny_opt_menu = NULL;
+	current_is_deny = FALSE;
+	allow_list = NULL;
+	block_list = NULL;
+}
+
+static void set_deny_type()
+{
+	GSList *bg = gtk_radio_button_group(GTK_RADIO_BUTTON(deny_type));
+
+	switch (current_deny_gc->permdeny) {
+	case 4:
+		break;
+	case 3:
+		bg = bg->next->next;
+		break;
+	case 2:
+		bg = bg->next;
+		break;
+	case 1:
+		bg = bg->next->next->next;
+		break;
+	}
+
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(bg->data), TRUE);
+}
+
+void build_allow_list()
+{
+	GtkWidget *label;
+	GtkWidget *list_item;
+	GSList *p;
+
+	if (!current_is_deny)
+		return;
+
+	p = current_deny_gc->permit;
+
+	gtk_list_remove_items(GTK_LIST(allow_list), GTK_LIST(allow_list)->children);
+
+	while (p) {
+		label = gtk_label_new(p->data);
+		list_item = gtk_list_item_new();
+		gtk_container_add(GTK_CONTAINER(list_item), label);
+		gtk_object_set_user_data(GTK_OBJECT(list_item), p->data);
+		gtk_widget_show(label);
+		gtk_container_add(GTK_CONTAINER(allow_list), list_item);
+		gtk_widget_show(list_item);
+		p = p->next;
+	}
+}
+
+void build_block_list()
+{
+	GtkWidget *label;
+	GtkWidget *list_item;
+	GSList *d;
+
+	if (!current_is_deny)
+		return;
+
+	d = current_deny_gc->deny;
+
+	gtk_list_remove_items(GTK_LIST(block_list), GTK_LIST(block_list)->children);
+
+	while (d) {
+		label = gtk_label_new(d->data);
+		list_item = gtk_list_item_new();
+		gtk_container_add(GTK_CONTAINER(list_item), label);
+		gtk_object_set_user_data(GTK_OBJECT(list_item), d->data);
+		gtk_widget_show(label);
+		gtk_container_add(GTK_CONTAINER(block_list), list_item);
+		gtk_widget_show(list_item);
+		d = d->next;
+	}
+}
+
+static void deny_gc_opt(GtkWidget *opt, struct gaim_connection *gc)
+{
+	current_deny_gc = gc;
+	set_deny_type();
+	build_allow_list();
+	build_block_list();
+}
+
+static void build_deny_menu()
+{
+	GtkWidget *menu;
+	GtkWidget *opt;
+	GSList *c = connections;
+	struct gaim_connection *gc;
+	int count = 0;
+	gboolean found = FALSE;
+	char buf[2048];
+
+	if (g_slist_length(connections) == 1) {
+		gtk_widget_hide(deny_conn_hbox);
+		return;
+	} else
+		gtk_widget_show(deny_conn_hbox);
+
+	menu = gtk_menu_new();
+
+	while (c) {
+		gc = (struct gaim_connection *)c->data;
+		c = c->next;
+		if (!gc->prpl->set_permit_deny)
+			continue;
+		g_snprintf(buf, sizeof buf, "%s (%s)", gc->username, gc->prpl->name());
+		opt = gtk_menu_item_new_with_label(buf);
+		gtk_signal_connect(GTK_OBJECT(opt), "activate", GTK_SIGNAL_FUNC(deny_gc_opt), gc);
+		gtk_widget_show(opt);
+		gtk_menu_append(GTK_MENU(menu), opt);
+		if (gc == current_deny_gc)
+			found = TRUE;
+		else if (!found)
+			count++;
+	}
+
+	if (!found) {
+		current_deny_gc = connections->data;
+		count = 0;
+	}
+
+	gtk_option_menu_remove_menu(GTK_OPTION_MENU(deny_opt_menu));
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(deny_opt_menu), menu);
+	gtk_option_menu_set_history(GTK_OPTION_MENU(deny_opt_menu), count);
+
+	gtk_widget_show(menu);
+	gtk_widget_show(deny_opt_menu);
+}
+
+static void pref_deny_add(GtkWidget *button, gboolean permit)
+{
+	show_add_perm(current_deny_gc, NULL, permit);
+}
+
+static void pref_deny_rem(GtkWidget *button, gboolean permit)
+{
+	GList *i;
+	char *who;
+
+	if (permit && !allow_list)
+		return;
+	if (!permit && !block_list)
+		return;
+
+	if (permit)
+		i = GTK_LIST(allow_list)->selection;
+	else
+		i = GTK_LIST(block_list)->selection;
+
+	if (!i)
+		return;
+	who = gtk_object_get_user_data(GTK_OBJECT(i->data));
+	if (permit) {
+		current_deny_gc->permit = g_slist_remove(current_deny_gc->permit, who);
+		serv_rem_permit(current_deny_gc, who);
+		build_allow_list();
+	} else {
+		current_deny_gc->deny = g_slist_remove(current_deny_gc->deny, who);
+		serv_rem_deny(current_deny_gc, who);
+		build_block_list();
+	}
+
+	do_export(current_deny_gc);
+}
+
+static void deny_page()
+{
+	GtkWidget *parent;
+	GtkWidget *box;
+	GtkWidget *hbox;
+	GtkWidget *label;
+	GtkWidget *vbox;
+	GtkWidget *sw;
+	GtkWidget *bbox;
+	GtkWidget *button;
+
+	parent = prefdialog->parent;
+	gtk_widget_destroy(prefdialog);
+
+	current_deny_gc = connections->data;	/* this is safe because this screen will only be
+						   available when there are connections */
+	current_is_deny = TRUE;
+
+	prefdialog = gtk_frame_new(_("Privacy Options"));
+	gtk_container_add(GTK_CONTAINER(parent), prefdialog);
+
+	box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(box), 5);
+	gtk_container_add(GTK_CONTAINER(prefdialog), box);
+	gtk_widget_show(box);
+
+	label = gtk_label_new(_("All options take effect immediately unless otherwise noted."));
+	gtk_box_pack_start(GTK_BOX(box), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	deny_conn_hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(box), deny_conn_hbox, FALSE, FALSE, 0);
+	gtk_widget_show(deny_conn_hbox);
+
+	label = gtk_label_new(_("Set privacy for:"));
+	gtk_box_pack_start(GTK_BOX(deny_conn_hbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	deny_opt_menu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(deny_conn_hbox), deny_opt_menu, FALSE, FALSE, 5);
+	gtk_signal_connect(GTK_OBJECT(deny_opt_menu), "destroy", GTK_SIGNAL_FUNC(des_deny_opt), NULL);
+	gtk_widget_show(deny_opt_menu);
+
+	build_deny_menu();
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(box), hbox, TRUE, TRUE, 5);
+	gtk_widget_show(hbox);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	deny_type = deny_opt(_("Allow all users to contact me"), 1, vbox, NULL);
+	deny_type = deny_opt(_("Allow only the users below"), 3, vbox, deny_type);
+
+	label = gtk_label_new(_("Allow List"));
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(vbox), sw, TRUE, TRUE, 5);
+	gtk_widget_show(sw);
+
+	allow_list = gtk_list_new();
+	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(sw), allow_list);
+	gtk_widget_show(allow_list);
+
+	build_allow_list();
+
+	bbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_end(GTK_BOX(vbox), bbox, FALSE, FALSE, 5);
+	gtk_widget_show(bbox);
+
+	button = picture_button(prefs, _("Add"), gnome_add_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(pref_deny_add), (void *)TRUE);
+	gtk_box_pack_start(GTK_BOX(bbox), button, FALSE, FALSE, 5);
+
+	button = picture_button(prefs, _("Remove"), gnome_remove_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(pref_deny_rem), (void *)TRUE);
+	gtk_box_pack_start(GTK_BOX(bbox), button, FALSE, FALSE, 5);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, TRUE, TRUE, 5);
+	gtk_widget_show(vbox);
+
+	deny_type = deny_opt(_("Deny all users"), 2, vbox, deny_type);
+	deny_type = deny_opt(_("Block the users below"), 4, vbox, deny_type);
+
+	label = gtk_label_new(_("Block List"));
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+	gtk_widget_show(label);
+
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(vbox), sw, TRUE, TRUE, 5);
+	gtk_widget_show(sw);
+
+	block_list = gtk_list_new();
+	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(sw), block_list);
+	gtk_widget_show(block_list);
+
+	build_block_list();
+
+	bbox = gtk_hbox_new(TRUE, 5);
+	gtk_box_pack_end(GTK_BOX(vbox), bbox, FALSE, FALSE, 5);
+	gtk_widget_show(bbox);
+
+	button = picture_button(prefs, _("Add"), gnome_add_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(pref_deny_add), FALSE);
+	gtk_box_pack_start(GTK_BOX(bbox), button, FALSE, FALSE, 5);
+
+	button = picture_button(prefs, _("Remove"), gnome_remove_xpm);
+	gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(pref_deny_rem), FALSE);
+	gtk_box_pack_start(GTK_BOX(bbox), button, FALSE, FALSE, 5);
+
+	gtk_widget_show(prefdialog);
+}
+
+void update_connection_dependent_prefs()
+{				/* what a crappy name */
+	gboolean needdeny = FALSE;
+	GSList *c = connections;
+	struct gaim_connection *gc = NULL;
+
+	if (!prefs)
+		return;
+
+	while (c) {
+		gc = c->data;
+		if (gc->prpl->set_permit_deny)
+			break;
+		gc = NULL;
+		c = c->next;
+	}
+	needdeny = (gc != NULL);
+
+	if (!needdeny && deny_node) {
+		if (current_is_deny)
+			gtk_ctree_select(GTK_CTREE(preftree), general_node);
+		gtk_ctree_remove_node(GTK_CTREE(preftree), deny_node);
+		deny_node = NULL;
+	} else if (deny_node && current_is_deny) {
+		build_deny_menu();
+		build_allow_list();
+		build_block_list();
+	} else if (needdeny && !deny_node) {
+		prefs_build_deny();
+	}
+
+	if (make_away_button) {
+		if (connections)
+			gtk_widget_set_sensitive(make_away_button, TRUE);
+		else
+			gtk_widget_set_sensitive(make_away_button, FALSE);
+	}
+}
+
+static void try_me(GtkCTree *ctree, GtkCTreeNode *node)
+{
+	/* this is a hack */
+	void (*func)();
+	func = gtk_ctree_node_get_row_data(ctree, node);
+	func();
+}
+
+void show_prefs()
+{
+	GtkWidget *vbox;
+	GtkWidget *hpaned;
+	/* GtkWidget *scroll; */
+	GtkWidget *container;
+	GtkWidget *hbox;
+	GtkWidget *close;
+
+	if (prefs) {
+		gtk_widget_show(prefs);
+		return;
+	}
+
+	prefs = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	gtk_window_set_wmclass(GTK_WINDOW(prefs), "preferences", "Gaim");
+	gtk_widget_realize(prefs);
+	aol_icon(prefs->window);
+	gtk_window_set_title(GTK_WINDOW(prefs), _("Gaim - Preferences"));
+	gtk_widget_set_usize(prefs, 725, 620);
+	gtk_signal_connect(GTK_OBJECT(prefs), "destroy", GTK_SIGNAL_FUNC(delete_prefs), NULL);
+
+	vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_border_width(GTK_CONTAINER(vbox), 5);
+	gtk_container_add(GTK_CONTAINER(prefs), vbox);
+	gtk_widget_show(vbox);
+
+	hpaned = gtk_hpaned_new();
+	gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
+	gtk_widget_show(hpaned);
+
+	/*
+	scroll = gtk_scrolled_window_new(NULL, NULL);
+	gtk_paned_pack1(GTK_PANED(hpaned), scroll, FALSE, FALSE);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_NEVER, GTK_POLICY_NEVER);
+	gtk_widget_set_usize(scroll, 125, -1);
+	gtk_widget_show(scroll);
+	*/
+
+	preftree = gtk_ctree_new(1, 0);
+	gtk_ctree_set_line_style(GTK_CTREE(preftree), GTK_CTREE_LINES_SOLID);
+	gtk_ctree_set_expander_style(GTK_CTREE(preftree), GTK_CTREE_EXPANDER_TRIANGLE);
+	gtk_clist_set_reorderable(GTK_CLIST(preftree), FALSE);
+	/* gtk_container_add(GTK_CONTAINER(scroll), preftree); */
+	gtk_paned_pack1(GTK_PANED(hpaned), preftree, FALSE, FALSE);
+	gtk_signal_connect(GTK_OBJECT(preftree), "tree_select_row", GTK_SIGNAL_FUNC(try_me), NULL);
+	gtk_widget_set_usize(preftree, 125, -1);
+	gtk_widget_show(preftree);
+
+	container = gtk_frame_new(NULL);
+	gtk_container_set_border_width(GTK_CONTAINER(container), 0);
+	gtk_frame_set_shadow_type(GTK_FRAME(container), GTK_SHADOW_NONE);
+	gtk_paned_pack2(GTK_PANED(hpaned), container, TRUE, TRUE);
+	gtk_widget_show(container);
+
+	prefdialog = gtk_vbox_new(FALSE, 5);
+	gtk_container_add(GTK_CONTAINER(container), prefdialog);
+	gtk_widget_show(prefdialog);
+
+	prefs_build_general();
+	prefs_build_buddy();
+	prefs_build_convo();
+	prefs_build_sound();
+	prefs_build_away();
+	prefs_build_deny();
+
+	/* general_page(); */
+
+	hbox = gtk_hbox_new(FALSE, 5);
+	gtk_box_pack_end(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	close = picture_button(prefs, _("Close"), cancel_xpm);
+	gtk_box_pack_end(GTK_BOX(hbox), close, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(close), "clicked", GTK_SIGNAL_FUNC(handle_delete), NULL);
+
+	gtk_widget_show(prefs);
+}
+
+static gint debug_delete(GtkWidget *w, GdkEvent *event, void *dummy)
+{
+	if (debugbutton)
+		gtk_button_clicked(GTK_BUTTON(debugbutton));
+	if (misc_options & OPT_MISC_DEBUG) {
+		misc_options ^= OPT_MISC_DEBUG;
+		save_prefs();
+	}
+	g_free(dw);
+	dw = NULL;
+	return FALSE;
+
+}
+
+static void build_debug()
+{
+	GtkWidget *scroll;
+	GtkWidget *box;
+	if (!dw)
+		dw = g_new0(struct debug_window, 1);
+
+	GAIM_DIALOG(dw->window);
+	gtk_window_set_title(GTK_WINDOW(dw->window), _("Gaim debug output window"));
+	gtk_window_set_wmclass(GTK_WINDOW(dw->window), "debug_out", "Gaim");
+	gtk_signal_connect(GTK_OBJECT(dw->window), "delete_event", GTK_SIGNAL_FUNC(debug_delete), NULL);
+	gtk_widget_realize(dw->window);
+	aol_icon(dw->window->window);
+
+	box = gtk_hbox_new(FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(dw->window), box);
+	gtk_widget_show(box);
+
+	dw->entry = gtk_text_new(NULL, NULL);
+	gtk_text_set_word_wrap(GTK_TEXT(dw->entry), TRUE);
+	gtk_text_set_editable(GTK_TEXT(dw->entry), FALSE);
+	gtk_container_add(GTK_CONTAINER(box), dw->entry);
+	gtk_widget_set_usize(dw->entry, 500, 200);
+	gtk_widget_show(dw->entry);
+
+	scroll = gtk_vscrollbar_new(GTK_TEXT(dw->entry)->vadj);
+	gtk_box_pack_start(GTK_BOX(box), scroll, FALSE, FALSE, 0);
+	gtk_widget_show(scroll);
+
+	gtk_widget_show(dw->window);
+}
+
+void show_debug()
+{
+	if ((misc_options & OPT_MISC_DEBUG)) {
+		if (!dw || !dw->window)
+			build_debug();
+		gtk_widget_show(dw->window);
+	} else {
+		if (!dw)
+			return;
+		gtk_widget_destroy(dw->window);
+		dw->window = NULL;
+	}
+}
+
+void debug_printf(char *fmt, ...)
+{
+	va_list ap;
+	gchar *s;
+
+	va_start(ap, fmt);
+	s = g_strdup_vprintf(fmt, ap);
+	va_end(ap);
+
+	if (misc_options & OPT_MISC_DEBUG && dw) {
+		GtkAdjustment *adj = GTK_TEXT(dw->entry)->vadj;
+		gboolean scroll = (adj->value == adj->upper - adj->lower - adj->page_size);
+
+		gtk_text_freeze(GTK_TEXT(dw->entry));
+		gtk_text_insert(GTK_TEXT(dw->entry), NULL, NULL, NULL, s, -1);
+		gtk_text_thaw(GTK_TEXT(dw->entry));
+
+		if (scroll)
+			gtk_adjustment_set_value(adj, adj->upper - adj->lower - adj->page_size);
+	}
+	if (opt_debug)
+		g_print("%s", s);
+	g_free(s);
+}
+
+static gint handle_delete(GtkWidget *w, GdkEvent *event, void *dummy)
+{
+	save_prefs();
+
+	if (event == NULL)
+		gtk_widget_destroy(prefs);
+	prefs = NULL;
+	prefdialog = NULL;
+	debugbutton = NULL;
+	prefs_away_menu = NULL;
+
+	return FALSE;
+}
+
+static void delete_prefs(GtkWidget *w, void *data)
+{
+	if (prefs) {
+		save_prefs();
+		gtk_widget_destroy(prefs);
+	}
+	prefs = NULL;
+	prefs_away_menu = NULL;
+	deny_node = NULL;
+	current_deny_gc = NULL;
+}
+
+
+void set_option(GtkWidget *w, int *option)
+{
+	*option = !(*option);
+}
+
+static void set_misc_option(GtkWidget *w, int option)
+{
+	misc_options ^= option;
+
+	if (option == OPT_MISC_DEBUG)
+		show_debug();
+
+	if (option == OPT_MISC_BUDDY_TICKER)
+		BuddyTickerShow();
+
+	save_prefs();
+}
+
+static void set_logging_option(GtkWidget *w, int option)
+{
+	logging_options ^= option;
+
+	if (option == OPT_LOG_ALL)
+		update_log_convs();
+
+	save_prefs();
+}
+
+static void set_blist_option(GtkWidget *w, int option)
+{
+	blist_options ^= option;
+
+	save_prefs();
+
+	if (!blist)
+		return;
+
+	if (option == OPT_BLIST_NO_BUTTONS)
+		build_imchat_box(!(blist_options & OPT_BLIST_NO_BUTTONS));
+
+	if (option == OPT_BLIST_SHOW_GRPNUM)
+		update_num_groups();
+
+	if (option == OPT_BLIST_NO_MT_GRP)
+		toggle_show_empty_groups();
+
+	if ((option == OPT_BLIST_SHOW_BUTTON_XPM) || (option == OPT_BLIST_NO_BUTTONS))
+		update_button_pix();
+
+	if (option == OPT_BLIST_SHOW_PIXMAPS)
+		toggle_buddy_pixmaps();
+
+	if ((option == OPT_BLIST_GREY_IDLERS) || (option == OPT_BLIST_SHOW_IDLETIME))
+		update_idle_times();
+
+}
+
+static void set_convo_option(GtkWidget *w, int option)
+{
+	convo_options ^= option;
+
+	if (option == OPT_CONVO_SHOW_SMILEY)
+		toggle_smileys();
+
+	if (option == OPT_CONVO_SHOW_TIME)
+		toggle_timestamps();
+
+	if (option == OPT_CONVO_CHECK_SPELLING)
+		toggle_spellchk();
+
+	if (option == OPT_CONVO_COMBINE) {
+		/* (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB) == (OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB) */
+		if (current_is_im) {
+			int set = im_options & (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB);
+			chat_options &= ~(OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB);
+			chat_options |= set;
+		} else {
+			int set = chat_options & (OPT_IM_SIDE_TAB | OPT_IM_BR_TAB);
+			im_options &= ~(OPT_CHAT_SIDE_TAB | OPT_CHAT_BR_TAB);
+			im_options |= set;
+		}
+		convo_tabize();
+	}
+
+	save_prefs();
+}
+
+static void set_im_option(GtkWidget *w, int option)
+{
+	im_options ^= option;
+
+	if (option == OPT_IM_ONE_WINDOW)
+		im_tabize();
+
+	if (option == OPT_IM_HIDE_ICONS)
+		set_hide_icons();
+
+	if (option == OPT_IM_ALIAS_TAB)
+		set_convo_titles();
+
+	if (option == OPT_IM_NO_ANIMATION)
+		set_anim();
+
+	save_prefs();
+}
+
+static void set_chat_option(GtkWidget *w, int option)
+{
+	chat_options ^= option;
+
+	if (option == OPT_CHAT_ONE_WINDOW)
+		chat_tabize();
+
+	save_prefs();
+}
+
+void set_sound_option(GtkWidget *w, int option)
+{
+	sound_options ^= option;
+
+	save_prefs();
+}
+
+static void set_font_option(GtkWidget *w, int option)
+{
+	font_options ^= option;
+
+	update_font_buttons();
+
+	save_prefs();
+}
+
+static void set_away_option(GtkWidget *w, int option)
+{
+	away_options ^= option;
+
+	if (option == OPT_AWAY_QUEUE)
+		toggle_away_queue();
+
+	save_prefs();
+}
+
+GtkWidget *gaim_button(const char *text, guint *options, int option, GtkWidget *page)
+{
+	GtkWidget *button;
+	button = gtk_check_button_new_with_label(text);
+	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(button), (*options & option));
+	gtk_box_pack_start(GTK_BOX(page), button, FALSE, FALSE, 0);
+
+	if (options == &misc_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_misc_option),
+				   (int *)option);
+	if (options == &logging_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_logging_option),
+				   (int *)option);
+	if (options == &blist_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_blist_option),
+				   (int *)option);
+	if (options == &convo_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_convo_option),
+				   (int *)option);
+	if (options == &im_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_im_option),
+				   (int *)option);
+	if (options == &chat_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_chat_option),
+				   (int *)option);
+	if (options == &font_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_font_option),
+				   (int *)option);
+	if (options == &sound_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_sound_option),
+				   (int *)option);
+	if (options == &away_options)
+		gtk_signal_connect(GTK_OBJECT(button), "clicked", GTK_SIGNAL_FUNC(set_away_option),
+				   (int *)option);
+
+	gtk_widget_show(button);
+
+	return button;
+}
+
+static void blist_tab_opt(GtkWidget *widget, int option)
+{
+	/* Following general method of set_tab_opt()  */
+	int mask;
+	mask = (OPT_BLIST_BOTTOM_TAB);
+	
+	blist_options &= ~(mask);
+	blist_options |= (mask & option);	
+	
+	set_blist_tab();
+}
+
+static GtkWidget *blist_tab_radio(const char *label, int which, GtkWidget *box,GtkWidget *set) 
+{
+        GtkWidget *new_opt;
+
+        if(!set)
+                new_opt = gtk_radio_button_new_with_label (NULL, label);        
+	else
+                new_opt = gtk_radio_button_new_with_label(gtk_radio_button_group(GTK_RADIO_BUTTON(set)), label); 
+        
+	gtk_box_pack_start(GTK_BOX(box), new_opt, FALSE, FALSE, 0);
+        gtk_signal_connect(GTK_OBJECT(new_opt), "clicked", 
+			GTK_SIGNAL_FUNC(blist_tab_opt), (void *)which);
+	gtk_widget_show(new_opt);
+
+        if ((blist_options & OPT_BLIST_BOTTOM_TAB) == (which & OPT_BLIST_BOTTOM_TAB))
+                gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(new_opt), TRUE);
+
+	return new_opt;        
+}
+
+void prefs_build_general()
+{
+	GtkCTreeNode *node;
+	char *text[1];
+
+	text[0] = _("General");
+	general_node = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+					     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), general_node, general_page);
+
+	text[0] = _("Proxy");
+	node = gtk_ctree_insert_node(GTK_CTREE(preftree), general_node, NULL,
+				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, proxy_page);
+
+	gtk_ctree_select(GTK_CTREE(preftree), general_node);
+}
+
+void prefs_build_buddy()
+{
+	GtkCTreeNode *parent;
+	char *text[1];
+
+	text[0] = _("Buddy List");
+	parent = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+				       text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), parent, buddy_page);
+}
+
+void prefs_build_convo()
+{
+	GtkCTreeNode *parent, *node;
+	char *text[1];
+
+	text[0] = _("Conversations");
+	parent = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+				       text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), parent, convo_page);
+
+	text[0] = _("IM Window");
+	node = gtk_ctree_insert_node(GTK_CTREE(preftree), parent, NULL,
+				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, im_page);
+
+	text[0] = _("Chat");
+	node = gtk_ctree_insert_node(GTK_CTREE(preftree), parent, NULL,
+				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, chat_page);
+
+	text[0] = _("Font Options");
+	node = gtk_ctree_insert_node(GTK_CTREE(preftree), parent, NULL,
+				     text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), node, font_page);
+}
+
+void prefs_build_sound()
+{
+	GtkCTreeNode *parent;
+	char *text[1];
+
+	text[0] = _("Sounds");
+	parent = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+				       text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), parent, sound_page);
+}
+
+void prefs_build_away()
+{
+	GtkCTreeNode *parent;
+	char *text[1];
+
+	text[0] = _("Away Messages");
+	parent = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+				       text, 5, NULL, NULL, NULL, NULL, 0, 1);
+	gtk_ctree_node_set_row_data(GTK_CTREE(preftree), parent, away_page);
+}
+
+void prefs_build_deny()
+{
+	char *text[1];
+
+	if (connections && !deny_node) {
+		text[0] = _("Privacy");
+		deny_node = gtk_ctree_insert_node(GTK_CTREE(preftree), NULL, NULL,
+						  text, 5, NULL, NULL, NULL, NULL, 0, 1);
+		gtk_ctree_node_set_row_data(GTK_CTREE(preftree), deny_node, deny_page);
+	}
+}
diff -Nru gaim-0.58/src/server.c gaim-0.58-t/src/server.c
--- gaim-0.58/src/server.c	Tue Apr 23 12:30:09 2002
+++ gaim-0.58-t/src/server.c	Wed Jun 12 20:09:47 2002
@@ -1061,6 +1061,11 @@
 	gtk_box_pack_start(GTK_BOX(vbox), sw, TRUE, TRUE, 5);
 
 	text = gtk_imhtml_new(NULL, NULL);
+
+#if 0
+	gtk_imhtml_set_background(GTK_IMHTML(text), NULL, 1, 1);
+#endif
+
 	gtk_container_add(GTK_CONTAINER(sw), text);
 	GTK_LAYOUT(text)->hadjustment->step_increment = 10.0;
 	GTK_LAYOUT(text)->vadjustment->step_increment = 10.0;
diff -Nru gaim-0.58/src/ui.h gaim-0.58-t/src/ui.h
--- gaim-0.58/src/ui.h	Sat May  4 04:21:31 2002
+++ gaim-0.58-t/src/ui.h	Wed Jun 12 20:10:24 2002
@@ -36,6 +36,7 @@
 #if USE_PIXBUF
 #include <gdk-pixbuf/gdk-pixbuf.h>
 #endif
+#include "gtkimhtml.h"
 
 #if GTK_CHECK_VERSION(1,3,0)
 #define GAIM_DIALOG(x)	x = gtk_window_new(GTK_WINDOW_TOPLEVEL); \
@@ -123,8 +124,10 @@
 	GtkWidget *font;
 	GtkWidget *smiley;
 	GtkWidget *imagebtn;
-	GtkWidget *fg_color_dialog;
-	GtkWidget *bg_color_dialog;
+	GtkWidget *out_fg_color_dialog;
+	GtkWidget *out_bg_color_dialog;
+	GtkWidget *def_fg_color_dialog;
+	GtkWidget *def_bg_color_dialog;
 	GtkWidget *font_dialog;
 	GtkWidget *smiley_dialog;
 	GtkWidget *link_dialog;
@@ -133,10 +136,14 @@
 	char fontface[128];
 	char fontxfld[256];
 	int hasfont;
-	GdkColor bgcol;
-	int hasbg;
-	GdkColor fgcol;
-	int hasfg;
+	GdkColor out_bgcol;
+	int has_out_bg;
+	GdkColor out_fgcol;
+	int has_out_fg;
+	GdkColor def_bgcol;
+	int has_def_bg;
+	GdkColor def_fgcol;
+	int has_def_fg;
 
 	GList *send_history;
 	GString *history;
@@ -296,10 +303,15 @@
 extern char fontface[128];
 extern char fontxfld[256];
 extern int fontsize;
-extern GdkColor bgcolor;
-extern GdkColor fgcolor;
+extern GdkColor out_bgcolor;
+extern GdkColor out_fgcolor;
+extern GdkColor def_bgcolor;
+extern GdkColor def_fgcolor;
 extern int smiley_array[FACE_TOTAL];
 
+/* Globals in gtkimhtml.c */
+extern GdkColor trans_tint;
+
 /* Globals in prefs.c */
 extern struct debug_window *dw;
 
@@ -381,6 +393,7 @@
 extern void remove_tags(GtkWidget *, char *);
 extern void update_log_convs();
 extern void update_transparency();
+extern void update_tints();
 extern void update_font_buttons();
 extern void toggle_sensitive(GtkWidget *widget, GtkWidget *to_toggle);
 extern void do_bold(GtkWidget *, GtkWidget *);
@@ -428,8 +441,10 @@
 extern void show_new_bp(char *, struct gaim_connection *, int, int, struct buddy_pounce *);
 extern void show_log(char *);
 extern void show_log_dialog(struct conversation *);
-extern void show_fgcolor_dialog(struct conversation *c, GtkWidget *color);
-extern void show_bgcolor_dialog(struct conversation *c, GtkWidget *color);
+extern void show_out_fgcolor_dialog(struct conversation *c, GtkWidget *color);
+extern void show_out_bgcolor_dialog(struct conversation *c, GtkWidget *color);
+extern void show_def_fgcolor_dialog(struct conversation *c, GtkWidget *color);
+extern void show_def_bgcolor_dialog(struct conversation *c, GtkWidget *color);
 extern void cancel_fgcolor(GtkWidget *widget, struct conversation *c);
 extern void cancel_bgcolor(GtkWidget *widget, struct conversation *c);
 extern void create_away_mess(GtkWidget *, void *);
@@ -452,6 +467,8 @@
 extern GtkWidget *picture_button(GtkWidget *, char *, char **);
 extern GtkWidget *picture_button2(GtkWidget *, char *, char **, short);
 extern int file_is_dir(const char *, GtkWidget *);
+/* extern void win_move(GtkWidget *w, GdkEventConfigure *e, gpointer data); */
+extern void win_move(GtkIMHtml *imhtml);
 
 /* Functions in multi.c */
 extern void account_editor(GtkWidget *, GtkWidget *);
@@ -474,8 +491,10 @@
 extern void build_block_list();
 extern GtkWidget *prefs_away_list;
 extern GtkWidget *prefs_away_menu;
-extern GtkWidget *pref_fg_picture;
-extern GtkWidget *pref_bg_picture;
+extern GtkWidget *pref_out_fg_picture;
+extern GtkWidget *pref_out_bg_picture;
+extern GtkWidget *pref_def_fg_picture;
+extern GtkWidget *pref_def_bg_picture;
 
 /* Functions in prpl.c */
 extern void register_dialog();
diff -Nru gaim-0.58/src/util.c gaim-0.58-t/src/util.c
--- gaim-0.58/src/util.c	Tue May  7 20:21:26 2002
+++ gaim-0.58-t/src/util.c	Wed Jun 12 20:09:47 2002
@@ -750,15 +750,23 @@
 		strcpy(buf, tmp);
 	}
 
-	if (font_options & OPT_FONT_FGCOL) {
-		g_snprintf(tmp, length, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", fgcolor.red,
-			   fgcolor.green, fgcolor.blue, buf);
+	if (font_options & OPT_FONT_OUT_FGCOL) {
+		g_snprintf(tmp, length, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", out_fgcolor.red,
+			   out_fgcolor.green, out_fgcolor.blue, buf);
+		strcpy(buf, tmp);
+	} else if (font_options & OPT_FONT_DEF_FGCOL) {
+		g_snprintf(tmp, length, "<FONT COLOR=\"#%02X%02X%02X\">%s</FONT>", def_fgcolor.red,
+			   def_fgcolor.green, def_fgcolor.blue, buf);
 		strcpy(buf, tmp);
 	}
 
-	if (font_options & OPT_FONT_BGCOL) {
-		g_snprintf(tmp, length, "<BODY BGCOLOR=\"#%02X%02X%02X\">%s</BODY>", bgcolor.red,
-			   bgcolor.green, bgcolor.blue, buf);
+	if (font_options & OPT_FONT_OUT_BGCOL) {
+		g_snprintf(tmp, length, "<BODY BGCOLOR=\"#%02X%02X%02X\">%s</BODY>", out_bgcolor.red,
+			   out_bgcolor.green, out_bgcolor.blue, buf);
+		strcpy(buf, tmp);
+	} else if (font_options & OPT_FONT_DEF_BGCOL) {
+		g_snprintf(tmp, length, "<BODY BGCOLOR=\"#%02X%02X%02X\">%s</BODY>", def_bgcolor.red,
+			   def_bgcolor.green, def_bgcolor.blue, buf);
 		strcpy(buf, tmp);
 	}
 
