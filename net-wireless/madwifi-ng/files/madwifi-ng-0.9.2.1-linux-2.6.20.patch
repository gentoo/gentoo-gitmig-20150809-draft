Index: madwifi-0.9.2.1/ath_hal/ah_osdep.h
===================================================================
--- madwifi-0.9.2.1.orig/hal/linux/ah_osdep.h
+++ madwifi-0.9.2.1/hal/linux/ah_osdep.h
@@ -40,12 +40,12 @@
 
 /*
- * Starting with 2.6.4 the kernel supports a configuration option
- * to pass parameters in registers.  If this is enabled we must
- * mark all function interfaces in+out of the HAL to pass parameters
- * on the stack as this is the convention used internally (for
- * maximum portability).
+ * Linux on i386 may pass parameters in registers.  This is an option
+ * starting with Linux 2.6.4.  Starting with Linux 2.6.20, it's done
+ * unconditionally.  However, the HAL uses standard ABI whereas the
+ * parameters are passed on the stack (for maximum portability).
+ * "asmlinkage" forces the standard ABI for the HAL calls.
  */
-#ifdef CONFIG_REGPARM
-#define	__ahdecl	__attribute__((regparm(0)))
+#ifdef __i386__
+#define	__ahdecl	asmlinkage
 #else
 #define	__ahdecl
Index: madwifi-0.9.2.1/ath/if_ath.c
===================================================================
--- madwifi-0.9.2.1.orig/ath/if_ath.c
+++ madwifi-0.9.2.1/ath/if_ath.c
@@ -118,7 +118,7 @@ static void ath_fatal_tasklet(TQUEUE_ARG
 static void ath_rxorn_tasklet(TQUEUE_ARG);
 static void ath_bmiss_tasklet(TQUEUE_ARG);
 static void ath_bstuck_tasklet(TQUEUE_ARG);
-static void ath_radar_task(TQUEUE_ARG);
+static void ath_radar_task(struct work_struct *);
 static void ath_dfs_test_return(unsigned long);
 
 static int ath_stop_locked(struct net_device *);
@@ -414,7 +414,7 @@ ath_attach(u_int16_t devid, struct net_d
 	ATH_INIT_TQUEUE(&sc->sc_bstucktq,ath_bstuck_tasklet,	dev);
 	ATH_INIT_TQUEUE(&sc->sc_rxorntq, ath_rxorn_tasklet,	dev);
 	ATH_INIT_TQUEUE(&sc->sc_fataltq, ath_fatal_tasklet,	dev);
-	ATH_INIT_SCHED_TASK(&sc->sc_radartask, ath_radar_task,	dev);
+	ATH_INIT_WORK(&sc->sc_radartask, ath_radar_task);
 
 	/*
 	 * Attach the hal and verify ABI compatibility by checking
@@ -934,7 +934,7 @@ ath_detach(struct net_device *dev)
 	ath_hal_setpower(sc->sc_ah, HAL_PM_AWAKE);
 	/* Flush the radar task if it's scheduled */
 	if (sc->sc_rtasksched == 1)
-		ATH_FLUSH_TASKS();
+		flush_scheduled_work();
 
 	sc->sc_invalid = 1;
 
@@ -1707,10 +1707,9 @@ ath_intr(int irq, void *dev_id, struct p
 }
 
 static void
-ath_radar_task(TQUEUE_ARG data)
+ath_radar_task(struct work_struct *thr)
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct ath_softc *sc = dev->priv;
+	struct ath_softc *sc = container_of(thr, struct ath_softc, sc_radartask);
 	struct ath_hal *ah = sc->sc_ah;
 	struct ieee80211com *ic = &sc->sc_ic;
 	struct ieee80211_channel ichan;
@@ -5634,7 +5633,7 @@ rx_next:
 	ath_hal_rxmonitor(ah, &sc->sc_halstats, &sc->sc_curchan);
 	if (ath_hal_radar_event(ah)) {
 		sc->sc_rtasksched = 1;
-		ATH_SCHEDULE_TASK(&sc->sc_radartask);
+		schedule_work(&sc->sc_radartask);
 	}
 #undef PA2DESC
 }
Index: madwifi-0.9.2.1/ath/if_athvar.h
===================================================================
--- madwifi-0.9.2.1.orig/ath/if_athvar.h
+++ madwifi-0.9.2.1/ath/if_athvar.h
@@ -71,22 +71,22 @@ typedef void *TQUEUE_ARG;
 #include <linux/sched.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)
 #include <linux/tqueue.h>
-#define ATH_WORK_THREAD			tq_struct
-#define ATH_SCHEDULE_TASK(t)		schedule_task((t))
-#define ATH_INIT_SCHED_TASK(t, f, d) do { 	\
+#define work_struct			tq_struct
+#define schedule_work(t)		schedule_task((t))
+#define flush_scheduled_work()		flush_scheduled_tasks()
+#define ATH_INIT_WORK(t, f) do { 	\
 	memset((t),0,sizeof(struct tq_struct)); 	\
 	(t)->routine = (void (*)(void*)) (f); 	\
-	(t)->data=(void *) (d); 		\
+	(t)->data=(void *) (t); 		\
 } while (0)
-#define ATH_FLUSH_TASKS			flush_scheduled_tasks
 #else
 #include <linux/workqueue.h>
-#define ATH_SCHEDULE_TASK(t)		schedule_work((t))
 
-#define ATH_INIT_SCHED_TASK(_t, _f, _d)	INIT_WORK((_t), (void (*)(void *))(_f), (void *)(_d));
-
-#define ATH_WORK_THREAD			work_struct
-#define	ATH_FLUSH_TASKS			flush_scheduled_work
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#define ATH_INIT_WORK(_t, _f)	INIT_WORK((_t), (void (*)(void *))(_f), (void *)(_t));
+#else
+#define ATH_INIT_WORK(_t, _f)	INIT_WORK((_t), (_f));
+#endif
 #endif /* KERNEL_VERSION < 2.5.41 */
 
 /*
@@ -613,7 +613,7 @@ struct ath_softc {
 
 	struct timer_list sc_cal_ch;		/* calibration timer */
 	HAL_NODE_STATS sc_halstats;		/* station-mode rssi stats */
-	struct ATH_WORK_THREAD sc_radartask;	/* Schedule task for DFS handling */
+	struct work_struct sc_radartask;	/* Schedule task for DFS handling */
 
 #ifdef CONFIG_SYSCTL
 	struct ctl_table_header *sc_sysctl_header;
Index: madwifi-0.9.2.1/hal/linux/ah_osdep.c
===================================================================
--- madwifi-0.9.2.1.orig/hal/linux/ah_osdep.c
+++ madwifi-0.9.2.1/hal/linux/ah_osdep.c
@@ -51,6 +51,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/jiffies.h>
 
 #include <linux/sysctl.h>
 #include <linux/proc_fs.h>
Index: madwifi-0.9.2.1/net80211/ieee80211_linux.h
===================================================================
--- madwifi-0.9.2.1.orig/net80211/ieee80211_linux.h
+++ madwifi-0.9.2.1/net80211/ieee80211_linux.h
@@ -276,9 +276,15 @@ struct ieee80211_cb {
  * mbuf packet header to store this data.
  * XXX use private cb area
  */
-#define	M_AGE_SET(skb,v)	(skb->csum = v)
-#define	M_AGE_GET(skb)		(skb->csum)
-#define	M_AGE_SUB(skb,adj)	(skb->csum -= adj)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#define skb_age csum_offset
+#else
+#define skb_age csum
+#endif
+
+#define	M_AGE_SET(skb,v)	(skb->skb_age = v)
+#define	M_AGE_GET(skb)		(skb->skb_age)
+#define	M_AGE_SUB(skb,adj)	(skb->skb_age -= adj)
 
 struct ieee80211com;
 struct ieee80211vap;
@@ -415,6 +421,8 @@ static __inline unsigned long msecs_to_j
 
 #endif
 
+#include <linux/jiffies.h>
+
 #ifndef CLONE_KERNEL
 /*
  * List of flags we want to share for kernel threads,
@@ -423,6 +431,7 @@ static __inline unsigned long msecs_to_j
 #define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
 #endif
 
+#include <linux/mm.h>
 #ifndef offset_in_page
 #define	offset_in_page(p) ((unsigned long) (p) & ~PAGE_MASK)
 #endif
