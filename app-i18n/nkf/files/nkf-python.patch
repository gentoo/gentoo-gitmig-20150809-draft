diff -Naur nkf205/NKF.python/NKF_python.c nkf205-py/NKF.python/NKF_python.c
--- nkf205/NKF.python/NKF_python.c	Thu Jan  1 09:00:00 1970
+++ nkf205-py/NKF.python/NKF_python.c	Thu Apr 14 23:16:11 2005
@@ -0,0 +1,185 @@
+/**  Python Interface to NKF
+***************************************************************************
+**  Copyright (c) 2005 Matsumoto, Tadashi <ma2@city.plala.jp>
+**  All Rights Reserved.
+**
+**    Everyone is permitted to do anything on this program
+**    including copying, modifying, improving,
+**    as long as you don't try to pretend that you wrote it.
+**    i.e., the above copyright notice has to appear in all copies.
+**    Binary distribution requires original version messages.
+**    You don't have to ask before copying, redistribution or publishing.
+**    THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+***************************************************************************/
+
+#include "Python.h"
+#include <setjmp.h>
+
+#define PYNKF_OPTSLEN 100
+
+#undef getc
+#undef ungetc
+#define getc(f)         pynkf_getc(f)         
+#define ungetc(c,f)     pynkf_ungetc(c,f)
+
+#undef putchar
+#undef TRUE
+#undef FALSE
+#define putchar(c)      pynkf_putchar(c)
+
+static char *PYNKF_ARGV[PYNKF_OPTSLEN/2 + 3];
+static long pynkf_ibufsize, pynkf_obufsize;
+static unsigned char *pynkf_inbuf, *pynkf_outbuf;
+static int pynkf_icount,pynkf_ocount;
+static unsigned char *pynkf_iptr, *pynkf_optr;
+static jmp_buf env;
+
+static int 
+pynkf_getc(FILE *f)
+{unsigned char c;
+ if (pynkf_icount >= pynkf_ibufsize) return EOF;
+ c = *pynkf_iptr++;
+ pynkf_icount++;
+ return (int)c;
+}
+
+static int 
+pynkf_ungetc(int c, FILE *f)
+{
+  if (pynkf_icount--){
+    *(--pynkf_iptr) = c;
+    return c;
+  }else{ return EOF; }
+}
+
+static void
+pynkf_putchar(int c)
+{
+  size_t size;
+  unsigned char *p;
+
+  if (pynkf_ocount--){
+    *pynkf_optr++ = c;
+  }else{
+    size = pynkf_obufsize + pynkf_obufsize;
+    p = (unsigned char *)PyMem_Realloc(pynkf_outbuf, size + 1);
+    if (pynkf_outbuf == NULL){ longjmp(env, 1); }
+    pynkf_outbuf = p;
+    pynkf_optr = pynkf_outbuf + pynkf_obufsize;
+    pynkf_ocount = pynkf_obufsize;
+    pynkf_obufsize = size;
+    *pynkf_optr++ = c;
+    pynkf_ocount--;
+  }
+}
+
+#define PERL_XS 1
+#include "../utf8tbl.c"
+#include "../nkf.c"
+
+static void
+pynkf_parseopts(char *opts, int *argcp, char **argv)
+{
+  register char *p;
+  register int argc, flg;
+  p = opts;
+  argc = 1;
+  flg = 1;
+  *argv++ = "nkf";
+  while(*p){
+    if (*p == ' '){ *p = '\0'; flg = 1; p++; continue; } 
+    if (*p != ' ' && flg){*argv++ = p; argc++; flg = 0; }
+    p++;
+  }
+  *argcp = argc;
+}
+
+static PyObject *
+pynkf_convert(unsigned char* str, long strlen, char* opts, int optslen)
+{
+  unsigned char *cp;
+  int argc;
+  char **argv;
+  register char **p;
+  PyObject * res;
+
+  if (optslen > PYNKF_OPTSLEN) {
+    PyErr_SetString(PyExc_ValueError, "Too many options.");
+    return NULL;
+  }
+  pynkf_ibufsize = strlen + 1;
+  pynkf_obufsize = pynkf_ibufsize * 1.5 + 256;
+  pynkf_outbuf = (unsigned char *)PyMem_Malloc(pynkf_obufsize);
+  if (pynkf_outbuf == NULL){
+    PyErr_NoMemory();
+    return NULL;
+  }
+  pynkf_outbuf[0] = '\0';
+  pynkf_ocount = pynkf_obufsize;
+  pynkf_optr = pynkf_outbuf;
+  pynkf_icount = 0;
+  pynkf_inbuf  = str;
+  pynkf_iptr = pynkf_inbuf;
+  argv = PYNKF_ARGV;
+
+  pynkf_parseopts(opts, &argc, argv);
+
+  if (setjmp(env) == 0){
+
+    reinit();
+
+    p = argv;
+    for (argc--,p++; (argc > 0) && **p == '-'; argc--, p++) {
+        cp = *p;
+        options(cp);
+    }
+
+    if(x0201_f == WISH_TRUE)
+      x0201_f = ((!iso2022jp_f)? TRUE : NO_X0201);
+
+    kanji_convert(NULL);
+
+  }else{
+    PyMem_Free(pynkf_outbuf);
+    PyErr_NoMemory();
+    return NULL;
+  }
+
+  *pynkf_optr = 0;
+  res = PyString_FromString(pynkf_outbuf);
+  PyMem_Free(pynkf_outbuf);
+  return res;
+}
+
+#ifndef EXTERN_NKF
+static
+#endif
+PyObject *pynkf_nkf(PyObject *self, PyObject *args)
+{
+  unsigned char *str;
+  long strlen;
+  char *opts;
+  int optslen;
+  PyObject* res;
+
+  if (!PyArg_ParseTuple(args, "s#s#", &opts, &optslen, &str, &strlen)) {
+    return NULL;
+  }
+  res = pynkf_convert(str, strlen, opts, optslen);
+  return res;
+}
+
+#ifndef EXTERN_NKF
+static PyMethodDef
+nkfmethods[] = {
+  {"nkf", pynkf_nkf, METH_VARARGS},
+  {NULL, NULL}
+};
+
+/* Module initialization function */
+void
+initnkf(void)
+{
+  Py_InitModule("nkf", nkfmethods);
+}
+#endif
diff -Naur nkf205/NKF.python/README nkf205-py/NKF.python/README
--- nkf205/NKF.python/README	Thu Jan  1 09:00:00 1970
+++ nkf205-py/NKF.python/README	Thu Apr 14 23:16:11 2005
@@ -0,0 +1,12 @@
+Python Interface to NKF
+
+1. How to Install
+
+    # python setup.py install
+
+2. Usage
+
+    from nkf import nkf
+    output = nkf(flag, input)
+
+Matsumoto, Tadashi  ma2@city.plala.jp
diff -Naur nkf205/NKF.python/setup.py nkf205-py/NKF.python/setup.py
--- nkf205/NKF.python/setup.py	Thu Jan  1 09:00:00 1970
+++ nkf205-py/NKF.python/setup.py	Thu Apr 14 23:16:11 2005
@@ -0,0 +1,11 @@
+#!/usr/bin/env python
+
+from distutils.core import setup, Extension
+
+setup (name = "nkf",
+       version="1.0",
+       description="Python Interface to NKF",
+       author="Matsumoto Tadashi",
+       author_email="ma2@city.plala.jp",
+       ext_modules = [
+               Extension("nkf", ["NKF_python.c"])])
