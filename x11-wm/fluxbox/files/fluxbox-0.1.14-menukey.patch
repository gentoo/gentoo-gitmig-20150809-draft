diff -uNr fluxbox-0.1.13-orig/src/Basemenu.cc fluxbox-0.1.13/src/Basemenu.cc
--- fluxbox-0.1.13-orig/src/Basemenu.cc	2002-11-15 23:24:59.000000000 +0900
+++ fluxbox-0.1.13/src/Basemenu.cc	2002-11-20 14:11:11.000000000 +0900
@@ -136,6 +136,8 @@
 				m_screen->getDepth(), InputOutput,
 				m_screen->getVisual(), attrib_mask, &attrib);
 	fluxbox->saveMenuSearch(menu.frame, this);
+
+	menu.highlighted = -1;
 	
 }
 
@@ -428,6 +430,7 @@
 
 	torn = visible = false;
 	which_sub = which_press = which_sub = -1;
+	menu.highlighted = -1;
 
 	XUnmapWindow(m_display, menu.window);
 }
@@ -759,6 +762,11 @@
 			break;
 		}
 	}
+	if (highlight) {
+		if (menu.highlighted != (int)index)
+			drawItem(menu.highlighted, False, True);
+		menu.highlighted = index;
+	}
 }
 
 
@@ -1078,3 +1086,41 @@
 	menu.bevel_w = m_screen->getBevelWidth();
 	update();
 }
+
+void Basemenu::highlightNextItem() {
+	if (menu.highlighted >= 0)
+		drawItem(menu.highlighted, False, True);
+
+	menu.highlighted++;
+	if (menu.highlighted >= (int)menuitems.size())
+		menu.highlighted = 0;
+
+	drawItem(menu.highlighted, True);
+}
+
+void Basemenu::highlightPrevItem() {
+	if (menu.highlighted >= 0)
+		drawItem(menu.highlighted, False, True);
+
+	menu.highlighted--;
+	if (menu.highlighted < 0)
+		menu.highlighted = menuitems.size() - 1;
+
+	drawItem(menu.highlighted, True);
+}
+
+void Basemenu::selectMenuItem() {
+	if (menu.highlighted >= 0)
+		itemSelected(1, menu.highlighted);
+}
+
+void Basemenu::openSubmenu() {
+	if (menu.highlighted >= 0)
+		if (hasSubmenu(menu.highlighted)) {
+			drawSubmenu(menu.highlighted);
+		}
+}
+
+void Basemenu::closeMenu() {
+	internal_hide();
+}
diff -uNr fluxbox-0.1.13-orig/src/Basemenu.hh fluxbox-0.1.13/src/Basemenu.hh
--- fluxbox-0.1.13-orig/src/Basemenu.hh	2002-11-04 03:45:30.000000000 +0900
+++ fluxbox-0.1.13/src/Basemenu.hh	2002-11-20 14:11:11.000000000 +0900
@@ -88,6 +88,11 @@
 	virtual void drawSubmenu(unsigned int index);
 	virtual void show();
 	virtual void hide();
+	virtual void highlightNextItem();
+	virtual void highlightPrevItem();
+	virtual void selectMenuItem();
+	virtual void openSubmenu();
+	virtual void closeMenu();
 	/*@}*/
 	
 	/**
@@ -153,6 +158,7 @@
 			grab_x, grab_y;
 		unsigned int width, height, title_h, frame_h, item_w, item_h, bevel_w,
 			bevel_h;
+		int highlighted;
 	} menu;
 
 };
diff -uNr fluxbox-0.1.13-orig/src/Keys.cc fluxbox-0.1.13/src/Keys.cc
--- fluxbox-0.1.13-orig/src/Keys.cc	2002-11-13 23:34:24.000000000 +0900
+++ fluxbox-0.1.13/src/Keys.cc	2002-11-20 14:11:11.000000000 +0900
@@ -122,6 +122,12 @@
 	{"ToggleDecor", TOGGLEDECOR},	
 	{"ToggleTab", TOGGLETAB}, 
 	{"RootMenu", ROOTMENU},
+	{"WindowMenu", WINDOWMENU},
+	{"NextMenuItem", NEXTMENUITEM},
+	{"PrevMenuItem", PREVMENUITEM},
+	{"SelectMenuItem", SELECTMENUITEM},
+	{"OpenSubmenu", OPENSUBMENU},
+	{"CloseMenu", CLOSEMENU},
 	{0, LASTKEYGRAB}
 	};	
 
diff -uNr fluxbox-0.1.13-orig/src/Keys.hh fluxbox-0.1.13/src/Keys.hh
--- fluxbox-0.1.13-orig/src/Keys.hh	2002-11-13 23:35:01.000000000 +0900
+++ fluxbox-0.1.13/src/Keys.hh	2002-11-20 14:11:11.000000000 +0900
@@ -59,6 +59,10 @@
 			TOGGLEDECOR,// toggle visibility of decor (title, frame, handles)
 			TOGGLETAB,  // toggle visibilty of tab
 			ROOTMENU,   // pop up rootmenu
+			WINDOWMENU, // pop up windowmenu
+			NEXTMENUITEM, PREVMENUITEM, // navigate to next/prev item
+			SELECTMENUITEM, // select current menu item
+			OPENSUBMENU, CLOSEMENU, // open/close (sub)menu
 			LASTKEYGRAB //mark end of keygrabbs
 	};
 	/**
diff -uNr fluxbox-0.1.13-orig/src/fluxbox.cc fluxbox-0.1.13/src/fluxbox.cc
--- fluxbox-0.1.13-orig/src/fluxbox.cc	2002-11-15 21:19:17.000000000 +0900
+++ fluxbox-0.1.13/src/fluxbox.cc	2002-11-20 14:11:48.000000000 +0900
@@ -1391,6 +1391,25 @@
 				}
 			}
 			break;
+			case Keys::NEXTMENUITEM:
+			case Keys::PREVMENUITEM:
+			case Keys::SELECTMENUITEM:
+			case Keys::OPENSUBMENU:
+			case Keys::CLOSEMENU:
+			{
+				Basemenu *target = 0;
+				std::map<Window, Basemenu *>::iterator it = menuSearch.begin();
+				std::map<Window, Basemenu *>::iterator it_end = menuSearch.end();
+				for (int i = 0; it != it_end; ++it, ++i) {
+					Basemenu *menu = it->second;
+					if (menu != target && menu->isVisible() && menu->currentSubmenu() < 0) {
+						target = menu;
+					}
+				}
+				if (target != 0)
+					doMenuAction(target, action);
+			}
+			break;
 			default: //try to see if its a window action
 				doWindowAction(action, key->getParam());
 			}
@@ -1404,6 +1423,27 @@
 	
 	
 }
+void Fluxbox::doMenuAction(Basemenu *target, Keys::KeyAction action) {
+	switch (action) {
+	case Keys::NEXTMENUITEM:
+		target->highlightNextItem();
+	break;
+	case Keys::PREVMENUITEM:
+		target->highlightPrevItem();
+	break;
+	case Keys::SELECTMENUITEM:
+		target->selectMenuItem();
+	break;
+	case Keys::OPENSUBMENU:
+		target->openSubmenu();
+	break;
+	case Keys::CLOSEMENU:
+		target->closeMenu();
+	break;
+	default:
+	break;
+	}
+}
 void Fluxbox::doWindowAction(Keys::KeyAction action, const int param) {
 	if (!focused_window)
 		return;
@@ -1551,6 +1591,26 @@
 		case Keys::TOGGLETAB:
 			focused_window->setTab(!focused_window->hasTab());
 		break;
+		case Keys::WINDOWMENU:
+		{
+			Windowmenu *menu = 0;
+
+			menu = focused_window->getWindowmenu();
+			if (menu) {
+				int x, y;
+				x = focused_window->getXFrame();
+				y = focused_window->getYFrame();
+				focused_window->showMenu(x, y);
+//				menu->move(x, y);
+//				if (! menu->isVisible()) {
+//					menu->show();
+//					XRaiseWindow(getXDisplay(), menu->windowID());
+//					XRaiseWindow(getXDisplay(), menu->getSendToMenu()->windowID());
+//					XRaiseWindow(getXDisplay(), menu->getSendGroupToMenu()->windowID());
+//				}
+			}
+		}
+		break;
 		default: //do nothing
 		break;							
 	}
diff -uNr fluxbox-0.1.13-orig/src/fluxbox.hh fluxbox-0.1.13/src/fluxbox.hh
--- fluxbox-0.1.13-orig/src/fluxbox.hh	2002-10-24 06:47:59.000000000 +0900
+++ fluxbox-0.1.13/src/fluxbox.hh	2002-11-20 14:11:11.000000000 +0900
@@ -221,6 +221,7 @@
 	void handleClientMessage(XClientMessageEvent &ce);
 	void handleKeyEvent(XKeyEvent &ke);	
 	void doWindowAction(Keys::KeyAction action, const int param);
+	void doMenuAction(Basemenu *menu, Keys::KeyAction action);
 
 	ResourceManager m_resourcemanager, m_screen_rm;
 	
