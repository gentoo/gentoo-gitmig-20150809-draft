--- distcc-1.2.orig/src/distcc.c	2003-02-21 17:25:48.000000000 -0800
+++ distcc-1.2/src/distcc.c	2003-02-23 13:55:45.000000000 -0800
@@ -481,6 +481,156 @@
     }
 }
 
+static char *dcc_safe_getcwd(void) 
+{
+	char *cwdstr;
+	size_t len = 200;
+
+	do {
+		cwdstr = malloc(len);
+		if (NULL == cwdstr) break;
+
+		if (NULL == getcwd(cwdstr, len)) {
+			free(cwdstr);
+			cwdstr = NULL;
+			if (ERANGE == errno) {
+				len += 200;
+				continue;
+			}
+		}
+	} while(0);
+
+	if (NULL == cwdstr) {
+		rs_log_error("can't get working directory");
+		exit(1);
+	}
+
+	return cwdstr;
+}
+
+/**
+ * Filter PATH past point that wrapper was called
+ */
+static void dcc_wrapper_trunc_path(char *progname, char *path, char *argv[]) 
+{
+    static const char *envpath = "PATH=";
+    const char *p;
+    char *n, *str;
+    char *ppath = NULL;
+    int len, maxlen, plen = 0;
+
+    maxlen = strlen(path) + strlen(envpath) + 1;
+    str = malloc(maxlen);
+    if (NULL == str) exit(1);
+
+    /* if we were called explicitly, find the (partial) path */
+    if (progname != argv[0]) {
+    	/* eliminate this explicit path from PATH */ 
+        char *cwdstr = NULL;
+	size_t cwdlen = 0;
+
+	if ('/' != argv[0][0]) {
+		cwdstr = dcc_safe_getcwd();
+		cwdlen = strlen(cwdstr);
+		/* or we could just error out and exit??? */
+	}
+
+	plen = progname - argv[0] - 1;
+	len = cwdlen + plen;
+        ppath = malloc(len);
+	if (NULL == ppath) exit(1);
+
+	ppath[0] = 0;
+	if (NULL != cwdstr) {
+		strncpy(ppath, cwdstr, len);
+		ppath[cwdlen++] = '/';
+		ppath[cwdlen] = 0;
+		free(cwdstr);
+	}
+	strncat(ppath, argv[0], cwdlen + plen);
+	rs_trace("looking for explicit path: %s\n", ppath);
+    }
+    else
+        ppath = NULL;
+	    
+    for (p = n = path; NULL != n; p = n ? n + 1 : NULL) {
+        n = strchr(p, ':');
+        if (NULL != n)	
+            len = n - p;
+	else
+            len = strlen(p);
+
+        if (NULL != ppath) {
+	    /* check for partial path name match,
+	        pmatch is last portion of path */
+	    rs_trace("checking for ppath in %s\n", p);
+            if (len != plen || 0 != strncmp(p, ppath, len))
+                continue;
+        }
+	else {
+	    strncpy(str, p, len);
+            snprintf(str + len, maxlen - len, "/%s", progname);
+	    rs_trace("checking %s\n", str);
+            if (0 != access(str, X_OK))
+                continue;
+	    rs_trace("found %s\n", str);
+        }
+        /* getting here means either we found the path we ran in, or
+           we found the target program we're trying to run;
+           so PATH now starts at next entry */
+	if (NULL != n)
+	    p = n + 1;
+	else
+	    p = "";
+        break;
+    }
+
+    /* if temp path, p, still contains something, reset PATH;
+       p will be NULL if relative or non-PATH invocation, so
+       the current path is probably free from recursion */
+    if (NULL != p) {
+	strncpy(str, envpath, maxlen);
+	strncat(str, p, maxlen);
+	rs_trace("wrapper is setting %s\n", str);
+	n = strdup(str);
+        if ((NULL == n) || (-1 == putenv(n))) {
+                rs_log_error("putenv PATH failed");
+                exit(1);
+        }
+    }
+    else
+        rs_trace("wrapper not modifying PATH");
+
+    free(str);
+    free(ppath);
+}
+
+static char *dcc_support_wrapper(char *argv[])
+{
+    char *progname, *envstr;
+
+    /* see if program was called with a full or partial path */
+    if ((progname = strrchr(argv[0], '/')) != NULL)
+        progname++;
+    else
+        progname = argv[0];
+
+    if (NULL == (envstr = getenv("DISTCC_HOSTS"))) {
+    	char localonly[] = "DISTCC_HOSTS=localhost";
+    	if (-1 == putenv(localonly)) {
+            rs_log_error("unable to set default DISTCC_HOSTS");
+	    exit(1);
+	}
+    }
+
+    /* right now, we're only playing with path... but
+       wouldn't it be interesting to look at CHOST, too? */
+    if (NULL != (envstr = getenv("PATH")))
+        dcc_wrapper_trunc_path(progname, envstr, argv);
+    
+    return progname;
+}
+
 
 /**
  * distcc client entry point.
@@ -490,6 +640,7 @@
  * Performs basic setup and checks for distcc arguments, and then kicks of
  * dcc_build_somewhere().
  **/
+#include <libgen.h>
 int main(int argc, char **argv)
 {
     int status;
@@ -499,17 +650,25 @@
 
     dcc_set_trace_from_env();
 
-    if (argc <= 1 || !strcmp(argv[1], "--help")) {
-        dcc_show_usage();
-        exit(0);
-    } else if (!strcmp(argv[1], "--version")) {
-        dcc_show_version("distcc");
-        exit(0);
-    }
-
     dcc_recursion_safeguard();
 
-    dcc_find_compiler(argv, &compiler_args);
+    if (NULL != strstr(basename(argv[0]), "distcc")) {
+
+        if (argc <= 1 || !strcmp(argv[1], "--help")) {
+            dcc_show_usage();
+            exit(0);
+        } else if (!strcmp(argv[1], "--version")) {
+            dcc_show_version("distcc");
+            exit(0);
+        }
+
+        dcc_find_compiler(argv, &compiler_args);
+    }
+    else {
+    	char *progname = dcc_support_wrapper(argv);
+        dcc_shallowcopy_argv(argv, &compiler_args, 0);
+        compiler_args[0] = progname;
+    }
 
     dcc_exit(dcc_build_somewhere(compiler_args, &status));
 }
